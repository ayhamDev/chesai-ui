
# AI Prompt Context for chesai-ui Component Library

You are an expert React developer tasked with assisting in the development of the "chesai-ui" library. The following document contains the complete source code for all UI components, hooks, contexts, and styling configurations.

**Your Task for Usage:**
import { ComponentName } from 'chesai-ui'

**Your Task for development:**
- Use this file as the single source of truth for the entire library.
- When asked to create, modify, or extend any part of the library, refer to its source code provided here.
- Maintain the existing coding style, architecture, and conventions (e.g., using CVA, Radix UI, Framer Motion).
- Provide complete, copy-pasteable code blocks for your solutions.

---

## UI Components


### Component: `accordion`

This section contains the source code for the `accordion` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\accordion\index.tsx`)**
```tsx
"use client";

import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { ChevronDown } from "lucide-react";
import React, { createContext, useContext, useRef } from "react";
import useRipple from "use-ripple-hook";

// --- Context for Accordion Configuration ---
interface AccordionContextProps {
  variant: "primary" | "secondary";
  shape: "full" | "minimal" | "sharp";
  layout: "integrated" | "separated";
}

const AccordionContext = createContext<AccordionContextProps | null>(null);

const useAccordionContext = () => {
  const context = useContext(AccordionContext);
  if (!context) {
    throw new Error(
      "useAccordionContext must be used within an AccordionContext.Provider"
    );
  }
  return context;
};
// --- CVA Variants ---
const itemVariants = cva("overflow-hidden transition-colors", {
  variants: {
    variant: {
      primary: "bg-graphite-card",
      secondary: "bg-graphite-secondary",
    },
    layout: {
      integrated: "border-b border-graphite-border last:border-b-0",
      separated: "border border-transparent",
    },
    shape: {
      full: "",
      minimal: "",
      sharp: "",
    },
  },
  compoundVariants: [
    { layout: "separated", shape: "full", className: "rounded-2xl" },
    { layout: "separated", shape: "minimal", className: "rounded-xl" },
    { layout: "separated", shape: "sharp", className: "rounded-none" },
  ],
  defaultVariants: {
    variant: "primary",
    layout: "integrated",
    shape: "minimal",
  },
});

// --- Root Component ---
type AccordionRootProps = React.ComponentPropsWithoutRef<
  typeof AccordionPrimitive.Root
> & {
  variant?: "primary" | "secondary";
  shape?: "full" | "minimal" | "sharp";
  layout?: "integrated" | "separated";
};

const AccordionRoot = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Root>,
  AccordionRootProps
>(
  (
    {
      className,
      variant = "primary",
      shape = "minimal",
      layout = "integrated",
      children,
      ...props
    },
    ref
  ) => (
    <AccordionContext.Provider value={{ variant, shape, layout }}>
      <AccordionPrimitive.Root
        ref={ref}
        className={clsx(
          "w-full",
          layout === "separated" && "space-y-2",
          className
        )}
        {...props}
      >
        {children}
      </AccordionPrimitive.Root>
    </AccordionContext.Provider>
  )
);
AccordionRoot.displayName = "Accordion";

// --- Accordion Item ---
const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => {
  const { variant, shape, layout } = useAccordionContext();
  return (
    <AccordionPrimitive.Item
      ref={ref}
      className={clsx(itemVariants({ variant, shape, layout }), className)}
      {...props}
    />
  );
});
AccordionItem.displayName = "AccordionItem";

// --- Accordion Trigger (MODIFIED) ---
const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger> & {
    /** If true, the ripple effect on click will be disabled. */
    disableRipple?: boolean;
  }
>(({ className, children, disableRipple = false, ...props }, ref) => {
  const localRef = useRef<HTMLButtonElement | null>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(0, 0, 0, 0.1)",
    duration: 400,
    disabled: disableRipple, // Pass the new prop to the hook
  });
  React.useImperativeHandle(ref, () => localRef.current);

  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        ref={localRef}
        onPointerDown={event}
        className={clsx(
          "relative flex flex-1 items-center justify-between p-4 font-semibold text-graphite-foreground transition-all focus:outline-none focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2",
          "[&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  );
});
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

// --- Accordion Content ---
const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={clsx("px-4 pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));
AccordionContent.displayName = AccordionPrimitive.Content.displayName;

// --- Compound Export ---
export const Accordion = Object.assign(AccordionRoot, {
  Item: AccordionItem,
  Trigger: AccordionTrigger,
  Content: AccordionContent,
});
```

**Storybook Stories (`Accordion.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Typography } from "../typography";
import { Accordion } from "./index";

const meta: Meta<typeof Accordion> = {
  title: "Components/Data/Accordion",
  component: Accordion,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A vertically stacked set of interactive headings that each reveal a section of content. Built on Radix UI for accessibility and styled for chesai-ui.",
      },
    },
  },
  argTypes: {
    type: {
      control: "select",
      options: ["single", "multiple"],
      description: "Determines if one or multiple items can be open at once.",
    },
    layout: {
      control: "select",
      options: ["integrated", "separated"],
      description: "The structural layout of the items.",
    },
    variant: {
      control: "select",
      options: ["primary", "secondary"],
      description: "The visual style of the accordion items.",
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "The border-radius of the accordion items.",
    },
    collapsible: {
      control: "boolean",
      description: "When type is 'single', allows closing all items.",
    },
    defaultValue: { control: "text" },
  },
};

export default meta;
type Story = StoryObj<typeof Accordion>;

const AccordionItems = () => (
  <>
    <Accordion.Item value="item-1">
      <Accordion.Trigger>What is chesai-ui?</Accordion.Trigger>
      <Accordion.Content>
        <Typography variant="p">
          chesai-ui is a React component library designed for building modern,
          accessible, and beautiful user interfaces with ease.
        </Typography>
      </Accordion.Content>
    </Accordion.Item>
    <Accordion.Item value="item-2">
      <Accordion.Trigger>Is it accessible?</Accordion.Trigger>
      <Accordion.Content>
        <Typography variant="p">
          Yes. It is built on top of Radix UI primitives, which are fully
          accessible and follow WAI-ARIA design patterns.
        </Typography>
      </Accordion.Content>
    </Accordion.Item>
    <Accordion.Item value="item-3">
      <Accordion.Trigger>Can I customize the styling?</Accordion.Trigger>
      <Accordion.Content>
        <Typography variant="p">
          Absolutely. The library is built with Tailwind CSS and CSS variables,
          making it highly customizable to fit your brand's design system.
        </Typography>
      </Accordion.Content>
    </Accordion.Item>
  </>
);

export const IntegratedLayout: Story = {
  name: "1. Integrated Layout (Default)",
  args: {
    type: "single",
    collapsible: true,
    defaultValue: "item-1",
    layout: "integrated",
    variant: "primary",
  },
  render: (args) => (
    <div className="w-96">
      <Accordion {...args}>
        <AccordionItems />
      </Accordion>
    </div>
  ),
};

export const SeparatedLayout: Story = {
  name: "2. Separated Layout",
  args: {
    type: "single",
    collapsible: true,
    layout: "separated",
    variant: "secondary",
    shape: "minimal",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `separated` layout renders each item as a distinct, card-like element, separated by a gap.",
      },
    },
  },
  render: (args) => (
    <div className="w-96">
      <Accordion {...args}>
        <AccordionItems />
      </Accordion>
    </div>
  ),
};

export const VariantCombinations: Story = {
  name: "3. Variant Combinations",
  args: {
    type: "single",
    collapsible: true,
    layout: "separated",
    shape: "minimal",
  },
  render: (args) => (
    <div className="flex items-start gap-8">
      <div className="w-80">
        <Typography variant="h4" className="mb-4 text-center">
          Layout: Separated
          <br />
          Variant: Primary
        </Typography>
        <Accordion {...args} variant="primary">
          <AccordionItems />
        </Accordion>
      </div>
      <div className="w-80">
        <Typography variant="h4" className="mb-4 text-center">
          Layout: Separated
          <br />
          Variant: Secondary
        </Typography>
        <Accordion {...args} variant="secondary">
          <AccordionItems />
        </Accordion>
      </div>
    </div>
  ),
};

export const MultipleOpen: Story = {
  name: "4. Allow Multiple Open",
  args: {
    type: "multiple",
    layout: "integrated",
    defaultValue: ["item-1", "item-3"],
  },
  parameters: {
    docs: {
      description: {
        story:
          "Set `type='multiple'` to allow users to open more than one item at a time.",
      },
    },
  },
  render: (args) => (
    <div className="w-96">
      <Accordion {...args}>
        <AccordionItems />
      </Accordion>
    </div>
  ),
};

export const RippleControl: Story = {
  name: "5. Ripple Control",
  args: {
    type: "single",
    collapsible: true,
    layout: "integrated",
  },
  parameters: {
    docs: {
      description: {
        story:
          "You can explicitly disable the ripple effect on a trigger by setting `disableRipple={true}` on the `<Accordion.Trigger>` component.",
      },
    },
  },
  render: (args) => (
    <div className="w-96">
      <Accordion {...args}>
        <Accordion.Item value="item-1">
          <Accordion.Trigger>Ripple Enabled (Default)</Accordion.Trigger>
          <Accordion.Content>
            <Typography variant="p">
              Click the trigger to see the ripple effect.
            </Typography>
          </Accordion.Content>
        </Accordion.Item>
        <Accordion.Item value="item-2">
          <Accordion.Trigger disableRipple={true}>
            Ripple Disabled
          </Accordion.Trigger>
          <Accordion.Content>
            <Typography variant="p">
              This trigger will not have a ripple effect.
            </Typography>
          </Accordion.Content>
        </Accordion.Item>
      </Accordion>
    </div>
  ),
};
```


### Component: `appbar`

This section contains the source code for the `appbar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\appbar\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { motion, type HTMLMotionProps } from "framer-motion";
import React from "react";
import { useAppBar } from "../../hooks/useAppBar";

const appBarVariants = cva(
  "absolute top-0 z-40 w-full transition-[colors,box-shadow] duration-300 ease-in-out",
  {
    variants: {
      appBarColor: {
        background: "bg-graphite-background text-graphite-foreground",
        card: "bg-graphite-card text-graphite-foreground",
        primary: "bg-graphite-primary text-graphite-primaryForeground",
        secondary: "bg-graphite-secondary text-graphite-secondaryForeground",
      },
      shadow: {
        none: "shadow-none",
        md: "shadow-sm",
      },
    },
    defaultVariants: {
      appBarColor: "card",
      shadow: "none",
    },
  }
);

export interface AppBarSharedProps {
  scrollBehavior?: "sticky" | "conditionally-sticky";
  animatedBehavior?: Array<"none" | "appbar-color" | "fold" | "shadow">;
  animatedColor?: "background" | "card" | "primary" | "secondary";
  size?: "md" | "lg";
  largeHeaderContent?: React.ReactNode;
  smallHeaderContent?: React.ReactNode;
  stickyHideTarget?: "main-row" | "full-appbar";
  scrollContainerRef?: React.RefObject<HTMLElement | null>;
  // --- NEW CUSTOMIZABLE PROPS ---
  /** The height of the main app bar row in its normal (md) or collapsed state. @default 64 */
  normalHeaderRowHeight?: number;
  /** The height of the main app bar row in its large (lg) expanded state. @default 96 */
  largeHeaderRowHeight?: number;
  /** The scroll distance over which the "fold" animation occurs. @default 50 */
  foldAnimationDistance?: number;
  /** The border-radius applied at the end of the "fold" animation. @default 24 */
  foldBorderRadius?: number;
  // --- MODIFICATION: Add routeKey to shared props ---
  /** A unique key representing the current route, used to reset animations on navigation. */
  routeKey?: string;
}

export interface AppBarProps
  extends Omit<HTMLMotionProps<"header">, "color" | "size">,
    AppBarSharedProps {
  appBarColor?: "background" | "card" | "primary" | "secondary";
  shadow?: "none" | "md";
  startAdornment?: React.ReactNode;
  centerAdornment?: React.ReactNode;
  endAdornments?: React.ReactNode[];
}

const AppBarRoot = React.forwardRef<HTMLElement, AppBarProps>(
  (
    {
      className,
      children,
      startAdornment,
      centerAdornment,
      endAdornments = [],
      appBarColor,
      scrollBehavior,
      animatedBehavior,
      animatedColor,
      size,
      largeHeaderContent,
      smallHeaderContent,
      stickyHideTarget,
      scrollContainerRef,
      // --- MODIFICATION: Destructure routeKey ---
      routeKey,
      // --- DESTRUCTURE NEW PROPS ---
      normalHeaderRowHeight,
      largeHeaderRowHeight,
      foldAnimationDistance,
      foldBorderRadius,
      ...rest
    },
    ref
  ) => {
    const hookProps = {
      appBarColor,
      scrollBehavior,
      animatedBehavior,
      animatedColor,
      size,
      largeHeaderContent,
      smallHeaderContent,
      stickyHideTarget,
      scrollContainerRef,
      // --- MODIFICATION: Pass routeKey to hook ---
      routeKey,
      // --- PASS NEW PROPS TO HOOK ---
      normalHeaderRowHeight,
      largeHeaderRowHeight,
      foldAnimationDistance,
      foldBorderRadius,
    };

    const {
      headerProps,
      mainRowProps,
      largeContentProps,
      childrenContainerProps,
      smallHeaderProps,
      finalColor,
      finalShadow,
      isCollapsible,
      shouldRenderLargeContent,
    } = useAppBar(hookProps);

    return (
      <motion.header
        ref={ref}
        className={clsx(
          appBarVariants({
            appBarColor: finalColor,
            shadow: finalShadow,
            className,
          }),
          (isCollapsible || animatedBehavior?.includes("fold")) &&
            "overflow-hidden"
        )}
        {...headerProps}
        {...rest}
      >
        <motion.div {...mainRowProps} className="flex w-full items-center">
          <div className="flex flex-1 items-center gap-2 px-4 min-w-0">
            {startAdornment && (
              <div className="flex justify-center items-center min-w-max">
                {startAdornment}
              </div>
            )}
            <div className="min-w-0 relative flex-1">
              <motion.div {...childrenContainerProps}>{children}</motion.div>
              {isCollapsible && (
                <motion.div
                  {...smallHeaderProps}
                  className="absolute inset-0 flex items-center"
                >
                  {smallHeaderContent}
                </motion.div>
              )}
            </div>
          </div>
          {centerAdornment && (
            <div className="flex justify-center items-center min-w-max flex-1 ">
              {centerAdornment}
            </div>
          )}
          <div className="flex items-center justify-end gap-1 px-4">
            {endAdornments}
          </div>
        </motion.div>

        {shouldRenderLargeContent && (
          <motion.div {...largeContentProps} className="px-4 pb-4">
            {largeHeaderContent}
          </motion.div>
        )}
      </motion.header>
    );
  }
);
AppBarRoot.displayName = "AppBar";

export const AppBar = AppBarRoot;
```

**Storybook Stories (`Appbar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  ArrowLeft,
  Menu,
  MoreVertical,
  Paperclip,
  Search,
  User,
} from "lucide-react";
import React, { useRef } from "react";
import { useAppBar } from "../../hooks/useAppBar";
import { ElasticScrollArea } from "../elastic-scroll-area";
import { IconButton } from "../icon-button";
import { Typography } from "../typography";
import { AppBar, type AppBarProps } from "./index";

const meta: Meta<typeof AppBar> = {
  title: "Components/AppBar",
  component: AppBar,
  tags: ["autodocs"],
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "A versatile AppBar that is decoupled from its scroll container. It uses a headless hook (`useAppBar`) to manage animations and behavior, allowing it to work with any scrollable element.",
      },
    },
  },
  argTypes: {
    size: {
      control: "select",
      options: ["md", "lg"],
    },
    appBarColor: {
      control: "select",
      options: ["background", "card", "primary", "secondary"],
    },
    scrollBehavior: {
      control: "select",
      options: ["sticky", "conditionally-sticky"],
    },
    animatedBehavior: {
      control: "check",
      options: ["appbar-color", "fold", "shadow"],
    },
    animatedColor: {
      control: "select",
      options: ["background", "card", "primary", "secondary"],
    },
    stickyHideTarget: {
      control: "select",
      options: [undefined, "main-row", "full-appbar"],
    },
    children: { control: false },
    largeHeaderContent: { control: false },
    smallHeaderContent: { control: false },
    startAdornment: { control: false },
    centerAdornment: { control: false },
    endAdornments: { control: false },
    scrollContainerRef: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof AppBar>;

// Helper component to generate scrollable content
const DummyContent = () => (
  <main className="p-6 pt-4">
    <Typography variant="h3">Scroll Down to See The Effect</Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
      {Array.from({ length: 30 }).map((_, i) => (
        // biome-ignore lint/suspicious/noArrayIndexKey: strict
        (<div key={i} className="h-48 rounded-2xl bg-black/5" />)
      ))}
    </div>
  </main>
);

// A mock async function for the onRefresh prop
const simulateRefresh = () => {
  return new Promise((resolve) => setTimeout(resolve, 2000));
};

// A smart render function to wrap stories and demonstrate the headless pattern.
const renderWithScrollContainer = (args: AppBarProps) => {
  const scrollRef = useRef<HTMLDivElement>(null);

  let paddingTop = "pt-[64px]";
  if (args.size === "lg" && args.largeHeaderContent) {
    paddingTop = "pt-[160px]";
  }

  return (
    <div className="h-screen bg-graphite-background">
      <AppBar {...args} scrollContainerRef={scrollRef} />
      <div ref={scrollRef} className={`h-full overflow-y-auto ${paddingTop}`}>
        <DummyContent />
      </div>
    </div>
  );
};

// --- STORIES ---

export const Default: Story = {
  name: "Default (Medium, Sticky)",
  args: {
    size: "md",
    scrollBehavior: "sticky",
    appBarColor: "card",
    children: <Typography variant="h4">Sticky Header</Typography>,
    startAdornment: (
      <IconButton variant="ghost" aria-label="Menu">
        <Menu />
      </IconButton>
    ),
    endAdornments: [
      <IconButton key="user-profile" variant="ghost" aria-label="User Profile">
        <User />
      </IconButton>,
    ],
  },
  render: renderWithScrollContainer,
};

export const ConditionallySticky: Story = {
  name: "Medium, Hiding on Scroll",
  args: {
    ...Default.args,
    scrollBehavior: "conditionally-sticky",
    children: <Typography variant="h4">Hiding Header</Typography>,
  },
  render: renderWithScrollContainer,
};

export const AnimatedColor: Story = {
  name: "Medium, Animated Color",
  args: {
    ...Default.args,
    animatedBehavior: ["appbar-color"],
    appBarColor: "background",
    animatedColor: "card",
    children: <Typography variant="h4">Animated Header</Typography>,
  },
  render: renderWithScrollContainer,
};

export const FoldingOnScroll: Story = {
  name: "Medium, Folding on Scroll",
  args: {
    ...Default.args,
    animatedBehavior: ["fold"],
    children: <Typography variant="h4">Folding Header</Typography>,
  },
  render: renderWithScrollContainer,
};

export const ShadowOnScroll: Story = {
  name: "Medium, Shadow on Scroll",
  args: {
    ...Default.args,
    animatedBehavior: ["shadow"],
    appBarColor: "background",
    children: <Typography variant="h4">Shadow Header</Typography>,
  },
  render: renderWithScrollContainer,
};

export const LargeCollapsing: Story = {
  name: "Large, Fully Collapsible",
  args: {
    size: "lg",
    scrollBehavior: "conditionally-sticky",
    appBarColor: "card",
    startAdornment: (
      <IconButton variant="ghost" aria-label="Back">
        <ArrowLeft />
      </IconButton>
    ),
    endAdornments: [
      <IconButton key="attach" variant="ghost" aria-label="Attach">
        <Paperclip />
      </IconButton>,
      <IconButton key="more" variant="ghost" aria-label="More">
        <MoreVertical />
      </IconButton>,
    ],
    children: (
      <Typography variant="h2" className="truncate font-bold">
        Large Collapsing Title
      </Typography>
    ),
    smallHeaderContent: (
      <Typography variant="h4" className="font-semibold">
        Collapsed Title
      </Typography>
    ),
    largeHeaderContent: (
      <div className="flex items-center gap-2 rounded-full bg-black/5 px-4 py-2">
        <Search className="h-5 w-5 text-gray-500" />
        <input
          type="text"
          placeholder="Search..."
          className="w-full bg-transparent outline-none"
        />
      </div>
    ),
  },
  render: renderWithScrollContainer,
};

export const LargeStatic: Story = {
  name: "Large, Static (No Collapse)",
  args: {
    ...LargeCollapsing.args,
    smallHeaderContent: undefined,
    children: (
      <Typography variant="h2" className="truncate font-bold">
        Large Static Title
      </Typography>
    ),
  },
  render: renderWithScrollContainer,
};

export const LargeStaticWithOverride: Story = {
  name: "Large, Static with Hide Override",
  args: {
    ...LargeStatic.args,
    stickyHideTarget: "main-row",
  },
  render: renderWithScrollContainer,
};

export const CombinedEffects: Story = {
  name: "Kitchen Sink (All Effects)",
  args: {
    ...LargeCollapsing.args,
    animatedBehavior: ["appbar-color", "shadow", "fold"],
    animatedColor: "secondary",
  },
  render: renderWithScrollContainer,
};

// This helper component calls the useAppBar hook safely *after* its parent has mounted and hydrated the ref.
const ElasticScrollContent = ({
  scrollRef,
  args,
}: {
  scrollRef: React.RefObject<HTMLDivElement | null>;
  args: AppBarProps;
}) => {
  // Explicitly pick only the props that the `useAppBar` hook needs.
  const {
    size,
    scrollBehavior,
    animatedBehavior,
    animatedColor,
    largeHeaderContent,
    smallHeaderContent,
    stickyHideTarget,
    appBarColor,
  } = args;

  // By the time this component renders, scrollRef.current is hydrated.
  const { contentPaddingTop } = useAppBar({
    size,
    scrollBehavior,
    animatedBehavior,
    animatedColor,
    largeHeaderContent,
    smallHeaderContent,
    stickyHideTarget,
    appBarColor: appBarColor ?? undefined, // Coalesce null to undefined for type safety
    scrollContainerRef: scrollRef,
  });

  return (
    <div style={{ paddingTop: contentPaddingTop }}>
      <DummyContent />
    </div>
  );
};

export const WithElasticScroll: Story = {
  name: "With Elastic Scroll & Refresh",
  args: {
    ...LargeCollapsing.args,
    animatedBehavior: ["shadow", "fold"],
    scrollBehavior: "conditionally-sticky",
  },
  parameters: {
    docs: {
      description: {
        story:
          "This story demonstrates composing the `AppBar` with `ElasticScrollArea`. We use a child component to safely call the `useAppBar` hook only after the scroll container's `ref` has been attached, preventing hydration errors.",
      },
    },
  },
  render: (args) => {
    // This ref will be passed down and attached by ElasticScrollArea
    const scrollRef = useRef<HTMLDivElement>(null);

    return (
      <div className="h-screen bg-graphite-background">
        {/* AppBar receives the ref but doesn't trigger the hook directly from here */}
        <AppBar {...args} scrollContainerRef={scrollRef} />

        <ElasticScrollArea
          ref={scrollRef}
          className="h-full"
          pullToRefresh={true}
          onRefresh={simulateRefresh}
        >
          {/* Render the child component that safely calls the hook */}
          <ElasticScrollContent scrollRef={scrollRef} args={args} />
        </ElasticScrollArea>
      </div>
    );
  },
};
```


### Component: `avatar`

This section contains the source code for the `avatar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\avatar\AvatarGroup.tsx`)**
```tsx
"use client";

import { clsx } from "clsx";
import React from "react";
import { Avatar, type AvatarProps } from "./index";

export interface AvatarGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  /** The maximum number of avatars to display before showing an overflow count. */
  max?: number;
}

export const AvatarGroup: React.FC<AvatarGroupProps> = ({
  children,
  className,
  max,
  ...props
}) => {
  const childArray = React.Children.toArray(children).filter(
    React.isValidElement
  ) as React.ReactElement<AvatarProps>[];

  const totalAvatars = childArray.length;
  const hasOverflow = max !== undefined && totalAvatars > max;

  const avatarsToShow = hasOverflow ? childArray.slice(0, max) : childArray;
  const overflowCount = totalAvatars - (max || 0);

  const avatarSize = avatarsToShow[0]?.props.size || "md";

  // --- THIS IS THE KEY CHANGE ---
  // We now map avatar sizes to a specific pixel value for the negative margin.
  // This will be used in an inline style object.
  const overlapMargin = {
    xs: "-6px",
    sm: "-10px",
    md: "-14px",
    lg: "-26px",
    xl: "-38px",
  }[avatarSize];
  // --- END OF CHANGE ---

  const hoverEffectClasses =
    "transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:z-50";

  return (
    <div className={clsx("flex items-center", className)} {...props}>
      {avatarsToShow.map((child, index) => {
        // Prepare the style object for each avatar
        const newStyle: React.CSSProperties = {
          ...child.props.style,
          zIndex: index,
        };

        // Apply the negative margin to every avatar EXCEPT the first one
        if (index > 0) {
          newStyle.marginLeft = overlapMargin;
        }

        return React.cloneElement(child, {
          className: clsx(
            child.props.className,
            "ring-2 ring-white dark:ring-graphite-card",
            hoverEffectClasses
          ),
          style: newStyle,
        });
      })}
      {hasOverflow && (
        <Avatar
          variant="count"
          size={avatarSize}
          fallback={`+${overflowCount}`}
          className={clsx(
            "ring-2 ring-white dark:ring-graphite-card",
            hoverEffectClasses
          )}
          // The overflow avatar also gets the negative margin via an inline style
          style={{
            zIndex: max,
            marginLeft: overlapMargin,
          }}
        />
      )}
    </div>
  );
};

AvatarGroup.displayName = "Avatar.Group";
```

**Storybook Stories (`Avatar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Avatar } from "./index";
import { AvatarGroup } from "./AvatarGroup"; // Import AvatarGroup

const meta: Meta<typeof Avatar> = {
  title: "Components/Avatar", // Changed title to be more general
  component: Avatar,
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: "select",
      options: ["xs", "sm", "md", "lg", "xl"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    src: { control: "text" },
    fallback: { control: "text" },
  },
};

export default meta;
type Story = StoryObj<typeof Avatar>;

export const Default: Story = {
  name: "1. Image",
  args: {
    src: "https://i.pravatar.cc/150",
    fallback: "User",
  },
};

export const LoadingSkeleton: Story = {
  name: "2. Loading Skeleton",
  args: {
    // This URL will delay the image load by 2 seconds
    src: "https://www.deelay.me/2000/https://i.pravatar.cc/150?img=1",
    fallback: "User",
    shape: "full",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The Avatar displays a skeleton loader while the image is loading. This is a 2-second delayed image.",
      },
    },
  },
};

export const InitialsFallback: Story = {
  name: "3. Fallback to Initials",
  args: {
    src: "https://broken-url.com/avatar.png",
    fallback: "Alisa Hester",
  },
};

export const GenericFallback: Story = {
  name: "4. Fallback to Icon",
  args: {},
};

export const AllSizes: Story = {
  name: "5. All Sizes",
  render: () => (
    <div className="flex items-center gap-4">
      <Avatar size="xs" fallback="A" />
      <Avatar size="sm" fallback="B" />
      <Avatar size="md" fallback="C" />
      <Avatar size="lg" fallback="D" />
      <Avatar size="xl" fallback="E" />
    </div>
  ),
};

export const AllShapes: Story = {
  name: "6. All Shapes",
  render: () => (
    <div className="flex items-center gap-4">
      <Avatar shape="full" src="https://i.pravatar.cc/150?img=3" />
      <Avatar shape="minimal" src="https://i.pravatar.cc/150?img=4" />
      <Avatar shape="sharp" src="https://i.pravatar.cc/150?img=5" />
    </div>
  ),
};

// --- NEW AVATAR GROUP STORY ---
export const Group: Story = {
  name: "7. Avatar Group",
  render: () => (
    <div className="flex flex-col items-start gap-8">
      <div>
        <h3 className="mb-2 font-semibold">Default Group (md)</h3>
        <AvatarGroup>
          <Avatar src="https://i.pravatar.cc/150?img=1" fallback="A" />
          <Avatar src="https://i.pravatar.cc/150?img=2" fallback="B" />
          <Avatar src="https://i.pravatar.cc/150?img=3" fallback="C" />
          <Avatar src="https://i.pravatar.cc/150?img=4" fallback="D" />
        </AvatarGroup>
      </div>
      <div>
        <h3 className="mb-2 font-semibold">With Max Count (lg)</h3>
        <AvatarGroup max={3}>
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=5"
            fallback="A"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=6"
            fallback="B"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=7"
            fallback="C"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=8"
            fallback="D"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=9"
            fallback="E"
          />
        </AvatarGroup>
      </div>
    </div>
  ),
};
```


### Component: `badge`

This section contains the source code for the `badge` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\badge\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import React from "react";

const badgeVariants = cva(
  // Base classes: Increased padding with px-3
  "inline-flex items-center border px-2 py-1 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-graphite-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        primary:
          "border-transparent bg-graphite-primary text-graphite-primaryForeground hover:bg-graphite-primary/80",
        secondary:
          "border-transparent bg-graphite-secondary text-graphite-secondaryForeground hover:bg-graphite-secondary/80",
        // Destructive variant is now a solid, bold red
        destructive:
          "border-transparent bg-red-500 text-graphite-primaryForeground hover:bg-red-600/80",
        outline: "text-graphite-foreground border-graphite-border",
      },
      shape: {
        // Added shape variants
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      variant: "primary",
      shape: "full", // Default to a pill shape
    },
  }
);

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: "primary" | "secondary" | "destructive" | "outline";
  shape?: "full" | "minimal" | "sharp";
}

export const Badge = React.forwardRef<HTMLDivElement, BadgeProps>(
  ({ className, variant, shape, ...props }, ref) => {
    return (
      <div
        className={badgeVariants({ variant, shape, className })}
        ref={ref}
        {...props}
      />
    );
  }
);

Badge.displayName = "Badge";
```

**Storybook Stories (`Badge.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Badge } from "./index";
import { Button } from "../button";

const meta: Meta<typeof Badge> = {
  title: "Components/Badge",
  component: Badge,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "destructive", "outline"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    children: {
      control: "text",
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    children: "Badge",
    shape: "full",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Badge variant="primary">Primary</Badge>
      <Badge variant="secondary">Secondary</Badge>
      <Badge variant="destructive">Destructive</Badge>
      <Badge variant="outline">Outline</Badge>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Badge variant="primary" shape="full">
        Full
      </Badge>
      <Badge variant="primary" shape="minimal">
        Minimal
      </Badge>
      <Badge variant="primary" shape="sharp">
        Sharp
      </Badge>
    </div>
  ),
};
```


### Component: `bottom-tabs`

This section contains the source code for the `bottom-tabs` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\bottom-tabs\index.tsx`)**
```tsx
"use client";

import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import { AnimatePresence, motion } from "framer-motion";
import React, {
  Children,
  createContext,
  useContext,
  useMemo,
  useRef,
} from "react";
import useRipple from "use-ripple-hook";
import { Typography } from "../typography";

// --- TYPE DEFINITIONS & CONTEXT ---

export interface ScreenProps {
  /** A unique name for the screen. */
  name: string;
  /** The text label to display. */
  label: React.ReactNode;
  /** A function that returns the icon element, receiving active state. */
  icon: (props: { isActive: boolean }) => React.ReactNode;
  /** Overrides the shape of this specific tab item, indicator, and ripple effect. */
  shape?: "full" | "minimal" | "sharp";
}

interface BottomTabsContextProps {
  activeTab: string;
  onTabPress: (name: string) => void;
  itemLayout: "stacked" | "inline";
  mode: "attached" | "detached";
  /** The shape inherited from the parent navigator, used as a fallback. */
  navigatorShape: "full" | "minimal" | "sharp";
  indicatorId: string;
}

const BottomTabsContext = createContext<BottomTabsContextProps | null>(null);
const useBottomTabs = () => {
  const context = useContext(BottomTabsContext);
  if (!context) {
    throw new Error(
      "BottomTabs components must be used within a <BottomTabs.Navigator>"
    );
  }
  return context;
};

// --- CVA VARIANTS (REFACTORED) ---

const navigatorVariants = cva("w-full bg-graphite-card", {
  variants: {
    mode: {
      attached: "",
      detached: "p-2",
    },
    shape: {
      full: "",
      minimal: "",
      sharp: "rounded-none",
    },
    bordered: {
      true: "border-t border-graphite-border",
      false: "",
    },
    shadow: {
      none: "shadow-none",
      sm: "shadow-sm",
      md: "shadow-md",
      lg: "shadow-lg",
    },
  },
  compoundVariants: [
    { mode: "detached", shape: "full", className: "rounded-full" },
    { mode: "detached", shape: "minimal", className: "rounded-xl" },
    { mode: "attached", shape: "full", className: "rounded-t-3xl" },
    { mode: "attached", shape: "minimal", className: "rounded-t-xl" },
  ],
});

// --- SCREEN COMPONENT (CONFIG ONLY) ---

const BottomTabsScreen: React.FC<ScreenProps> = () => {
  return null;
};
BottomTabsScreen.displayName = "BottomTabs.Screen";

// --- TAB ITEM (INTERNAL) ---

interface TabItemProps {
  screen: ScreenProps;
}

const TabItem: React.FC<TabItemProps> = ({ screen }) => {
  const { name, label, icon, shape: itemShape } = screen;
  const { activeTab, onTabPress, itemLayout, indicatorId, navigatorShape } =
    useBottomTabs();
  const isActive = activeTab === name;

  // If the item has its own shape, use it; otherwise, fall back to the navigator's shape.
  const finalShape = itemShape || navigatorShape;

  const localRef = useRef<HTMLButtonElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(0, 0, 0, 0.1)",
    duration: 400,
  });

  const isHorizontal = itemLayout === "inline" && isActive;

  const shapeToBorderRadius = {
    full: 9999,
    minimal: 12, // Corresponds to rounded-xl
    sharp: 0,
  };

  const shapeToClassName = {
    full: "rounded-full",
    minimal: "rounded-lg",
    sharp: "rounded-none",
  };

  return (
    <li className="flex-1">
      <button
        ref={localRef}
        type="button"
        role="tab"
        aria-selected={isActive}
        onClick={() => onTabPress(name)}
        onPointerDown={event}
        className={clsx(
          "relative z-10 flex h-16 w-full items-center justify-center transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2",
          isHorizontal ? "flex-row gap-2 px-4 py-2" : "flex-col gap-1 p-2",
          isActive
            ? "text-graphite-primary font-semibold"
            : "text-graphite-foreground/70",
          shapeToClassName[finalShape] // Apply dynamic shape class for ripple
        )}
      >
        {isActive && (
          <motion.div
            layoutId={indicatorId}
            className="absolute inset-0 z-0 bg-graphite-secondary"
            // Apply dynamic border radius for indicator
            style={{ borderRadius: shapeToBorderRadius[finalShape] }}
            transition={{ type: "spring", stiffness: 400, damping: 35 }}
          />
        )}
        <div className="relative z-10">{icon({ isActive })}</div>
        <AnimatePresence>
          {isHorizontal ? (
            <motion.div
              initial={{ width: 0, opacity: 0 }}
              animate={{
                width: "auto",
                opacity: 1,
                transition: { delay: 0.1, duration: 0.2 },
              }}
              exit={{ width: 0, opacity: 0, transition: { duration: 0.1 } }}
              className="relative z-10 overflow-hidden whitespace-nowrap"
            >
              <Typography variant="small" className="font-semibold">
                {label}
              </Typography>
            </motion.div>
          ) : (
            <div className="relative z-10">
              <Typography
                variant="small"
                className={isActive ? "font-semibold" : ""}
              >
                {label}
              </Typography>
            </div>
          )}
        </AnimatePresence>
      </button>
    </li>
  );
};

// --- NAVIGATOR COMPONENT (REFACTORED) ---

interface NavigatorProps extends React.HTMLAttributes<HTMLElement> {
  mode?: "attached" | "detached";
  shape?: "full" | "minimal" | "sharp";
  bordered?: boolean;
  shadow?: "none" | "sm" | "md" | "lg";
  children: React.ReactElement<ScreenProps> | React.ReactElement<ScreenProps>[];
  activeTab: string;
  onTabPress: (name: string) => void;
  itemLayout?: "stacked" | "inline";
}

const BottomTabsNavigator: React.FC<NavigatorProps> = ({
  children,
  activeTab,
  onTabPress,
  mode = "attached",
  itemLayout = "stacked",
  shape = "full",
  bordered = true,
  shadow = "lg",
  className,
  ...props
}) => {
  const indicatorId = React.useId();

  const screens = useMemo(
    () =>
      Children.toArray(children)
        .filter(
          (child): child is React.ReactElement<ScreenProps> =>
            React.isValidElement(child) && child.type === BottomTabsScreen
        )
        .map((child) => child.props),
    [children]
  );

  const contextValue = useMemo(
    () => ({
      activeTab,
      onTabPress,
      itemLayout,
      mode,
      navigatorShape: shape,
      indicatorId,
    }),
    [activeTab, onTabPress, itemLayout, mode, shape, indicatorId]
  );

  return (
    <BottomTabsContext.Provider value={contextValue}>
      <nav
        className={clsx(
          navigatorVariants({
            mode,
            shape,
            bordered: mode === "attached" ? bordered : false,
            shadow: mode === "detached" ? shadow : undefined,
            className,
          })
        )}
        {...props}
      >
        <ul className="flex items-center justify-around gap-2 p-1">
          {screens.map((screen) => (
            <TabItem key={screen.name} screen={screen} />
          ))}
        </ul>
      </nav>
    </BottomTabsContext.Provider>
  );
};
BottomTabsNavigator.displayName = "BottomTabs.Navigator";

// --- EXPORT COMPOUND COMPONENT ---

export const BottomTabs = {
  Navigator: BottomTabsNavigator,
  Screen: BottomTabsScreen,
};
```

**Storybook Stories (`bottom-tabs.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Compass, Home, Library, Radio } from "lucide-react";
import { ShallowRouter, useRouter } from "../shallow-router";
import { Typography } from "../typography";
import { BottomTabs } from "./index";
const meta: Meta<typeof BottomTabs.Navigator> = {
  title: "Components/Navigators/BottomTabs",
  component: BottomTabs.Navigator,
  subcomponents: { Screen: BottomTabs.Screen },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A responsive and animated bottom navigation component, inspired by native mobile tab bars. It integrates with any routing library by exposing `activeTab` and `onTabPress` props.",
      },
    },
  },
  argTypes: {
    mode: {
      control: "select",
      options: ["attached", "detached"],
      description: "Controls the container style: full-width or floating.",
    },
    itemLayout: {
      control: "select",
      options: ["stacked", "inline"],
      description: "Controls the layout animation of the active tab item.",
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description:
        "Sets the border-radius for the container and the active item indicator.",
    },
    shadow: {
      control: "select",
      options: ["none", "sm", "md", "lg"],
      description: "Sets the shadow depth for the `detached` mode.",
      if: { arg: "mode", eq: "detached" },
    },
    bordered: {
      control: "boolean",
      description: "Toggles the top border for the `attached` mode.",
      if: { arg: "mode", eq: "attached" },
    },
    activeTab: { control: false },
    onTabPress: { action: "tabPressed" },
  },
};

export default meta;
type Story = StoryObj<typeof BottomTabs.Navigator>;

// Helper component to render stories with routing context
const RenderWithRouter = (args: any) => {
  const { path: activeTab, push: onTabPress } = useRouter();

  const iconSize = 24;
  const initialTab = "home";

  return (
    <div className="w-96">
      <BottomTabs.Navigator
        {...args}
        activeTab={activeTab === "/" ? initialTab : activeTab.substring(1)}
        onTabPress={(tab) => onTabPress(`/${tab}`)}
      >
        <BottomTabs.Screen
          name="home"
          label="Home"
          icon={() => <Home size={iconSize} />}
        />
        <BottomTabs.Screen
          name="browse"
          label="Browse"
          icon={() => <Compass size={iconSize} />}
        />
        <BottomTabs.Screen
          name="radio"
          label="Radio"
          icon={() => <Radio size={iconSize} />}
        />
        <BottomTabs.Screen
          name="library"
          label="Library"
          icon={() => <Library size={iconSize} />}
        />
      </BottomTabs.Navigator>
    </div>
  );
};

export const AttachedDefault: Story = {
  name: "1. Attached (Default)",
  args: {
    mode: "attached",
    itemLayout: "stacked",
    bordered: true,
    shape: "full",
  },
  render: (args) => (
    <ShallowRouter paramName="tab">
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const AttachedWithInlineAnimation: Story = {
  name: "2. Attached (Inline Item Layout)",
  args: {
    mode: "attached",
    itemLayout: "inline",
    bordered: true,
    shape: "full",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `itemLayout` is `inline`, the active tab's label animates horizontally, creating a common native mobile pattern.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter paramName="tab">
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const AttachedWithShapes: Story = {
  name: "3. Attached (Shape Variants)",
  render: (args) => (
    <div className="flex flex-col gap-12">
      <div>
        <Typography variant="small" className="font-bold mb-2 text-center">
          Full Shape
        </Typography>
        <ShallowRouter paramName="tab1">
          <RenderWithRouter {...args} mode="attached" shape="full" />
        </ShallowRouter>
      </div>
      <div>
        <Typography variant="small" className="font-bold mb-2 text-center">
          Minimal Shape
        </Typography>
        <ShallowRouter paramName="tab2">
          <RenderWithRouter {...args} mode="attached" shape="minimal" />
        </ShallowRouter>
      </div>
      <div>
        <Typography variant="small" className="font-bold mb-2 text-center">
          Sharp Shape
        </Typography>
        <ShallowRouter paramName="tab3">
          <RenderWithRouter {...args} mode="attached" shape="sharp" />
        </ShallowRouter>
      </div>
    </div>
  ),
};

// Helper for the new story
const RenderWithRouterForMixedShapes = (args: any) => {
  const { path: activeTab, push: onTabPress } = useRouter();
  const iconSize = 24;
  const initialTab = "home";

  return (
    <div className="w-96">
      <BottomTabs.Navigator
        {...args}
        activeTab={activeTab === "/" ? initialTab : activeTab.substring(1)}
        onTabPress={(tab) => onTabPress(`/${tab}`)}
      >
        <BottomTabs.Screen
          name="home"
          label="Home"
          icon={() => <Home size={iconSize} />}
          shape="full" // Override: This item will be a circle
        />
        <BottomTabs.Screen
          name="browse"
          label="Browse"
          icon={() => <Compass size={iconSize} />}
          // No shape prop: This item will inherit "minimal" from the navigator
        />
        <BottomTabs.Screen
          name="radio"
          label="Radio"
          icon={() => <Radio size={iconSize} />}
          shape="sharp" // Override: This item will be a square
        />
        <BottomTabs.Screen
          name="library"
          label="Library"
          icon={() => <Library size={iconSize} />}
          shape="full" // Override: This item will be a circle
        />
      </BottomTabs.Navigator>
    </div>
  );
};

export const MixedItemShapes: Story = {
  name: "4. Mixed Item Shapes",
  args: {
    mode: "attached",
    shape: "minimal", // The bar itself is minimal
    bordered: true,
  },
  parameters: {
    docs: {
      description: {
        story:
          "You can override the shape for individual tab items by setting the `shape` prop on the `<BottomTabs.Screen>` component. If an item doesn't have a shape, it inherits from the parent `<BottomTabs.Navigator>`.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter paramName="tab4">
      <RenderWithRouterForMixedShapes {...args} />
    </ShallowRouter>
  ),
};

export const Detached: Story = {
  name: "5. Detached (Floating)",
  args: {
    mode: "detached",
    shape: "full",
    itemLayout: "stacked",
    shadow: "lg",
  },
  render: (args) => (
    <ShallowRouter paramName="tab">
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const DetachedWithShadows: Story = {
  name: "6. Detached (Shadow Variants)",
  render: (args) => (
    <div className="flex flex-col gap-12">
      <div>
        <Typography variant="small" className="font-bold mb-2 text-center">
          Small Shadow (sm)
        </Typography>
        <ShallowRouter paramName="tab1">
          <RenderWithRouter {...args} mode="detached" shadow="sm" />
        </ShallowRouter>
      </div>
      <div>
        <Typography variant="small" className="font-bold mb-2 text-center">
          Medium Shadow (md)
        </Typography>
        <ShallowRouter paramName="tab2">
          <RenderWithRouter {...args} mode="detached" shadow="md" />
        </ShallowRouter>
      </div>
      <div>
        <Typography variant="small" className="font-bold mb-2 text-center">
          Large Shadow (lg)
        </Typography>
        <ShallowRouter paramName="tab3">
          <RenderWithRouter {...args} mode="detached" shadow="lg" />
        </ShallowRouter>
      </div>
    </div>
  ),
};
```


### Component: `bouncy-box`

This section contains the source code for the `bouncy-box` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\bouncy-box\index.tsx`)**
```tsx
import { clsx } from "clsx";
import { motion, type HTMLMotionProps } from "framer-motion";
import React from "react";

// Define the component's props, extending Framer Motion's div props
export interface BouncyBoxProps extends HTMLMotionProps<"div"> {
  /** The amount to scale down on press. 1 is no scale, 0.9 is 90%. */
  scaleAmount?: number;
}

export const BouncyBox = React.forwardRef<HTMLDivElement, BouncyBoxProps>(
  ({ className, children, scaleAmount = 0.95, ...props }, ref) => {
    return (
      <motion.div
        ref={ref}
        className={clsx(
          "cursor-pointer inline-block", // Use inline-flex to wrap content tightly
          className
        )}
        // The magic prop: animates to this state while tapped/clicked
        whileTap={{ scale: scaleAmount }}
        // Configure the spring physics for a nice "bouncy" feel
        transition={{ type: "spring", stiffness: 400, damping: 30, mass: 3 }}
        {...props}
      >
        {children}
      </motion.div>
    );
  }
);

BouncyBox.displayName = "BouncyBox";
```

**Storybook Stories (`bouncy-box.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Button } from "../button"; // Import Button
import { Card } from "../card"; // Import Card
import { Typography } from "../typography"; // Import Typography
import { BouncyBox } from "./index";

const meta: Meta<typeof BouncyBox> = {
  title: "Components/BouncyBox",
  component: BouncyBox,
  tags: ["autodocs"],
  argTypes: {
    scaleAmount: {
      control: { type: "range", min: 0.7, max: 1, step: 0.01 },
    },
  },
  parameters: {
    layout: "centered", // Center the component for better viewing
    docs: {
      description: {
        component:
          "A wrapper component that adds a bouncy, pressable animation to any child element on click. Built with Framer Motion.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    scaleAmount: 0.95,
  },
  render: (args) => (
    <BouncyBox {...args}>
      <Card shape="minimal" className="w-64 cursor-pointer">
        <Typography variant="h4">Click Me!</Typography>
        <Typography variant="p">
          This entire card will bounce when you press down on it.
        </Typography>
      </Card>
    </BouncyBox>
  ),
};

export const WrappingAButton: Story = {
  name: "Wrapping an Interactive Element",
  render: () => (
    <BouncyBox
      onClick={() => alert("Wrapper Clicked!")}
      className="rounded-full"
    >
      <Button
        size="lg"
        onClick={(e) => {
          // Prevent the wrapper's onClick from firing if needed
          e.stopPropagation();
          alert("Button Clicked!");
        }}
      >
        Click the Button
      </Button>
    </BouncyBox>
  ),
};

export const MoreBouncy: Story = {
  name: "More Bouncy",
  args: {
    scaleAmount: 0.85,
  },
  render: (args) => (
    <BouncyBox {...args}>
      <Card shape="full" className="w-48 h-48 flex items-center justify-center">
        <Typography variant="h3">Boing!</Typography>
      </Card>
    </BouncyBox>
  ),
};
```


### Component: `button`

This section contains the source code for the `button` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\button\index.tsx`)**
```tsx
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import clsx from "clsx";
import { AnimatePresence, motion } from "framer-motion";
import { Loader2 } from "lucide-react";
import React from "react";
import useRipple from "use-ripple-hook";
export const buttonVariants = cva(
  "font-semibold cursor-pointer  min-w-max focus:outline-none transition-all duration-300 ease-in-out flex items-center justify-center relative overflow-hidden",
  {
    variants: {
      variant: {
        primary:
          "bg-graphite-primary hover:shadow-md disabled:bg-graphite-primary/70  text-graphite-primaryForeground hover:opacity-90 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring ",
        secondary:
          "bg-graphite-secondary text-graphite-secondaryForeground disabled:bg-graphite-secondary/70 hover:bg-graphite-secondary/80  focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        destructive:
          "bg-red-500 text-graphite-primaryForeground disabled:bg-red-500/70 hover:bg-red-600/80 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        ghost:
          "bg-transparent text-graphite-foreground disabled:opacity-70 hover:bg-graphite-secondary focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        link: "bg-transparent text-graphite-primary disabled:opacity-70 hover:text-graphite-primary hover:underline !p-1 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
      },
      size: {
        xs: "h-8 px-2 text-xs",
        sm: "h-10 px-4 text-sm",
        md: "h-12 px-6 text-base",
        lg: "h-14 px-8 text-lg",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
      isLoading: {
        true: "cursor-wait",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      shape: "full",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary" | "destructive" | "ghost" | "link";
  size?: "xs" | "sm" | "md" | "lg";
  shape?: "full" | "minimal" | "sharp";
  isLoading?: boolean;
  startIcon?: React.ReactNode;
  endIcon?: React.ReactNode;
  /** If true, the button will render as a `Slot.Root` and merge its props onto the immediate child. */
  asChild?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant = "primary",
      size,
      shape,
      children,
      disabled,
      startIcon,
      endIcon,
      isLoading,
      asChild = false,
      ...props
    },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);
    const rippleColor =
      variant === "primary" || variant === "destructive"
        ? "rgba(255, 255, 255, 0.4)"
        : "rgba(0, 0, 0, 0.1)";

    const rippleRef = localRef as React.RefObject<HTMLElement>;
    const [, event] = useRipple({
      ref: rippleRef,
      color: rippleColor,
      duration: 400,
      disabled: disabled || isLoading,
    });

    const loaderSizeMap = {
      xs: "h-4 w-4",
      sm: "h-4 w-4",
      md: "h-5 w-5",
      lg: "h-6 w-6",
    };

    if (asChild) {
      return (
        <Slot
          className={clsx(
            buttonVariants({
              variant,
              size,
              shape,
              className,
              isLoading,
            }),
            disabled || isLoading ? "opacity-70 pointer-events-none" : ""
          )}
          ref={localRef}
          onPointerDown={(e: React.PointerEvent<HTMLButtonElement>) => {
            e.stopPropagation();
            event(e);
          }}
          {...props}
        >
          {children}
        </Slot>
      );
    }

    return (
      <button
        className={buttonVariants({
          variant,
          size,
          shape,
          className,
          isLoading,
        })}
        ref={localRef}
        onPointerDown={(e: React.PointerEvent<HTMLButtonElement>) => {
          e.stopPropagation();
          event(e);
        }}
        disabled={disabled || isLoading}
        {...props}
      >
        <AnimatePresence mode="wait" initial={false}>
          {isLoading ? (
            <motion.div
              key="spinner"
              initial={{ opacity: 0, scale: 0.5 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.5 }}
              transition={{ duration: 0.2 }}
            >
              <Loader2
                className={`animate-spin ease-[cubic-bezier(0.95,0.05,0.795,0.035)] ${
                  loaderSizeMap[size || "md"]
                }`}
              />
            </motion.div>
          ) : (
            <motion.span
              key="content"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
              className="relative z-10 flex items-center justify-center"
            >
              {startIcon && (
                <span className="mr-2 flex items-center">{startIcon}</span>
              )}
              {children}
              {endIcon && (
                <span className="ml-2 flex items-center">{endIcon}</span>
              )}
            </motion.span>
          )}
        </AnimatePresence>
      </button>
    );
  }
);

Button.displayName = "Button";
```

**Storybook Stories (`Button.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { ChevronRight, Plus } from "lucide-react";
import { useState } from "react";
import { Button } from "./index";

const meta: Meta<typeof Button> = {
  title: "Components/Buttons/Button",
  component: Button,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "destructive", "ghost", "link"],
    },
    size: {
      control: "select",
      options: ["xs", "sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "The border radius of the button.",
    },
    isLoading: { control: "boolean" },
    disabled: { control: "boolean" },
    asChild: { control: "boolean" },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    variant: "primary",
    size: "md",
    shape: "full",
    children: "Primary Button",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary">Primary</Button>
      <Button variant="secondary">Secondary</Button>
      <Button variant="destructive">Destructive</Button>
      <Button variant="ghost">Ghost</Button>
      <Button variant="link">Link</Button>
    </div>
  ),
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary" size="lg">
        Large
      </Button>
      <Button variant="primary" size="md">
        Medium
      </Button>
      <Button variant="primary" size="sm">
        Small
      </Button>
      <Button variant="primary" size="xs">
        Extra Small
      </Button>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary" shape="full">
        Full
      </Button>
      <Button variant="primary" shape="minimal">
        Minimal
      </Button>
      <Button variant="primary" shape="sharp">
        Sharp
      </Button>
    </div>
  ),
};

export const WithIcons: Story = {
  name: "With Start/End Icons",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button
        variant="primary"
        size="md"
        startIcon={<Plus className="h-5 w-5" />}
      >
        Add Item
      </Button>
      <Button
        variant="secondary"
        size="md"
        shape="minimal"
        endIcon={<ChevronRight className="h-5 w-5" />}
      >
        Continue
      </Button>
    </div>
  ),
};

export const Loading: Story = {
  name: "Loading State",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary" isLoading>
        Saving...
      </Button>
      <Button variant="secondary" isLoading>
        Loading...
      </Button>
      <Button variant="ghost" isLoading>
        Processing...
      </Button>
    </div>
  ),
};

export const InteractiveLoading: Story = {
  name: "Interactive Loading",
  render: () => {
    const [isLoading, setIsLoading] = useState(false);
    const handleClick = () => {
      setIsLoading(true);
      setTimeout(() => {
        setIsLoading(false);
      }, 2000);
    };
    return (
      <Button variant="primary" isLoading={isLoading} onClick={handleClick}>
        {isLoading ? "Submitting..." : "Click to Submit"}
      </Button>
    );
  },
};

export const AsChild: Story = {
  name: "As Child (Polymorphic)",
  parameters: {
    docs: {
      description: {
        story:
          "Use the `asChild` prop to render the button as a different element, like an anchor tag, while preserving all styles and functionality.",
      },
    },
  },
  render: () => (
    <Button asChild variant={"primary"} size="lg">
      <a href="#">This is an anchor tag</a>
    </Button>
  ),
};
```


### Component: `button-group`

This section contains the source code for the `button-group` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\button-group\index.tsx`)**
```tsx
import { clsx } from "clsx";
import React from "react";

// Explicitly define the shape type for clarity and type safety
type ButtonShape = "full" | "minimal" | "sharp";

// Define the component's props
// FIX 1: The wrapping element is now a <fieldset>, so the attributes should match.
interface ButtonGroupProps extends React.HTMLAttributes<HTMLFieldSetElement> {
  children: React.ReactNode;
  shape?: ButtonShape;
}

export const ButtonGroup = ({
  children,
  className,
  shape = "full",
  ...props
}: ButtonGroupProps) => {
  // Map the shape prop to the correct Tailwind CSS classes for the outer corners
  const shapeClasses: Record<ButtonShape, { left: string; right: string }> = {
    full: { left: "rounded-l-full", right: "rounded-r-full" },
    minimal: { left: "rounded-l-lg", right: "rounded-r-lg" },
    sharp: { left: "rounded-l-none", right: "rounded-r-none" },
  };

  const childArray = React.Children.toArray(children);

  return (
    // FIX 1: Use a more semantic <fieldset> element as suggested by the linter.
    // The role="group" attribute is now implicit.
    // Added border-none and p-0 to reset default fieldset browser styles.
    <fieldset
      className={clsx("inline-flex items-center border-none p-0", className)}
      {...props}
    >
      {childArray.map((child, index) => {
        // FIX 2 & 3: Use a generic type guard to inform TypeScript about the child's props.
        // This ensures child.props is recognized as an object with a potential `className`.
        if (!React.isValidElement<React.HTMLAttributes<HTMLElement>>(child)) {
          return child;
        }

        const isFirst = index === 0;
        const isLast = index === childArray.length - 1;

        // --- NEW, ROBUST LOGIC INSPIRED BY SPLITBUTTON ---
        // Determine the precise rounding classes based on the child's position.
        let positionClasses = "";
        if (isFirst) {
          // The first child gets the group's left rounding and a sharp right corner.
          positionClasses = clsx(shapeClasses[shape].left, "rounded-r-none");
        } else if (isLast) {
          // The last child gets the group's right rounding and a sharp left corner.
          positionClasses = clsx(shapeClasses[shape].right, "rounded-l-none");
        } else {
          // All middle children are forced to be sharp on both sides.
          positionClasses = "rounded-none";
        }

        const newClassName = clsx(
          child.props.className, // This is now type-safe
          positionClasses,
          // Create the overlapping border effect for a seamless look.
          !isFirst && "-ml-px",
          // Ensure the focused button renders on top of its siblings.
          "focus:z-10"
        );

        return React.cloneElement(child, {
          ...child.props, // This spread is also now type-safe
          className: newClassName,
        });
      })}
    </fieldset>
  );
};

ButtonGroup.displayName = "ButtonGroup";
```

**Storybook Stories (`Button-group.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Bold, Italic, Underline } from "lucide-react";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { ButtonGroup } from "./index";

const meta: Meta<typeof ButtonGroup> = {
  title: "Components/Buttons/ButtonGroup",
  component: ButtonGroup,
  tags: ["autodocs"],
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "Determines the border-radius of the group's outer corners.",
    },
  },
  parameters: {
    docs: {
      description: {
        component:
          "A container for grouping related buttons. It automatically styles its children to create a seamless, 'glued-together' look.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    shape: "full",
  },
  render: (args) => (
    <ButtonGroup {...args}>
      <Button variant="secondary">Left</Button>
      <Button variant="secondary">Middle</Button>
      <Button variant="secondary">Right</Button>
    </ButtonGroup>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-col items-start gap-4">
      <ButtonGroup shape="full">
        <Button variant="secondary">Full</Button>
        <Button variant="secondary">Full</Button>
        <Button variant="secondary">Full</Button>
      </ButtonGroup>
      <ButtonGroup shape="minimal">
        <Button variant="secondary">Minimal</Button>
        <Button variant="secondary">Minimal</Button>
        <Button variant="secondary">Minimal</Button>
      </ButtonGroup>
      <ButtonGroup shape="sharp">
        <Button variant="secondary">Sharp</Button>
        <Button variant="secondary">Sharp</Button>
        <Button variant="secondary">Sharp</Button>
      </ButtonGroup>
    </div>
  ),
};

export const WithIconButtons: Story = {
  name: "With Icon Buttons (Toolbar Example)",
  render: () => (
    <div className="flex flex-col items-start gap-4">
      <p className="text-sm text-gray-500">
        A common use case, like a text editor toolbar.
      </p>
      <ButtonGroup shape="minimal">
        <IconButton variant="primary" size="sm" aria-label="Bold">
          <Bold className="h-4 w-4" />
        </IconButton>
        <IconButton variant="secondary" size="sm" aria-label="Italic">
          <Italic className="h-4 w-4" />
        </IconButton>
        <IconButton variant="secondary" size="sm" aria-label="Underline">
          <Underline className="h-4 w-4" />
        </IconButton>
      </ButtonGroup>
    </div>
  ),
};
```


### Component: `calendar`

This section contains the source code for the `calendar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\calendar\index.tsx`)**
```tsx
"use client";

import { clsx } from "clsx";
import * as React from "react";
import { DayPicker } from "react-day-picker";
import { buttonVariants } from "../button"; // Your existing button variants
import { iconButtonVariants } from "../icon-button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={clsx("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: clsx(
          buttonVariants({ variant: "ghost", shape: "full" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex justify-center",
        head_cell:
          "text-gray-500 rounded-md w-9 font-normal text-[0.8rem] text-center",
        row: "flex w-full mt-2 justify-center",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-full [&:has([aria-selected].day-outside)]:bg-graphite-secondary/50 [&:has([aria-selected])]:bg-graphite-secondary first:[&:has([aria-selected])]:rounded-l-full last:[&:has([aria-selected])]:rounded-r-full focus-within:relative focus-within:z-20",
        day: clsx(
          iconButtonVariants({ variant: "ghost", shape: "full" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-graphite-primary text-graphite-primaryForeground hover:bg-graphite-primary hover:text-graphite-primaryForeground focus:bg-graphite-primary focus:text-graphite-primaryForeground",
        day_today: "bg-graphite-secondary text-graphite-secondaryForeground",
        day_outside:
          "day-outside text-gray-500 opacity-50 aria-selected:bg-graphite-secondary/50 aria-selected:text-gray-500 aria-selected:opacity-30",
        day_disabled: "text-gray-500 opacity-50",
        day_range_middle:
          "aria-selected:bg-graphite-secondary aria-selected:text-graphite-secondaryForeground",
        day_hidden: "invisible",
        ...classNames,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };
```

**Storybook Stories (`calendar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { addDays } from "date-fns";
import { useState } from "react";
import type { DateRange } from "react-day-picker";
import { PaginatedCalendar } from "../date-picker/paginated-calendar"; // Adjust the import path as needed
import { Card } from "../card/index";
const meta: Meta<typeof PaginatedCalendar> = {
  title: "Components/Date & Time/PaginatedCalendar",
  component: PaginatedCalendar,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A custom, paginated calendar component with day, month, and year views. It supports both single and range date selection and features swipe and click navigation.",
      },
    },
  },
  argTypes: {
    mode: {
      control: "select",
      options: ["single", "range"],
      description:
        "Determines if a single date or a date range can be selected.",
    },
    value: {
      control: false,
      description: "The currently selected date or date range.",
    },
    onSelect: {
      control: false,
      description: "Callback function triggered when a date is selected.",
    },
  },
};

export default meta;
type Story = StoryObj<typeof PaginatedCalendar>;

// --- STORIES ---

export const SingleDate: Story = {
  name: "1. Single Date Selection",
  args: {
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | DateRange | undefined>(new Date());

    return (
      <Card className="min-w-[320px]">
        <PaginatedCalendar
          {...args}
          value={date}
          onSelect={(newVal) => setDate(newVal)}
        />
      </Card>
    );
  },
};

export const DateRange: Story = {
  name: "2. Date Range Selection",
  args: {
    mode: "range",
  },
  parameters: {
    docs: {
      description: {
        story:
          "In range mode, the first click sets the start date, and the second click sets the end date. Clicking a new date after a range is complete will start a new selection.",
      },
    },
  },
  render: function Render(args) {
    const [range, setRange] = useState<Date | DateRange | undefined>({
      from: new Date(),
      to: addDays(new Date(), 7),
    });

    return (
      <Card className="min-w-[320px]">
        <PaginatedCalendar
          {...args}
          value={range}
          onSelect={(newVal) => setRange(newVal)}
        />
      </Card>
    );
  },
};

export const NoInitialValue: Story = {
  name: "3. No Initial Value",
  args: {
    mode: "single",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The calendar can also be initialized without a pre-selected date.",
      },
    },
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | DateRange | undefined>();

    return (
      <Card className="min-w-[320px]">
        <PaginatedCalendar
          {...args}
          value={date}
          onSelect={(newVal) => setDate(newVal)}
        />
      </Card>
    );
  },
};
```


### Component: `card`

This section contains the source code for the `card` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\card\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import clsx from "clsx";
import React from "react";

const cardVariants = cva(
  // Base classes
  "shadow-xs transition-colors duration-200",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
        /** A semi-transparent, blurred background effect. Best used on a colorful or textured background. */
        glass:
          "bg-white/5 backdrop-blur-lg border border-white/10 text-graphite-primaryForeground",
      },
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
      padding: {
        none: "p-0",
        sm: "p-2",
        md: "p-5",
        lg: "p-8",
      },
      isSelected: {
        true: "border-2 border-graphite-primary",
        false: " border-2 border-transparent", // No border by default
      },
    },
    // Special case for the glass variant to use its own border style
    compoundVariants: [
      {
        variant: "glass",
        isSelected: false,
        className: "border border-white/10",
      },
    ],
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
      padding: "md",
      isSelected: false,
    },
  }
);

export interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: "primary" | "secondary" | "glass";
  shape?: "full" | "minimal" | "sharp";
  padding?: "none" | "sm" | "md" | "lg";
  isSelected?: boolean;
}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, shape, variant, padding, isSelected, ...props }, ref) => {
    return (
      <div
        className={clsx(
          cardVariants({ shape, variant, padding, isSelected }),
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);

Card.displayName = "Card";
```

**Storybook Stories (`Card.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Button } from "../button";
import { Typography } from "../typography";
import { Card } from "./index";

const meta: Meta<typeof Card> = {
  title: "Components/Card",
  component: Card,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "glass"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    isSelected: {
      control: "boolean",
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
  },
  render: (args) => (
    <Card {...args} className="max-w-md">
      <Typography variant="h3">This is a Card</Typography>
      <Typography variant="p">
        A card is a flexible container for content. You can place any other
        components inside it.
      </Typography>
    </Card>
  ),
};

export const AllVariants: Story = {
  name: "All Variants & States",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card variant="primary" shape="minimal">
        <Typography variant="h4">Primary</Typography>
        <Typography variant="p">The default card style.</Typography>
      </Card>
      <Card variant="secondary" shape="minimal">
        <Typography variant="h4">Secondary</Typography>
        <Typography variant="p">For less emphasis.</Typography>
      </Card>
      <Card variant="primary" shape="minimal" isSelected={true}>
        <Typography variant="h4">Primary (Selected)</Typography>
        <Typography variant="p">To indicate selection.</Typography>
      </Card>
    </div>
  ),
};

export const GlassVariant: Story = {
  name: "Glass Variant",
  args: {
    variant: "glass",
    shape: "minimal",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `glass` variant creates a 'glassmorphism' effect with a blurred, semi-transparent background. It's designed to be placed on top of colorful or textured backgrounds.",
      },
    },
  },
  render: (args) => (
    <div
      className="w-full max-w-2xl h-96 flex items-center justify-center rounded-2xl overflow-hidden bg-cover bg-center"
      style={{
        backgroundImage:
          "url(https://images.unsplash.com/photo-1579546929518-9e396f3cc809?q=80&w=1470&auto=format&fit=crop)",
      }}
    >
      <Card {...args} className="max-w-md">
        <Typography variant="h3">Glass Card</Typography>
        <Typography variant="p" className="!text-white/80">
          This card uses a backdrop-blur effect to create a frosted glass look,
          letting the background color and texture show through.
        </Typography>
      </Card>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card shape="full">
        <Typography variant="h4">Full</Typography>
        <Typography variant="p">The default, highly-rounded style.</Typography>
      </Card>
      <Card shape="minimal">
        <Typography variant="h4">Minimal</Typography>
        <Typography variant="p">A more subtle, modern rounding.</Typography>
      </Card>
      <Card shape="sharp">
        <Typography variant="h4">Sharp</Typography>
        <Typography variant="p">No rounding for a blocky look.</Typography>
      </Card>
    </div>
  ),
};

export const Composition: Story = {
  name: "Composition Example",
  render: () => (
    <Card shape="minimal" className="max-w-sm flex flex-col gap-4">
      <div>
        <Typography variant="h3">Upgrade to Pro</Typography>
        <Typography variant="muted">
          Unlock all features and get unlimited access.
        </Typography>
      </div>
      <Typography variant="p">
        Gain access to advanced analytics, priority support, and exclusive
        content by upgrading your plan today.
      </Typography>
      <div className="flex justify-end">
        <Button>Learn More</Button>
      </div>
    </Card>
  ),
};
```


### Component: `checkbox`

This section contains the source code for the `checkbox` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\checkbox\index.tsx`)**
```tsx
import { clsx } from "clsx";
import React from "react";

// Using the exact CheckIcon component you provided.
const CheckIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    {...props}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M4.5 12.75l6 6 9-13.5"
    />
  </svg>
);

export interface CheckboxProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
}

export const Checkbox = React.forwardRef<HTMLInputElement, CheckboxProps>(
  ({ className, id, label, ...props }, ref) => {
    const uniqueId = React.useId();
    const checkboxId = id || uniqueId;

    return (
      <div className="inline-flex items-center">
        {/* Container is now h-6 w-6 to match the design */}
        <div className="relative flex items-center justify-center h-6 w-6">
          <input
            type="checkbox"
            ref={ref}
            id={checkboxId}
            className={clsx(
              "peer h-6 w-6 shrink-0 appearance-none transition-colors duration-200",
              // Changed to rounded-lg for the softer, squircle shape
              "rounded-lg",
              // Unchecked state with a border-2 to match the visual weight
              "border-2 border-graphite-border",
              // Checked state
              "checked:border-graphite-primary checked:bg-graphite-primary",
              // Focus state
              "focus:outline-none focus:ring-2 focus:ring-graphite-ring focus:ring-offset-2",
              // Disabled state
              "disabled:cursor-not-allowed disabled:opacity-50 disabled:checked:bg-graphite-border disabled:checked:border-graphite-border",
              className
            )}
            {...props}
          />
          <CheckIcon
            className={clsx(
              "pointer-events-none absolute h-4 w-4 text-graphite-primaryForeground",
              // Increased stroke weight for better visibility and to match the design
              "stroke-[3.5]",
              // Animation scales the icon in when the peer input is checked
              "transition-transform duration-200 ease-in-out transform scale-0 peer-checked:scale-100"
            )}
          />
        </div>
        {label && (
          <label
            htmlFor={checkboxId}
            className="ml-3 text-sm font-medium text-graphite-foreground select-none"
          >
            {label}
          </label>
        )}
      </div>
    );
  }
);

Checkbox.displayName = "Checkbox";
```

**Storybook Stories (`Checkbox.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { Checkbox } from "./index";

const meta: Meta<typeof Checkbox> = {
  title: "Components/Forms & Inputs/Checkbox",
  component: Checkbox,
  tags: ["autodocs"],
  argTypes: {
    label: { control: "text" },
    checked: { control: "boolean" },
    disabled: { control: "boolean" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    label: "Accept terms and conditions",
  },
};

export const Checked: Story = {
  args: {
    label: "Save my preferences",
    defaultChecked: true, // Use defaultChecked for uncontrolled initial state
  },
};

export const Disabled: Story = {
  name: "Disabled States",
  render: () => (
    <div className="flex flex-col gap-4">
      <Checkbox disabled label="Unchecked and Disabled" />
      <Checkbox disabled defaultChecked label="Checked and Disabled" />
    </div>
  ),
};

export const Interactive: Story = {
  name: "Interactive (Controlled)",
  render: () => {
    const [isChecked, setIsChecked] = useState(false);
    return (
      <div className="flex flex-col gap-2">
        <Checkbox
          checked={isChecked}
          onChange={(e) => setIsChecked(e.target.checked)}
          label="Click me to see the state change"
        />
        <p className="text-sm text-gray-500">
          Current state: {isChecked ? "Checked" : "Unchecked"}
        </p>
      </div>
    );
  },
};

export const WithoutLabel: Story = {
  name: "Without a Label",
  args: {
    "aria-label": "A checkbox without a visible label", // Important for accessibility
  },
};
```


### Component: `chip`

This section contains the source code for the `chip` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\chip\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import React from "react";
import useRipple from "use-ripple-hook";

const chipVariants = cva(
  // Base classes for a fixed height, padding, and pill shape
  "inline-flex items-center justify-center h-10 px-4 rounded-full font-semibold text-sm border-2 transition-colors relative overflow-hidden disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      // The main variant is its selection state
      selected: {
        true: "bg-graphite-primary text-graphite-primaryForeground border border-graphite-primary",
        false:
          "bg-transparent text-graphite-foreground border border-graphite-border hover:bg-graphite-secondary",
      },
    },
    defaultVariants: {
      selected: false,
    },
  }
);

export interface ChipProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  selected?: boolean;
  startIcon?: React.ReactNode;
  endIcon?: React.ReactNode;
}

export const Chip = React.forwardRef<HTMLButtonElement, ChipProps>(
  (
    { className, selected, children, disabled, startIcon, endIcon, ...props },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);

    // Ripple color changes based on the selection state
    const rippleColor = selected
      ? "rgba(255, 255, 255, 0.3)"
      : "rgba(0, 0, 0, 0.1)";

    const rippleRef = localRef as React.RefObject<HTMLElement>;
    const [, event] = useRipple({
      ref: rippleRef,
      color: rippleColor,
      duration: 400,
      disabled: disabled,
    });

    return (
      <button
        className={chipVariants({ selected, className })}
        ref={localRef}
        onPointerDown={event}
        disabled={disabled}
        {...props}
      >
        <span className="relative z-10 flex items-center justify-center">
          {startIcon && (
            <span className="mr-2 flex items-center">{startIcon}</span>
          )}
          {children}
          {endIcon && <span className="ml-2 flex items-center">{endIcon}</span>}
        </span>
      </button>
    );
  }
);

Chip.displayName = "Chip";
```

**Storybook Stories (`chip.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Check, X } from "lucide-react";
import { useState } from "react";
import { Chip } from "./index";

const meta: Meta<typeof Chip> = {
  title: "Components/Chip",
  component: Chip,
  tags: ["autodocs"],
  argTypes: {
    selected: {
      control: "boolean",
    },
    disabled: {
      control: "boolean",
    },
    children: {
      control: "text",
    },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    children: "Default Chip",
  },
};

export const Selected: Story = {
  args: {
    children: "Selected Chip",
    selected: true,
  },
};

export const Interactive: Story = {
  name: "Interactive (Toggle)",
  render: (args) => {
    const [isSelected, setIsSelected] = useState(false);
    return (
      <Chip
        {...args}
        selected={isSelected}
        onClick={() => setIsSelected(!isSelected)}
        startIcon={isSelected && <Check className="h-4 w-4" />}
      >
        {isSelected ? "Filter Enabled" : "Enable Filter"}
      </Chip>
    );
  },
};

export const WithIcons: Story = {
  name: "With Start and End Icons",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Chip>
        <span className="font-normal mr-2">Tag:</span>
        React
      </Chip>
      <Chip endIcon={<X className="h-4 w-4" />}>Dismissible</Chip>
    </div>
  ),
};

export const Disabled: Story = {
  name: "Disabled States",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Chip disabled>Disabled</Chip>
      <Chip selected disabled>
        Selected & Disabled
      </Chip>
    </div>
  ),
};
```


### Component: `context-menu`

This section contains the source code for the `context-menu` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\context-menu\index.tsx`)**
```tsx
"use client";

import * as RadixContextMenu from "@radix-ui/react-context-menu";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { Check, ChevronRight, Circle } from "lucide-react";
import React, { createContext, useContext, useRef } from "react";
import useRipple from "use-ripple-hook";

// --- TYPES & CONTEXT ---
type ContextMenuShape = "full" | "minimal" | "sharp";
type ContextMenuSize = "sm" | "md" | "lg";

interface ContextMenuContextProps {
  shape: ContextMenuShape;
  size: ContextMenuSize;
}

const ContextMenuContext = createContext<ContextMenuContextProps>({
  shape: "minimal",
  size: "md",
});

const useContextMenuContext = () => useContext(ContextMenuContext);

// --- CVA VARIANTS ---
const contentVariants = cva(
  [
    "z-50 min-w-[12rem] max-h-[var(--radix-context-menu-content-available-height)] overflow-y-auto overflow-x-hidden",
    "border border-graphite-border bg-graphite-card p-1.5",
    "shadow-md",
  ],
  {
    variants: {
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      shape: "minimal",
    },
  }
);

const itemVariants = cva(
  [
    "relative flex cursor-pointer select-none items-center gap-2 rounded-lg outline-none overflow-hidden",
    "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
    "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
    "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
    "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
    "[&_svg]:pointer-events-none [&_svg]:shrink-0",
  ],
  {
    variants: {
      size: {
        sm: "px-2 py-1.5 text-xs",
        md: "px-3 py-2.5 text-sm",
        lg: "px-4 py-3 text-base",
      },
      shape: {
        full: "",
        minimal: "",
        sharp: "!rounded-none",
      },
    },
    defaultVariants: {
      size: "md",
    },
  }
);

// --- ROOT COMPONENT ---
interface ContextMenuProps extends RadixContextMenu.ContextMenuProps {
  shape?: ContextMenuShape;
  size?: ContextMenuSize;
}

const ContextMenuRoot: React.FC<ContextMenuProps> = ({
  shape = "minimal",
  size = "md",
  ...props
}) => {
  return (
    <ContextMenuContext.Provider value={{ shape, size }}>
      <RadixContextMenu.Root {...props} />
    </ContextMenuContext.Provider>
  );
};

// --- RE-EXPORTED PRIMITIVES ---
const ContextMenuTrigger = RadixContextMenu.Trigger;
const ContextMenuGroup = RadixContextMenu.Group;
const ContextMenuPortal = RadixContextMenu.Portal;
const ContextMenuSub = RadixContextMenu.Sub;
const ContextMenuRadioGroup = RadixContextMenu.RadioGroup;

// --- ANIMATED CONTENT ---
const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.Content>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.Content>
>(({ className, ...props }, ref) => {
  const { shape } = useContextMenuContext();
  return (
    <RadixContextMenu.Portal>
      <RadixContextMenu.Content
        ref={ref}
        className={clsx(
          contentVariants({ shape }),
          "data-[state=open]:animate-menu-enter",
          "data-[state=closed]:animate-menu-exit",
          "data-[side=top]:origin-bottom",
          "data-[side=bottom]:origin-top",
          "data-[side=left]:origin-right",
          "data-[side=right]:origin-left",
          className
        )}
        {...props}
      />
    </RadixContextMenu.Portal>
  );
});
ContextMenuContent.displayName = RadixContextMenu.Content.displayName;

// --- ENHANCED ITEM COMPONENTS ---
const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.Item>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => {
  const { shape, size } = useContextMenuContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixContextMenu.Item
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        itemVariants({ size, shape }),
        inset && "pl-8",
        className
      )}
      {...props}
    />
  );
});
ContextMenuItem.displayName = RadixContextMenu.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.CheckboxItem>
>(({ className, children, ...props }, ref) => {
  const { shape, size } = useContextMenuContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixContextMenu.CheckboxItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(itemVariants({ size, shape }), "pl-8", className)}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixContextMenu.ItemIndicator>
          <Check className="h-4 w-4 animate-check-in" />
        </RadixContextMenu.ItemIndicator>
      </span>
      {children}
    </RadixContextMenu.CheckboxItem>
  );
});
ContextMenuCheckboxItem.displayName = RadixContextMenu.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.RadioItem>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.RadioItem>
>(({ className, children, ...props }, ref) => {
  const { shape, size } = useContextMenuContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixContextMenu.RadioItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(itemVariants({ size, shape }), "pl-8", className)}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixContextMenu.ItemIndicator>
          <Circle className="h-2 w-2 fill-current animate-check-in" />
        </RadixContextMenu.ItemIndicator>
      </span>
      {children}
    </RadixContextMenu.RadioItem>
  );
});
ContextMenuRadioItem.displayName = RadixContextMenu.RadioItem.displayName;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, children, inset, ...props }, ref) => {
  const { shape, size } = useContextMenuContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixContextMenu.SubTrigger
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        itemVariants({ size, shape }),
        inset && "pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRight className="ml-auto h-4 w-4" />
    </RadixContextMenu.SubTrigger>
  );
});
ContextMenuSubTrigger.displayName = RadixContextMenu.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.SubContent>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.SubContent>
>(({ className, ...props }, ref) => {
  const { shape } = useContextMenuContext();
  return (
    <RadixContextMenu.SubContent
      ref={ref}
      className={clsx(
        contentVariants({ shape }),
        "data-[state=open]:data-[side=right]:animate-submenu-enter-right",
        "data-[state=closed]:data-[side=right]:animate-submenu-exit-right",
        "data-[state=open]:data-[side=left]:animate-submenu-enter-left",
        "data-[state=closed]:data-[side=left]:animate-submenu-exit-left",
        className
      )}
      {...props}
    />
  );
});
ContextMenuSubContent.displayName = RadixContextMenu.SubContent.displayName;

// --- OTHER COMPONENTS ---
const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.Label>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <RadixContextMenu.Label
    ref={ref}
    className={clsx(
      "px-3 py-2 text-xs font-medium text-graphite-foreground/70 tracking-wide",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
ContextMenuLabel.displayName = RadixContextMenu.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof RadixContextMenu.Separator>,
  React.ComponentPropsWithoutRef<typeof RadixContextMenu.Separator>
>(({ className, ...props }, ref) => (
  <RadixContextMenu.Separator
    ref={ref}
    className={clsx("-mx-1 my-1.5 h-px bg-graphite-border/60", className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = RadixContextMenu.Separator.displayName;

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={clsx(
        "ml-auto text-xs font-mono tracking-wider text-graphite-foreground/50",
        className
      )}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

// --- COMPOUND EXPORT ---
export const ContextMenu = Object.assign(ContextMenuRoot, {
  Trigger: ContextMenuTrigger,
  Content: ContextMenuContent,
  Item: ContextMenuItem,
  CheckboxItem: ContextMenuCheckboxItem,
  RadioGroup: ContextMenuRadioGroup,
  RadioItem: ContextMenuRadioItem,
  Label: ContextMenuLabel,
  Separator: ContextMenuSeparator,
  Shortcut: ContextMenuShortcut,
  Group: ContextMenuGroup,
  Portal: ContextMenuPortal,
  Sub: ContextMenuSub,
  SubContent: ContextMenuSubContent,
  SubTrigger: ContextMenuSubTrigger,
});
```

**Storybook Stories (`context-menu.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Copy,
  ExternalLink,
  Pen,
  Share2,
  Trash2,
  UserPlus,
} from "lucide-react";
import { useState } from "react";
import { Card } from "../card";
import { Typography } from "../typography";
import { ContextMenu } from "./index";

const meta: Meta<typeof ContextMenu> = {
  title: "Components/ContextMenu",
  component: ContextMenu,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A menu that appears on right-click (desktop) or long-press (mobile). It is built on Radix UI for accessibility.",
      },
    },
  },
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
  },
};

export default meta;
type Story = StoryObj<typeof ContextMenu>;

const MenuContent = () => (
  <>
    <ContextMenu.Item>
      <Pen className="mr-2 h-4 w-4" />
      <span>Edit</span>
      <ContextMenu.Shortcut>⌘E</ContextMenu.Shortcut>
    </ContextMenu.Item>
    <ContextMenu.Item>
      <Copy className="mr-2 h-4 w-4" />
      <span>Copy</span>
      <ContextMenu.Shortcut>⌘C</ContextMenu.Shortcut>
    </ContextMenu.Item>
    <ContextMenu.Separator />
    <ContextMenu.Item>
      <Share2 className="mr-2 h-4 w-4" />
      <span>Share</span>
    </ContextMenu.Item>
    <ContextMenu.Separator />
    <ContextMenu.Item className="text-red-500 hover:!bg-red-500/10">
      <Trash2 className="mr-2 h-4 w-4" />
      <span>Delete</span>
      <ContextMenu.Shortcut>⌘⌫</ContextMenu.Shortcut>
    </ContextMenu.Item>
  </>
);

export const Default: Story = {
  name: "1. Basic Usage",
  args: {
    shape: "sharp",
    size: "sm",
  },
  render: (args) => (
    <ContextMenu {...args}>
      <ContextMenu.Trigger asChild>
        <Card className="flex h-48 w-80 cursor-default items-center justify-center border-2 border-dashed">
          <Typography variant="muted">
            Right-click or long-press here
          </Typography>
        </Card>
      </ContextMenu.Trigger>
      <ContextMenu.Content>
        <MenuContent />
      </ContextMenu.Content>
    </ContextMenu>
  ),
};

export const AllSizes: Story = {
  name: "2. All Sizes",
  render: () => (
    <div className="flex items-start gap-8">
      <ContextMenu size="sm">
        <ContextMenu.Trigger asChild>
          <Card className="flex h-32 w-48 cursor-default items-center justify-center border-2 border-dashed">
            <Typography variant="small">Small Menu</Typography>
          </Card>
        </ContextMenu.Trigger>
        <ContextMenu.Content>
          <MenuContent />
        </ContextMenu.Content>
      </ContextMenu>
      <ContextMenu size="md">
        <ContextMenu.Trigger asChild>
          <Card className="flex h-32 w-48 cursor-default items-center justify-center border-2 border-dashed">
            <Typography variant="small">Medium Menu</Typography>
          </Card>
        </ContextMenu.Trigger>
        <ContextMenu.Content>
          <MenuContent />
        </ContextMenu.Content>
      </ContextMenu>
      <ContextMenu size="lg">
        <ContextMenu.Trigger asChild>
          <Card className="flex h-32 w-48 cursor-default items-center justify-center border-2 border-dashed">
            <Typography variant="small">Large Menu</Typography>
          </Card>
        </ContextMenu.Trigger>
        <ContextMenu.Content>
          <MenuContent />
        </ContextMenu.Content>
      </ContextMenu>
    </div>
  ),
};

export const KitchenSink: Story = {
  name: "3. Kitchen Sink",
  args: {
    size: "md",
    shape: "minimal",
  },
  render: function Render(args) {
    const [showGrid, setShowGrid] = useState(true);
    const [theme, setTheme] = useState("dark");
    return (
      <ContextMenu {...args}>
        <ContextMenu.Trigger asChild>
          <Card className="flex h-48 w-80 cursor-default items-center justify-center border-2 border-dashed">
            <Typography variant="muted">
              Right-click or long-press here
            </Typography>
          </Card>
        </ContextMenu.Trigger>
        <ContextMenu.Content>
          <ContextMenu.Item>
            Open in New Tab <ContextMenu.Shortcut>⌘T</ContextMenu.Shortcut>
          </ContextMenu.Item>
          <ContextMenu.Item disabled>
            Print... <ContextMenu.Shortcut>⌘P</ContextMenu.Shortcut>
          </ContextMenu.Item>
          <ContextMenu.Separator />
          <ContextMenu.CheckboxItem
            checked={showGrid}
            onCheckedChange={setShowGrid}
          >
            Show Grid Lines
          </ContextMenu.CheckboxItem>
          <ContextMenu.Separator />
          <ContextMenu.Label>Theme</ContextMenu.Label>
          <ContextMenu.RadioGroup value={theme} onValueChange={setTheme}>
            <ContextMenu.RadioItem value="light">Light</ContextMenu.RadioItem>
            <ContextMenu.RadioItem value="dark">Dark</ContextMenu.RadioItem>
            <ContextMenu.RadioItem value="system">System</ContextMenu.RadioItem>
          </ContextMenu.RadioGroup>
          <ContextMenu.Separator />
          <ContextMenu.Sub>
            <ContextMenu.SubTrigger>
              <UserPlus className="mr-2 h-4 w-4" />
              Share with...
            </ContextMenu.SubTrigger>
            <ContextMenu.Portal>
              <ContextMenu.SubContent>
                <ContextMenu.Item>
                  <ExternalLink className="mr-2 h-4 w-4" />
                  Email Link
                </ContextMenu.Item>
                <ContextMenu.Item>
                  <Copy className="mr-2 h-4 w-4" />
                  Copy Link
                </ContextMenu.Item>
              </ContextMenu.SubContent>
            </ContextMenu.Portal>
          </ContextMenu.Sub>
        </ContextMenu.Content>
      </ContextMenu>
    );
  },
};
```


### Component: `date-picker`

This section contains the source code for the `date-picker` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\date-picker\header.tsx`)**
```tsx
import { format } from "date-fns";
import { Pencil } from "lucide-react";
import React from "react";
import type { DateRange } from "react-day-picker";
import { IconButton } from "../icon-button";
import { Typography } from "../typography";

interface DatePickerHeaderProps {
  mode: "single" | "range";
  selectedDate?: Date;
  selectedRange?: DateRange;
  onEditClick: () => void;
}

export const DatePickerHeader = ({
  mode,
  selectedDate,
  selectedRange,
  onEditClick,
}: DatePickerHeaderProps) => {
  const getSingleDateText = () => {
    if (!selectedDate) return "Select date";
    return format(selectedDate, "E, MMM d");
  };

  const getRangeDateText = () => {
    if (!selectedRange?.from) return "Select dates";
    if (selectedRange.from && !selectedRange.to) {
      return format(selectedRange.from, "MMM d");
    }
    if (selectedRange.from && selectedRange.to) {
      return `${format(selectedRange.from, "MMM d")} – ${format(
        selectedRange.to,
        "MMM d"
      )}`;
    }
    return "Select dates";
  };

  return (
    <div className="flex items-center justify-between pt-6 px-0 pb-2">
      <div>
        {mode === "range" && (
          <Typography variant="muted">Depart – Return dates</Typography>
        )}
        <Typography variant="h2" className="!mt-0">
          {mode === "single" ? getSingleDateText() : getRangeDateText()}
        </Typography>
      </div>
      <IconButton
        variant="ghost"
        size="md"
        aria-label="Enter date manually"
        onClick={onEditClick}
      >
        <Pencil className="h-5 w-5" />
      </IconButton>
    </div>
  );
};
```

**Storybook Stories (`Date-picker.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { addDays } from "date-fns";
import { useState } from "react";
import type { DateRange } from "react-day-picker";
import { DatePicker } from "./index";

const meta: Meta<typeof DatePicker> = {
  title: "Components/Date & Time/DatePicker",
  component: DatePicker,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A fully custom, MD3-compliant date picker with single/range modes, a spacious paginated calendar, and a manual input mode. It has three variants: `docked` (desktop), `modal`, and `fullscreen` (mobile).",
      },
    },
  },
  argTypes: {
    mode: {
      control: "select",
      options: ["single", "range"],
      description:
        "Determines if a single date or a date range can be selected.",
    },
    variant: {
      control: "select",
      options: ["docked", "modal", "fullscreen"],
      description:
        "Overrides the default responsive behavior to force a specific variant.",
    },
    size: { control: "select", options: ["sm", "md", "lg"] },
    shape: { control: "select", options: ["full", "minimal", "sharp"] },
    label: { control: "text" },
    disabled: { control: "boolean" },
    value: { control: false },
    onChange: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof DatePicker>;

export const Docked: Story = {
  name: "1. Docked (Desktop Default)",
  args: {
    variant: "docked",
    label: "Event Date",
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | undefined>(new Date());
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={date}
          onChange={(val) => setDate(val as Date)}
        />
      </div>
    );
  },
};

export const ModalSingle: Story = {
  name: "2. Modal (Single Date)",
  args: {
    variant: "modal",
    label: "Appointment",
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | undefined>(new Date());
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={date}
          onChange={(val) => setDate(val as Date)}
        />
      </div>
    );
  },
};

export const ModalRange: Story = {
  name: "3. Modal (Date Range)",
  args: {
    variant: "modal",
    label: "Vacation",
    mode: "range",
  },
  render: function Render(args) {
    const [range, setRange] = useState<DateRange | undefined>({
      from: new Date(),
      to: addDays(new Date(), 5),
    });
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={range}
          onChange={(val) => setRange(val as DateRange)}
        />
      </div>
    );
  },
};

export const InputMode: Story = {
  name: "4. Manual Input Mode",
  args: {
    variant: "modal",
    label: "Date of Birth",
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | undefined>(new Date("1990-01-01"));
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={date}
          onChange={(val) => setDate(val as Date)}
        />
      </div>
    );
  },
  parameters: {
    docs: {
      description: {
        story:
          "Click the pencil icon in the modal to switch to the manual text input view.",
      },
    },
  },
};
```


### Component: `dialog`

This section contains the source code for the `dialog` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\dialog\index.tsx`)**
```tsx
// src/components/dialog/index.tsx
import { clsx } from "clsx";
import FocusTrap from "focus-trap-react";
import { AnimatePresence, motion, type Variants } from "framer-motion";
import {
  cloneElement,
  createContext,
  forwardRef,
  isValidElement,
  useContext,
  useEffect,
  useId,
  useState,
  type ButtonHTMLAttributes,
  type FC,
  type HTMLAttributes,
  type MouseEvent,
  type ReactNode,
} from "react";
import ReactDOM from "react-dom";
import { Card, type CardProps } from "../card";
import {
  ElasticScrollArea,
  type ElasticScrollAreaProps,
} from "../elastic-scroll-area";
import { Typography } from "../typography";

// --- CONTEXT and PORTAL ---
type DialogVariant = "basic" | "fullscreen";
interface DialogContextProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  setTriggerRef: (node: HTMLElement | null) => void;
  titleId: string;
  descriptionId: string;
  variant: DialogVariant;
}
const DialogContext = createContext<DialogContextProps | null>(null);
const useDialogContext = () => {
  const context = useContext(DialogContext);
  if (!context) {
    throw new Error("Dialog components must be used within a <Dialog>");
  }
  return context;
};
const Portal: FC<{ children: ReactNode }> = ({ children }) => {
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);
  return mounted ? ReactDOM.createPortal(children, document.body) : null;
};

// --- ROOT Component ---
export interface DialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  children: ReactNode;
  variant?: DialogVariant;
}
const Dialog: FC<DialogProps> = ({
  open,
  onOpenChange,
  children,
  variant = "basic",
}) => {
  const [, setTriggerRef] = useState<HTMLElement | null>(null);
  const titleId = useId();
  const descriptionId = useId();
  return (
    <DialogContext.Provider
      value={{
        open,
        onOpenChange,
        setTriggerRef,
        titleId,
        descriptionId,
        variant,
      }}
    >
      {children}
    </DialogContext.Provider>
  );
};

// --- TRIGGER ---
interface DialogTriggerProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}
const DialogTrigger = forwardRef<HTMLButtonElement, DialogTriggerProps>(
  ({ children, asChild = false, onClick, ...props }, ref) => {
    const { onOpenChange, setTriggerRef } = useDialogContext();
    const handleRef = (node: HTMLButtonElement | null) => {
      setTriggerRef(node);
      if (typeof ref === "function") ref(node);
      else if (ref) ref.current = node;
    };
    const triggerProps = {
      ...props,
      ref: handleRef,
      onClick: (e: MouseEvent<HTMLButtonElement>) => {
        onOpenChange(true);
        onClick?.(e);
      },
    };
    if (asChild && isValidElement(children)) {
      return cloneElement(children, triggerProps);
    }
    return <button {...triggerProps}>{children}</button>;
  }
);
DialogTrigger.displayName = "DialogTrigger";

// --- ANIMATION VARIANTS ---
const basicDialogVariants: Variants = {
  hidden: { opacity: 0, scale: 0.92 },
  visible: {
    opacity: 1,
    scale: 1,
    transition: { duration: 0.3, ease: [0.2, 0, 0, 1.1] },
  },
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: { duration: 0.2, ease: [0.4, 0, 1, 1] },
  },
};
const fullscreenDialogVariants: Variants = {
  hidden: { y: "100%", opacity: 0 },
  visible: {
    y: "0%",
    opacity: 1,
    transition: { duration: 0.35, ease: [0.2, 0.7, 0.1, 1] },
  },
  exit: {
    y: "50%",
    opacity: 0,
    transition: { duration: 0.2, ease: [0.2, 0.2, 0.5, 1] },
  },
};
const iosBackdropVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.25, ease: [0.25, 0.46, 0.45, 0.94] },
  },
  exit: {
    opacity: 0,
    transition: { duration: 0.2, ease: [0.25, 0.46, 0.45, 0.94] },
  },
};
const materialBackdropVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: { duration: 0.25, ease: [0.4, 0, 0.2, 1] },
  },
  exit: { opacity: 0, transition: { duration: 0.2, ease: [0.4, 0, 1, 1] } },
};
const materialContentVariants: Variants = {
  hidden: { opacity: 0, y: 8 },
  visible: {
    opacity: 1,
    y: 0,
    transition: { duration: 0.25, delay: 0.1, ease: [0.4, 0, 0.2, 1] },
  },
};

// --- CONTENT ---
export interface DialogContentProps extends HTMLAttributes<HTMLDivElement> {
  shape?: CardProps["shape"];
}
const DialogContent = forwardRef<HTMLDivElement, DialogContentProps>(
  ({ className, children, shape = "minimal", ...props }, ref) => {
    const { open, onOpenChange, titleId, descriptionId, variant } =
      useDialogContext();

    useEffect(() => {
      if (open) {
        document.body.style.overflow = "hidden";
        if (variant === "fullscreen") {
          document.body.style.overscrollBehavior = "none";
        }
      }
      return () => {
        document.body.style.overflow = "";
        document.body.style.overscrollBehavior = "";
      };
    }, [open, variant]);

    const isFullscreen = variant === "fullscreen";
    const backdropVariants = isFullscreen
      ? materialBackdropVariants
      : iosBackdropVariants;

    return (
      <Portal>
        <AnimatePresence mode="wait">
          {open && (
            <FocusTrap
              active={open}
              focusTrapOptions={{
                onDeactivate: () => onOpenChange(false),
                escapeDeactivates: true,
                allowOutsideClick: true,
              }}
            >
              <div
                ref={ref}
                className={clsx(
                  "fixed inset-0 z-50 flex",
                  !isFullscreen && "items-center justify-center p-4 sm:p-8",
                  isFullscreen &&
                    "items-end sm:items-center sm:justify-center  sm:p-8"
                )}
                {...props}
              >
                <motion.div
                  initial="hidden"
                  animate="visible"
                  exit="exit"
                  variants={backdropVariants}
                  className={clsx(
                    "absolute inset-0",
                    isFullscreen ? "bg-black/32" : "bg-black/50"
                  )}
                  onClick={() => onOpenChange(false)}
                  style={{ willChange: "opacity" }}
                />
                <motion.div
                  role="dialog"
                  aria-modal="true"
                  aria-labelledby={titleId}
                  aria-describedby={descriptionId}
                  variants={
                    isFullscreen
                      ? fullscreenDialogVariants
                      : basicDialogVariants
                  }
                  initial="hidden"
                  animate="visible"
                  exit="exit"
                  className={clsx(
                    "relative z-10 flex flex-col",
                    isFullscreen
                      ? [
                          "w-full bg-white shadow-2xl",
                          "h-full sm:max-h-[90vh] sm:w-full sm:max-w-2xl",
                          "sm:rounded-3xl",
                          "overflow-hidden",
                        ]
                      : "w-full max-w-lg",
                    className
                  )}
                  style={{
                    willChange: "transform, opacity",
                    backfaceVisibility: "hidden",
                    transform: "translate3d(0, 0, 0)",
                  }}
                >
                  {isFullscreen ? (
                    <motion.div
                      className="flex h-full flex-col"
                      initial="hidden"
                      animate="visible"
                      variants={materialContentVariants}
                      style={{
                        willChange: "opacity",
                        transform: "translate3d(0, 0, 0)",
                      }}
                    >
                      {children}
                    </motion.div>
                  ) : (
                    <Card shape={shape} className="relative w-full shadow-2xl">
                      {children}
                    </Card>
                  )}
                </motion.div>
              </div>
            </FocusTrap>
          )}
        </AnimatePresence>
      </Portal>
    );
  }
);
DialogContent.displayName = "DialogContent";

// --- HELPER COMPONENTS ---
interface DialogCloseProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}
const DialogClose = forwardRef<HTMLButtonElement, DialogCloseProps>(
  ({ children, asChild = false, onClick, ...props }, ref) => {
    const { onOpenChange } = useDialogContext();
    const closeProps = {
      ...props,
      ref,
      onClick: (e: MouseEvent<HTMLButtonElement>) => {
        onOpenChange(false);
        onClick?.(e);
      },
    };
    if (asChild && isValidElement(children)) {
      return cloneElement(children, closeProps);
    }
    return <button {...closeProps}>{children}</button>;
  }
);
DialogClose.displayName = "DialogClose";

const DialogHeader = (props: HTMLAttributes<HTMLDivElement>) => {
  const { variant } = useDialogContext();
  return (
    <div
      className={clsx(
        variant === "basic" &&
          "flex flex-col space-y-1.5 text-center sm:text-left",
        variant === "fullscreen" && [
          "flex flex-shrink-0 flex-row items-center justify-between",
          "px-6 py-4 sm:px-8 sm:py-6",
          "bg-white",
          "border-b border-gray-200/60",
        ],
        props.className
      )}
      style={{
        ...(variant === "fullscreen" && {
          willChange: "transform",
          transform: "translate3d(0, 0, 0)",
        }),
      }}
      {...props}
    />
  );
};
DialogHeader.displayName = "DialogHeader";

const DialogFooter = (props: HTMLAttributes<HTMLDivElement>) => {
  const { variant } = useDialogContext();
  return (
    <div
      className={clsx(
        variant === "basic" && "mt-6 flex gap-2 sm:justify-end",
        variant === "fullscreen" && [
          "flex flex-shrink-0 flex-row justify-end gap-3",
          "px-6 py-4 sm:px-8 sm:py-6",
          "bg-white",
          "border-t border-gray-200/60",
        ],
        props.className
      )}
      style={{
        ...(variant === "fullscreen" && {
          willChange: "transform",
          transform: "translate3d(0, 0, 0)",
        }),
      }}
      {...props}
    />
  );
};
DialogFooter.displayName = "DialogFooter";

const DialogTitle = forwardRef<
  HTMLHeadingElement,
  HTMLAttributes<HTMLHeadingElement>
>((props, ref) => {
  const { titleId, variant } = useDialogContext();
  return (
    <h2
      ref={ref}
      id={titleId}
      className={clsx(
        "font-semibold tracking-tight",
        variant === "fullscreen" ? "text-2xl sm:text-3xl" : "text-xl"
      )}
      {...props}
    />
  );
});
DialogTitle.displayName = "DialogTitle";

const DialogDescription = forwardRef<
  HTMLParagraphElement,
  HTMLAttributes<HTMLParagraphElement>
>((props, ref) => {
  const { descriptionId } = useDialogContext();
  return <Typography variant="muted" ref={ref} id={descriptionId} {...props} />;
});
DialogDescription.displayName = "DialogDescription";

// --- MODIFIED: DialogBody now integrates ElasticScrollArea ---
export interface DialogBodyProps
  extends Omit<HTMLAttributes<HTMLDivElement>, "dir">,
    Omit<ElasticScrollAreaProps, "children" | "className" | "ref"> {}

const DialogBody = forwardRef<HTMLDivElement, DialogBodyProps>(
  (
    {
      className,
      children,
      elasticity = true,
      pullToRefresh,
      onRefresh,
      ...props
    },
    ref
  ) => {
    const { variant } = useDialogContext();

    if (variant === "fullscreen") {
      return (
        <ElasticScrollArea
          ref={ref}
          className={clsx(
            "flex-1 pt-0!",
            "px-6 py-4 sm:px-8 sm:py-6 transition-all",
            className
          )}
          elasticity={elasticity}
          pullToRefresh={pullToRefresh}
          onRefresh={onRefresh}
          {...props}
        >
          {children}
        </ElasticScrollArea>
      );
    }

    return (
      <div ref={ref} className={clsx("flex-1", className)} {...props}>
        {children}
      </div>
    );
  }
);
DialogBody.displayName = "DialogBody";

// --- EXPORTS ---
export {
  Dialog,
  DialogBody,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
};
```

**Storybook Stories (`Dialog.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { X } from "lucide-react";
import { useRef, useState } from "react";
import { AppBar } from "../appbar";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { Input } from "../input";
import { Typography } from "../typography";
import {
  Dialog,
  DialogBody,
  DialogClose,
  DialogContent,
  type DialogContentProps,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  type DialogProps,
  DialogTitle,
  DialogTrigger,
} from "./index";

type StoryComponentProps = DialogProps & Pick<DialogContentProps, "shape">;

const meta: Meta<StoryComponentProps> = {
  title: "Components/Dialog",
  component: Dialog,
  tags: ["autodocs"],
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "A fully accessible, custom-built dialog component with support for basic and fullscreen variants. The fullscreen variant's body is an `ElasticScrollArea`, enabling pull-to-refresh and other advanced scrolling effects.",
      },
    },
  },
  argTypes: {
    variant: {
      control: "select",
      options: ["basic", "fullscreen"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      if: { arg: "variant", eq: "basic" },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

// Mock refresh function for the story
const simulateRefresh = () => {
  console.log("Refresh triggered!");
  return new Promise((resolve) => setTimeout(resolve, 2000));
};

export const Basic: Story = {
  name: "Basic Dialog",
  args: { variant: "basic", shape: "minimal" },
  parameters: { layout: "centered" },
  render: (args) => {
    const [isOpen, setIsOpen] = useState(false);
    return (
      <Dialog open={isOpen} onOpenChange={setIsOpen} variant={args.variant}>
        <DialogTrigger asChild>
          <Button>Open Basic Dialog</Button>
        </DialogTrigger>
        <DialogContent shape={args.shape}>
          <DialogHeader>
            <DialogTitle>Basic Dialog Title</DialogTitle>
            <DialogDescription>
              This is a standard modal dialog.
            </DialogDescription>
          </DialogHeader>
          <div className="py-4">
            <Typography variant="p">
              It floats in the center and has a scale/fade animation.
            </Typography>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="secondary">Cancel</Button>
            </DialogClose>
            <Button>Confirm</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  },
};

export const FullScreen: Story = {
  name: "Full-Screen Dialog with AppBar",
  args: { variant: "fullscreen" },
  parameters: {
    viewport: { defaultViewport: "mobile1" },
    docs: {
      description: {
        story:
          "The `DialogBody` in a fullscreen dialog is now an `ElasticScrollArea`. This allows for native-like scrolling and enables features like `pullToRefresh`. The `AppBar`'s `scrollContainerRef` points to the `DialogBody`'s ref to synchronize scroll animations.",
      },
    },
  },
  render: (args) => {
    const [isOpen, setIsOpen] = useState(false);
    const scrollRef = useRef<HTMLDivElement>(null);

    return (
      <div className="h-screen w-screen bg-gray-100 p-4">
        <Dialog open={isOpen} onOpenChange={setIsOpen} variant={args.variant}>
          <DialogTrigger asChild>
            <Button>Open Full-Screen Dialog</Button>
          </DialogTrigger>
          <DialogContent>
            <AppBar
              size="md"
              scrollBehavior="conditionally-sticky"
              startAdornment={
                <DialogClose asChild>
                  <IconButton variant="ghost" size={"md"} shape="full">
                    <X className="h-5 w-5" />
                  </IconButton>
                </DialogClose>
              }
              animatedBehavior={["shadow"]}
              appBarColor="card"
              endAdornments={[
                <Button key="save" size={"sm"} variant="secondary">
                  Save
                </Button>,
              ]}
              scrollContainerRef={scrollRef}
            >
              <Typography variant="h4" className="truncate font-semibold">
                Create New Event
              </Typography>
            </AppBar>

            <DialogBody
              ref={scrollRef}
              className="px-4 pb-8"
              pullToRefresh={false}
              onRefresh={simulateRefresh}
            >
              <div className="grid gap-6 pt-[70px]">
                <Input label="Event name" placeholder="Team Sync" />
                <Input label="Location" placeholder="Conference Room 4" />
                <Typography variant="p">
                  Scroll down to see the AppBar animate. You can also pull down
                  from the top to refresh.
                </Typography>
                <div className="h-96 rounded-lg border-2 border-dashed border-gray-200 bg-gray-50" />
                <div className="h-96 rounded-lg border-2 border-dashed border-gray-200 bg-gray-50" />
                <Typography variant="p" className="text-center">
                  End of content.
                </Typography>
              </div>
            </DialogBody>
          </DialogContent>
        </Dialog>
      </div>
    );
  },
};
```


### Component: `dropdown-menu`

This section contains the source code for the `dropdown-menu` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\dropdown-menu\index.tsx`)**
```tsx
"use client";

import * as RadixDropdownMenu from "@radix-ui/react-dropdown-menu";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { Check, ChevronRight, Circle } from "lucide-react";
import React, { createContext, useContext } from "react";
import useRipple from "use-ripple-hook";

type DropdownMenuShape = "full" | "minimal" | "sharp";

// --- Context to pass shape down the tree ---
interface DropdownMenuContextProps {
  shape: DropdownMenuShape;
}

const DropdownMenuContext = createContext<DropdownMenuContextProps>({
  shape: "minimal",
});

const useDropdownMenuContext = () => useContext(DropdownMenuContext);

// --- Root Component (Wrapped to provide context) ---
interface DropdownMenuProps extends RadixDropdownMenu.DropdownMenuProps {
  shape?: DropdownMenuShape;
}

const DropdownMenu: React.FC<DropdownMenuProps> = ({
  shape = "minimal",
  ...props
}) => {
  return (
    <DropdownMenuContext.Provider value={{ shape }}>
      <RadixDropdownMenu.Root {...props} />
    </DropdownMenuContext.Provider>
  );
};

const DropdownMenuTrigger = RadixDropdownMenu.Trigger;
const DropdownMenuGroup = RadixDropdownMenu.Group;
const DropdownMenuPortal = RadixDropdownMenu.Portal;
const DropdownMenuSub = RadixDropdownMenu.Sub;
const DropdownMenuRadioGroup = RadixDropdownMenu.RadioGroup;

// --- CVA for Content Components ---
const contentVariants = cva(
  [
    "z-50 min-w-[12rem] max-h-[var(--radix-dropdown-menu-content-available-height)] overflow-y-auto overflow-x-hidden",
    "border border-graphite-border bg-graphite-card p-1.5",
    "shadow-md",
  ],
  {
    variants: {
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      shape: "minimal",
    },
  }
);

// --- Enhanced Animated Content Container ---
const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Content>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Content>
>(({ className, sideOffset = 8, ...props }, ref) => {
  const { shape } = useDropdownMenuContext();
  return (
    <RadixDropdownMenu.Portal>
      <RadixDropdownMenu.Content
        ref={ref}
        sideOffset={sideOffset}
        className={clsx(
          contentVariants({ shape }),
          "data-[state=open]:animate-menu-enter",
          "data-[state=closed]:animate-menu-exit",
          "data-[side=top]:origin-bottom",
          "data-[side=bottom]:origin-top",
          "data-[side=left]:origin-right",
          "data-[side=right]:origin-left",
          className
        )}
        {...props}
      />
    </RadixDropdownMenu.Portal>
  );
});
DropdownMenuContent.displayName = RadixDropdownMenu.Content.displayName;

// --- Enhanced Menu Item (Restored Original Styles) ---
const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Item>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.Item
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center gap-2 rounded-lg px-3 py-2.5 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        "[&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    />
  );
});
DropdownMenuItem.displayName = RadixDropdownMenu.Item.displayName;

// --- Enhanced Checkbox Item (Restored Original Styles) ---
const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.CheckboxItem>
>(({ className, children, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.CheckboxItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center rounded-lg py-2.5 pl-8 pr-3 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixDropdownMenu.ItemIndicator>
          <Check className="h-4 w-4 animate-check-in" />
        </RadixDropdownMenu.ItemIndicator>
      </span>
      {children}
    </RadixDropdownMenu.CheckboxItem>
  );
});
DropdownMenuCheckboxItem.displayName =
  RadixDropdownMenu.CheckboxItem.displayName;

// --- Enhanced Radio Item (Restored Original Styles) ---
const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.RadioItem>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.RadioItem>
>(({ className, children, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.RadioItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center rounded-lg py-2.5 pl-8 pr-3 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixDropdownMenu.ItemIndicator>
          <Circle className="h-2 w-2 fill-current animate-check-in" />
        </RadixDropdownMenu.ItemIndicator>
      </span>
      {children}
    </RadixDropdownMenu.RadioItem>
  );
});
DropdownMenuRadioItem.displayName = RadixDropdownMenu.RadioItem.displayName;

// --- Enhanced Sub-Menu Trigger (Restored Original Styles) ---
const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, children, inset, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.SubTrigger
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center gap-2 rounded-lg px-3 py-2.5 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary",
        "data-[state=open]:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "[&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRight className="ml-auto h-4 w-4 transition-transform duration-200 ease-[cubic-bezier(0.2,0,0,1)] group-data-[state=open]:rotate-90" />
    </RadixDropdownMenu.SubTrigger>
  );
});
DropdownMenuSubTrigger.displayName = RadixDropdownMenu.SubTrigger.displayName;

// --- Enhanced Sub-Menu Content ---
const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.SubContent>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.SubContent>
>(({ className, ...props }, ref) => {
  const { shape } = useDropdownMenuContext();
  return (
    <RadixDropdownMenu.SubContent
      ref={ref}
      className={clsx(
        contentVariants({ shape }),
        "data-[state=open]:data-[side=right]:animate-submenu-enter-right",
        "data-[state=closed]:data-[side=right]:animate-submenu-exit-right",
        "data-[state=open]:data-[side=left]:animate-submenu-enter-left",
        "data-[state=closed]:data-[side=left]:animate-submenu-exit-left",
        "data-[state=open]:data-[side=top]:animate-menu-enter",
        "data-[state=closed]:data-[side=top]:animate-menu-exit",
        "data-[state=open]:data-[side=bottom]:animate-menu-enter",
        "data-[state=closed]:data-[side=bottom]:animate-menu-exit",
        className
      )}
      {...props}
    />
  );
});
DropdownMenuSubContent.displayName = RadixDropdownMenu.SubContent.displayName;

// --- Other Components (Unchanged) ---
const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Label>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <RadixDropdownMenu.Label
    ref={ref}
    className={clsx(
      "px-3 py-2 text-xs font-medium text-graphite-foreground/70 tracking-wide",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = RadixDropdownMenu.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Separator>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Separator>
>(({ className, ...props }, ref) => (
  <RadixDropdownMenu.Separator
    ref={ref}
    className={clsx("-mx-1 my-1.5 h-px bg-graphite-border/60", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = RadixDropdownMenu.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={clsx(
        "ml-auto text-xs font-mono tracking-wider text-graphite-foreground/50",
        className
      )}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};
```

**Storybook Stories (`DropdownMenu.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Cloud,
  CreditCard,
  LifeBuoy,
  LogOut,
  Mail,
  MessageSquare,
  Plus,
  PlusCircle,
  Settings,
  User,
  UserPlus,
  Users,
} from "lucide-react";
import { useState } from "react";
import { Button } from "../button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "./index";

const meta: Meta<typeof DropdownMenu> = {
  title: "Components/DropdownMenu",
  component: DropdownMenu,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
  },
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
};

export default meta;
type Story = StoryObj<typeof DropdownMenu>;

export const Default: Story = {
  name: "1. Basic Usage",
  args: {
    shape: "minimal",
  },
  render: (args) => (
    <DropdownMenu {...args}>
      <DropdownMenuTrigger asChild>
        <Button>Open Menu</Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent>
        <DropdownMenuItem>
          <User className="mr-2 h-4 w-4" />
          <span>Profile</span>
          <DropdownMenuShortcut>⇧⌘P</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <CreditCard className="mr-2 h-4 w-4" />
          <span>Billing</span>
          <DropdownMenuShortcut>⌘B</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <Settings className="mr-2 h-4 w-4" />
          <span>Settings</span>
          <DropdownMenuShortcut>⌘S</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem disabled>
          <Cloud className="mr-2 h-4 w-4" />
          <span>API (Disabled)</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
          <DropdownMenuShortcut>⇧⌘Q</DropdownMenuShortcut>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};

// New story to showcase shapes
export const AllShapes: Story = {
  name: "2. All Shapes",
  render: () => (
    <div className="flex items-center gap-4">
      <DropdownMenu shape="full">
        <DropdownMenuTrigger asChild>
          <Button>Full</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem>Profile</DropdownMenuItem>
          <DropdownMenuItem>Settings</DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
      <DropdownMenu shape="minimal">
        <DropdownMenuTrigger asChild>
          <Button>Minimal</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem>Profile</DropdownMenuItem>
          <DropdownMenuItem>Settings</DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
      <DropdownMenu shape="sharp">
        <DropdownMenuTrigger asChild>
          <Button>Sharp</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem>Profile</DropdownMenuItem>
          <DropdownMenuItem>Settings</DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  ),
};

export const WithGroupsAndLabels: Story = {
  name: "3. Groups & Labels",
  args: {
    shape: "minimal",
  },
  render: (args) => (
    <DropdownMenu {...args}>
      <DropdownMenuTrigger asChild>
        <Button variant="secondary">Open Grouped Menu</Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56">
        <DropdownMenuLabel>My Account</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem>
            <User className="mr-2 h-4 w-4" />
            <span>Profile</span>
          </DropdownMenuItem>
          <DropdownMenuItem>
            <Settings className="mr-2 h-4 w-4" />
            <span>Settings</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem>
            <Users className="mr-2 h-4 w-4" />
            <span>Team</span>
          </DropdownMenuItem>
          <DropdownMenuItem>
            <UserPlus className="mr-2 h-4 w-4" />
            <span>Invite users</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          <LifeBuoy className="mr-2 h-4 w-4" />
          <span>Support</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};

export const WithCheckboxes: Story = {
  name: "4. Checkbox Items",
  args: {
    shape: "minimal",
  },
  render: (args) => {
    const [showStatusBar, setShowStatusBar] = useState(true);
    const [showActivityBar, setShowActivityBar] = useState(false);
    return (
      <DropdownMenu {...args}>
        <DropdownMenuTrigger asChild>
          <Button>View Options</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-56">
          <DropdownMenuLabel>Panel Visibility</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuCheckboxItem
            checked={showStatusBar}
            onCheckedChange={setShowStatusBar}
          >
            Status Bar
          </DropdownMenuCheckboxItem>
          <DropdownMenuCheckboxItem
            checked={showActivityBar}
            onCheckedChange={setShowActivityBar}
          >
            Activity Bar
          </DropdownMenuCheckboxItem>
          <DropdownMenuCheckboxItem disabled>Panel</DropdownMenuCheckboxItem>
        </DropdownMenuContent>
      </DropdownMenu>
    );
  },
};

export const WithRadioGroup: Story = {
  name: "5. Radio Group Items",
  args: {
    shape: "minimal",
  },
  render: (args) => {
    const [position, setPosition] = useState("bottom");
    return (
      <DropdownMenu {...args}>
        <DropdownMenuTrigger asChild>
          <Button variant="secondary">Set Position</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-56">
          <DropdownMenuLabel>Panel Position</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuRadioGroup value={position} onValueChange={setPosition}>
            <DropdownMenuRadioItem value="top">Top</DropdownMenuRadioItem>
            <DropdownMenuRadioItem value="bottom">Bottom</DropdownMenuRadioItem>
            <DropdownMenuRadioItem value="right">Right</DropdownMenuRadioItem>
          </DropdownMenuRadioGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    );
  },
};

export const WithSubMenu: Story = {
  name: "6. Sub-Menus",
  args: {
    shape: "minimal",
  },
  render: (args) => (
    <DropdownMenu {...args}>
      <DropdownMenuTrigger asChild>
        <Button>Open With Sub-Menu</Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56">
        <DropdownMenuItem>
          <Mail className="mr-2 h-4 w-4" />
          <span>Email</span>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <MessageSquare className="mr-2 h-4 w-4" />
          <span>Message</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuSub>
          <DropdownMenuSubTrigger>
            <UserPlus className="mr-2 h-4 w-4" />
            <span>Invite</span>
          </DropdownMenuSubTrigger>
          <DropdownMenuPortal>
            <DropdownMenuSubContent>
              <DropdownMenuItem>
                <Plus className="mr-2 h-4 w-4" />
                <span>New User</span>
              </DropdownMenuItem>
              <DropdownMenuItem>
                <PlusCircle className="mr-2 h-4 w-4" />
                <span>New Team</span>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <span>More...</span>
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuPortal>
        </DropdownMenuSub>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};
```


### Component: `elastic-scroll-area`

This section contains the source code for the `elastic-scroll-area` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\elastic-scroll-area\index.tsx`)**
```tsx
"use client";

import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import { clsx } from "clsx";
import {
  type MotionValue,
  animate,
  motion,
  useMotionValue,
  useTransform,
} from "framer-motion";
import { ArrowDown, Loader2 } from "lucide-react";
import {
  type ComponentPropsWithoutRef,
  type ComponentType,
  type ElementRef,
  type FC,
  type RefObject,
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useRef,
  useState,
} from "react";

// --- CONSTANTS ---
const OVERSCROLL_DAMPING = 0.25;
const MAX_OVERSCROLL_DESKTOP = 200;
const SNAP_BACK_STIFFNESS = 300;
const SNAP_BACK_DAMPING = 30;
const DEFAULT_PULL_THRESHOLD = 80;

// --- TYPE DEFINITIONS (MODIFIED) ---
interface RefreshIndicatorProps {
  pullProgress: MotionValue<number>;
  isRefreshing: boolean;
}

export interface ElasticScrollAreaProps
  extends ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> {
  /** The primary scrolling direction of the content. @default "vertical" */
  orientation?: "vertical" | "horizontal";
  elasticity?: boolean;
  dampingFactor?: number;
  /**
   * Controls scrollbar visibility.
   * `auto`: Default browser behavior.
   * `always`/`visible`: Always visible.
   * `scroll`: Visible only when scrolling.
   * `hidden`: Never visible.
   * @default "auto"
   */
  scrollbarVisibility?: "auto" | "always" | "scroll" | "hidden" | "visible";
  pullToRefresh?: boolean;
  onRefresh?: () => Promise<unknown>;
  pullThreshold?: number;
  RefreshIndicatorComponent?: ComponentType<RefreshIndicatorProps>;
  /** Callback fired when the user scrolls up. */
  onScrollUp?: () => void;
  /** Callback fired when the user scrolls down. */
  onScrollDown?: () => void;
}

// --- DEFAULT REFRESH INDICATOR ---
const DefaultRefreshIndicator: FC<RefreshIndicatorProps> = ({
  pullProgress,
  isRefreshing,
}) => {
  const rotation = useTransform(
    pullProgress,
    [0, DEFAULT_PULL_THRESHOLD],
    [0, 180]
  );

  return isRefreshing ? (
    <Loader2 className="h-5 w-5 animate-spin text-graphite-primary" />
  ) : (
    <motion.div style={{ rotate: rotation }}>
      <ArrowDown className="h-5 w-5 text-graphite-foreground/70" />
    </motion.div>
  );
};
// --- OVERSCROLL & PULL-TO-REFRESH LOGIC HOOK ---
const useElasticAndRefresh = (
  viewportRef: RefObject<HTMLDivElement>,
  motionValue: MotionValue<number>,
  options: {
    orientation: "vertical" | "horizontal";
    isEnabled: boolean;
    damping: number;
    isRefreshEnabled: boolean;
    onRefresh?: () => Promise<unknown>;
    pullThreshold: number;
  }
) => {
  const {
    orientation,
    isEnabled,
    damping,
    isRefreshEnabled,
    onRefresh,
    pullThreshold,
  } = options;
  const isVertical = orientation === "vertical";

  const [isRefreshing, setIsRefreshing] = useState(false);
  const isTouching = useRef(false);
  const startPos = useRef(0);
  const isOverscrolling = useRef(false);
  const wheelTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const springToZero = useCallback(() => {
    animate(motionValue, 0, {
      type: "spring",
      stiffness: SNAP_BACK_STIFFNESS,
      damping: SNAP_BACK_DAMPING,
    });
  }, [motionValue]);

  const triggerRefresh = useCallback(async () => {
    if (!onRefresh || !isVertical) {
      springToZero();
      return;
    }
    setIsRefreshing(true);
    springToZero();
    try {
      await onRefresh();
    } finally {
      setIsRefreshing(false);
    }
  }, [onRefresh, springToZero, isVertical]);

  useEffect(() => {
    const viewport = viewportRef.current;
    if (!viewport || !isEnabled) return;

    const handleWheel = (event: WheelEvent) => {
      if (isRefreshing) return;
      const {
        scrollTop,
        scrollLeft,
        scrollHeight,
        scrollWidth,
        clientHeight,
        clientWidth,
      } = viewport;

      const scrollPos = isVertical ? scrollTop : scrollLeft;
      const scrollDim = isVertical ? scrollHeight : scrollWidth;
      const clientDim = isVertical ? clientHeight : clientWidth;
      const delta = isVertical ? event.deltaY : event.deltaX;

      const isAtStart = scrollPos <= 0;
      const isAtEnd = scrollPos >= scrollDim - clientDim;
      const isScrollingTowardsStart = delta < 0;
      const isScrollingTowardsEnd = delta > 0;

      if (
        (isAtStart && isScrollingTowardsStart) ||
        (isAtEnd && isScrollingTowardsEnd)
      ) {
        event.preventDefault();
        const currentVal = motionValue.get();
        const resistance = Math.abs(currentVal) / MAX_OVERSCROLL_DESKTOP;
        const adjustedDelta = delta * damping * (1 - resistance);
        const newVal = Math.max(
          -MAX_OVERSCROLL_DESKTOP,
          Math.min(MAX_OVERSCROLL_DESKTOP, currentVal - adjustedDelta)
        );
        motionValue.set(newVal);

        if (wheelTimeoutRef.current) clearTimeout(wheelTimeoutRef.current);
        wheelTimeoutRef.current = setTimeout(() => {
          const finalVal = motionValue.get();
          if (Math.abs(finalVal) > 0) {
            if (isRefreshEnabled && finalVal >= pullThreshold) {
              triggerRefresh();
            } else {
              springToZero();
            }
          }
        }, 50);
      }
    };

    const handleTouchStart = (event: TouchEvent) => {
      if (isRefreshing || event.touches.length !== 1) return;
      isTouching.current = true;
      startPos.current = isVertical
        ? event.touches[0].clientY
        : event.touches[0].clientX;
    };

    const handleTouchMove = (event: TouchEvent) => {
      if (!isTouching.current || isRefreshing || event.touches.length !== 1)
        return;

      const {
        scrollTop,
        scrollLeft,
        scrollHeight,
        scrollWidth,
        clientHeight,
        clientWidth,
      } = viewport;

      const scrollPos = isVertical ? scrollTop : scrollLeft;
      const scrollDim = isVertical ? scrollHeight : scrollWidth;
      const clientDim = isVertical ? clientHeight : clientWidth;
      const currentPosVal = isVertical
        ? event.touches[0].clientY
        : event.touches[0].clientX;

      const delta = currentPosVal - startPos.current;
      const isAtStart = scrollPos <= 0;
      const isAtEnd = scrollPos >= scrollDim - clientDim;
      const isPullingTowardsEnd = delta < 0;
      const isPullingTowardsStart = delta > 0;

      if (
        (isAtStart && isPullingTowardsStart) ||
        (isAtEnd && isPullingTowardsEnd)
      ) {
        isOverscrolling.current = true;
        motionValue.set(delta * damping);
      } else {
        if (isOverscrolling.current) {
          isOverscrolling.current = false;
          motionValue.set(0);
          startPos.current = currentPosVal;
        }
      }
    };

    const handleTouchEnd = () => {
      if (!isTouching.current) return;
      isTouching.current = false;
      if (isOverscrolling.current) {
        if (isRefreshEnabled && motionValue.get() >= pullThreshold) {
          triggerRefresh();
        } else {
          springToZero();
        }
        isOverscrolling.current = false;
      }
    };

    viewport.addEventListener("wheel", handleWheel, { passive: false });
    viewport.addEventListener("touchstart", handleTouchStart, {
      passive: false,
    });
    viewport.addEventListener("touchmove", handleTouchMove, { passive: false });
    viewport.addEventListener("touchend", handleTouchEnd, { passive: true });
    viewport.addEventListener("touchcancel", handleTouchEnd, {
      passive: true,
    });

    return () => {
      viewport.removeEventListener("wheel", handleWheel);
      viewport.removeEventListener("touchstart", handleTouchStart);
      viewport.removeEventListener("touchmove", handleTouchMove);
      viewport.removeEventListener("touchend", handleTouchEnd);
      viewport.removeEventListener("touchcancel", handleTouchEnd);
      if (wheelTimeoutRef.current) clearTimeout(wheelTimeoutRef.current);
    };
  }, [
    viewportRef,
    isEnabled,
    damping,
    motionValue,
    springToZero,
    isRefreshEnabled,
    pullThreshold,
    triggerRefresh,
    isRefreshing,
    isVertical,
  ]);

  return { isRefreshing };
};

// --- MAIN COMPONENT ---
const ElasticScrollAreaRoot = forwardRef<
  HTMLDivElement,
  ElasticScrollAreaProps
>(
  (
    {
      className,
      children,
      orientation = "vertical",
      elasticity = true,
      dampingFactor = OVERSCROLL_DAMPING,
      scrollbarVisibility = "auto",
      pullToRefresh = false,
      onRefresh,
      pullThreshold = DEFAULT_PULL_THRESHOLD,
      RefreshIndicatorComponent = DefaultRefreshIndicator,
      onScrollUp,
      onScrollDown,
      ...props
    },
    ref
  ) => {
    const localViewportRef = useRef<HTMLDivElement>(null);
    useImperativeHandle(
      ref,
      () => localViewportRef.current as HTMLDivElement,
      []
    );

    const motionValue = useMotionValue(0);
    const isVertical = orientation === "vertical";

    const { isRefreshing } = useElasticAndRefresh(
      localViewportRef,
      motionValue,
      {
        orientation,
        isEnabled: elasticity || pullToRefresh,
        damping: dampingFactor,
        isRefreshEnabled: pullToRefresh,
        onRefresh,
        pullThreshold,
      }
    );

    const pullProgress = useTransform(motionValue, (v) => (v > 0 ? v : 0));
    const indicatorOpacity = useTransform(
      pullProgress,
      [0, pullThreshold * 0.5],
      [0, 1]
    );

    const lastScrollTop = useRef(0);
    const handleScroll = useCallback(
      (event: React.UIEvent<HTMLDivElement>) => {
        const currentScrollTop = event.currentTarget.scrollTop;
        const scrollDelta = currentScrollTop - lastScrollTop.current;

        // Prevent firing on small jitters or bounce-back
        if (Math.abs(scrollDelta) < 5) return;

        if (scrollDelta > 0) {
          onScrollDown?.();
        } else {
          onScrollUp?.();
        }

        // Update last scroll position, clamping at 0 for iOS bounce.
        lastScrollTop.current = Math.max(0, currentScrollTop);
      },
      [onScrollDown, onScrollUp]
    );

    return (
      <ScrollAreaPrimitive.Root
        className={clsx("relative h-full w-full overflow-hidden!", className)}
        {...props}
      >
        {pullToRefresh && isVertical && (
          <motion.div
            className="pointer-events-none absolute inset-x-0 top-[-40px] z-50 flex justify-center"
            style={{
              y: isRefreshing ? pullThreshold + 40 : pullProgress,
              opacity: isRefreshing ? 1 : indicatorOpacity,
            }}
            transition={{ type: "spring", stiffness: 300, damping: 30 }}
          >
            <div className="flex h-10 w-10 items-center justify-center rounded-full bg-graphite-card shadow-md">
              <RefreshIndicatorComponent
                pullProgress={pullProgress}
                isRefreshing={isRefreshing}
              />
            </div>
          </motion.div>
        )}
        <motion.div
          style={{ [isVertical ? "y" : "x"]: motionValue }}
          className="h-full w-full"
        >
          <ScrollAreaPrimitive.Viewport
            ref={localViewportRef}
            className="h-full w-full rounded-[inherit]"
            style={{ touchAction: isVertical ? "pan-y" : "pan-x" }}
            onScroll={onScrollUp || onScrollDown ? handleScroll : undefined}
          >
            {children}
          </ScrollAreaPrimitive.Viewport>
        </motion.div>
        <ScrollBar
          scrollbarVisibility={scrollbarVisibility}
          orientation="vertical"
        />
        <ScrollBar
          scrollbarVisibility={scrollbarVisibility}
          orientation="horizontal"
        />
        <ScrollAreaPrimitive.Corner />
      </ScrollAreaPrimitive.Root>
    );
  }
);
ElasticScrollAreaRoot.displayName = "ElasticScrollArea";

// --- STYLED SUB-COMPONENTS (MODIFIED) ---
const ScrollBar = forwardRef<
  ElementRef<typeof ScrollAreaPrimitive.Scrollbar>,
  ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Scrollbar> & {
    scrollbarVisibility?: ElasticScrollAreaProps["scrollbarVisibility"];
  }
>(
  (
    {
      className,
      orientation = "vertical",
      scrollbarVisibility = "auto",
      ...props
    },
    ref
  ) => (
    <ScrollAreaPrimitive.Scrollbar
      ref={ref}
      orientation={orientation}
      className={clsx(
        "flex touch-none select-none transition-opacity duration-200 z-[100]",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent p-[1px]",
        orientation === "horizontal" &&
          "h-2.5 border-t border-t-transparent p-[1px]",
        {
          "opacity-100":
            scrollbarVisibility === "always" ||
            scrollbarVisibility === "visible",
          hidden: scrollbarVisibility === "hidden",
          "data-[state=hidden]:opacity-0": scrollbarVisibility === "scroll",
          "opacity-0 data-[state=visible]:opacity-100":
            scrollbarVisibility === "auto",
        },
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.Thumb className="relative flex-1 rounded-full bg-graphite-primary/30" />
    </ScrollAreaPrimitive.Scrollbar>
  )
);
ScrollBar.displayName = ScrollAreaPrimitive.Scrollbar.displayName;

export const ElasticScrollArea = Object.assign(ElasticScrollAreaRoot, {
  ScrollBar,
});
```

**Storybook Stories (`elastic-scroll-area.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  AnimatePresence,
  motion,
  useTransform,
  type MotionValue,
} from "framer-motion";
import { Compass, Home, Library, Menu, Search, Sun } from "lucide-react";
import React, { useRef, useState } from "react";
import { useAppBar } from "../../hooks/useAppBar";
import { AppBar, type AppBarProps } from "../appbar";
import { BottomTabs } from "../bottom-tabs";
import { IconButton } from "../icon-button";
import { Input } from "../input";
import { ShallowRouter, useRouter } from "../shallow-router";
import { Typography } from "../typography";
import { ElasticScrollArea } from "./index";

const meta: Meta<typeof ElasticScrollArea> = {
  title: "Components/ElasticScrollArea",
  component: ElasticScrollArea,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A scroll container that provides a native-like 'rubber band' or elastic overscroll effect, common in modern operating systems like iOS and macOS. It is built on top of Radix UI's accessible Scroll Area primitive and powered by Framer Motion for physics-based animations.",
      },
    },
  },
  argTypes: {
    orientation: {
      control: "select",
      options: ["vertical", "horizontal"],
      description: "The primary scrolling direction.",
    },
    elasticity: {
      control: "boolean",
      description: "Toggles the elastic overscroll effect.",
    },
    dampingFactor: {
      control: { type: "range", min: 0.05, max: 0.5, step: 0.01 },
      description:
        "Controls the resistance of the pull. Lower values are stiffer.",
    },
    scrollbarVisibility: {
      control: "select",
      options: ["auto", "always", "scroll", "hidden", "visible"],
      description: "Controls the visibility of the scrollbar.",
    },
    pullToRefresh: {
      control: "boolean",
      description: "Enables the pull-to-refresh functionality (vertical only).",
    },
    pullThreshold: {
      control: { type: "number", min: 40, max: 200, step: 10 },
      description: "The pixel distance to pull to trigger a refresh.",
    },
    onRefresh: { action: "refreshed" },
    onScrollUp: { action: "scrolled up" },
    onScrollDown: { action: "scrolled down" },
    children: { control: false },
    RefreshIndicatorComponent: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof ElasticScrollArea>;

// Helper component to generate vertical scrollable content
const DummyContent = ({ itemCount = 30 }: { itemCount?: number }) => (
  <main className="p-6">
    <Typography variant="h3">Scroll Me</Typography>
    <Typography variant="muted">
      Use your mouse wheel, trackpad, or touch to scroll. Try scrolling past the
      top or bottom edges.
    </Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2">
      {Array.from({ length: itemCount }).map((_, i) => (
        <div
          key={i}
          className="h-24 rounded-2xl bg-graphite-secondary flex items-center justify-center"
        >
          <Typography variant="small" className="text-graphite-foreground/50">
            Item {i + 1}
          </Typography>
        </div>
      ))}
    </div>
  </main>
);

// Helper component to generate horizontal scrollable content
const DummyHorizontalContent = ({ itemCount = 20 }: { itemCount?: number }) => (
  <div className="p-6 h-full">
    <Typography variant="h3">Scroll Me Horizontally</Typography>
    <Typography variant="muted">
      Use Shift + Mouse Wheel, or swipe horizontally.
    </Typography>
    <div className="mt-4 flex gap-4 h-full">
      {Array.from({ length: itemCount }).map((_, i) => (
        <div
          key={i}
          className="h-32 w-32 flex-shrink-0 rounded-2xl bg-graphite-secondary flex items-center justify-center"
        >
          <Typography variant="small" className="text-graphite-foreground/50">
            Item {i + 1}
          </Typography>
        </div>
      ))}
    </div>
  </div>
);

// A mock async function for the onRefresh prop
const simulateRefresh = () => {
  return new Promise((resolve) => setTimeout(resolve, 2000));
};

// A smart render function to wrap stories in a sized container
const renderVertical = (args: any) => (
  <div className="w-96 h-[600px] rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
    <ElasticScrollArea {...args}>
      <DummyContent />
    </ElasticScrollArea>
  </div>
);

// --- STORIES ---

export const Default: Story = {
  name: "1. Vertical (Default)",
  args: {
    orientation: "vertical",
    elasticity: true,
    dampingFactor: 0.25,
    scrollbarVisibility: "auto",
  },
  render: renderVertical,
};

export const Horizontal: Story = {
  name: "2. Horizontal",
  args: {
    orientation: "horizontal",
    elasticity: true,
    dampingFactor: 0.25,
    scrollbarVisibility: "auto",
  },
  render: (args) => (
    <div className="w-[700px] h-72 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
      <ElasticScrollArea {...args}>
        <DummyHorizontalContent />
      </ElasticScrollArea>
    </div>
  ),
};

export const PullToRefresh: Story = {
  name: "3. With Pull to Refresh (Vertical Only)",
  args: {
    orientation: "vertical",
    elasticity: true,
    pullToRefresh: true,
    onRefresh: simulateRefresh,
    pullThreshold: 80,
  },
  parameters: {
    docs: {
      description: {
        story:
          "Pull-to-refresh is only enabled when `orientation` is `vertical`. When you pull and release, the content snaps back while the indicator remains visible during the loading state.",
      },
    },
  },
  render: renderVertical,
};

// --- Custom Indicator Example ---
const CustomWeatherIndicator = ({
  pullProgress,
  isRefreshing,
}: {
  pullProgress: MotionValue<number>;
  isRefreshing: boolean;
}) => {
  const rotation = useTransform(pullProgress, [0, 150], [0, 360]);
  return (
    <motion.div style={{ rotate: rotation }}>
      <Sun
        className={
          isRefreshing
            ? "h-6 w-6 text-yellow-500 animate-spin"
            : "h-6 w-6 text-yellow-500"
        }
      />
    </motion.div>
  );
};

export const CustomRefreshIndicator: Story = {
  name: "4. Custom Refresh Indicator",
  args: {
    ...PullToRefresh.args,
    pullThreshold: 100,
    RefreshIndicatorComponent: CustomWeatherIndicator,
  },
  parameters: {
    docs: {
      description: {
        story:
          "You can pass a custom component to `RefreshIndicatorComponent` to create unique loading experiences.",
      },
    },
  },
  render: renderVertical,
};

export const ScrollbarVisibility: Story = {
  name: "5. Scrollbar Visibility",
  parameters: {
    docs: {
      description: {
        story:
          "The `scrollbarVisibility` prop controls how the scrollbar is displayed. `auto` shows on hover/scroll, `always`/`visible` keeps it visible, `scroll` only shows during active scrolling, and `hidden` never shows it.",
      },
    },
  },
  render: () => (
    <div className="flex w-full max-w-7xl gap-4 items-start justify-center">
      <div className="flex flex-col items-center gap-2">
        <Typography variant="small" className="font-bold">
          'auto' (default)
        </Typography>
        <div className="w-48 h-96 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
          <ElasticScrollArea scrollbarVisibility="auto">
            <DummyContent itemCount={15} />
          </ElasticScrollArea>
        </div>
      </div>
      <div className="flex flex-col items-center gap-2">
        <Typography variant="small" className="font-bold">
          'visible' / 'always'
        </Typography>
        <div className="w-48 h-96 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
          <ElasticScrollArea scrollbarVisibility="visible">
            <DummyContent itemCount={15} />
          </ElasticScrollArea>
        </div>
      </div>
      <div className="flex flex-col items-center gap-2">
        <Typography variant="small" className="font-bold">
          'scroll'
        </Typography>
        <div className="w-48 h-96 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
          <ElasticScrollArea scrollbarVisibility="scroll">
            <DummyContent itemCount={15} />
          </ElasticScrollArea>
        </div>
      </div>
      <div className="flex flex-col items-center gap-2">
        <Typography variant="small" className="font-bold">
          'hidden'
        </Typography>
        <div className="w-48 h-96 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
          <ElasticScrollArea scrollbarVisibility="hidden">
            <DummyContent itemCount={15} />
          </ElasticScrollArea>
        </div>
      </div>
    </div>
  ),
};

// This helper component calls the useAppBar hook safely *after* its parent has mounted and hydrated the ref.
const ElasticScrollContent = ({
  scrollRef,
  appBarArgs,
}: {
  scrollRef: React.RefObject<HTMLDivElement | null>;
  appBarArgs: AppBarProps;
}) => {
  // By the time this component renders, scrollRef.current is hydrated.
  const { contentPaddingTop } = useAppBar({
    ...appBarArgs,
    scrollContainerRef: scrollRef,
  });

  return (
    <div style={{ paddingTop: contentPaddingTop }}>
      <DummyContent />
    </div>
  );
};

const RenderWithAppBarAndBottomTabs = ({
  elasticScrollArgs,
}: {
  elasticScrollArgs: any;
}) => {
  const { path: activeTab, push: onTabPress } = useRouter();
  const initialTab = "home";
  const [isTabsVisible, setIsTabsVisible] = useState(true);
  const scrollRef = useRef<HTMLDivElement>(null);

  // Define the props for the AppBar in one place
  const appBarArgs: AppBarProps = {
    size: "lg",
    scrollBehavior: "conditionally-sticky",
    appBarColor: "card",
    animatedBehavior: ["shadow"],
    largeHeaderRowHeight: 60,
    startAdornment: (
      <IconButton variant="ghost" aria-label="Menu">
        <Menu />
      </IconButton>
    ),
    children: (
      <Typography variant="h4" className="font-semibold truncate">
        Explore
      </Typography>
    ),
    largeHeaderContent: (
      <Input
        variant="secondary"
        shape="full"
        startAdornment={<Search className="h-5 w-5 text-gray-500" />}
        placeholder="Search..."
      />
    ),
  };

  return (
    <div className="w-96 h-[600px] rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden relative bg-graphite-background">
      {/* AppBar receives the ref but doesn't trigger the hook directly from here */}
      <AppBar {...appBarArgs} scrollContainerRef={scrollRef} />

      <ElasticScrollArea
        {...elasticScrollArgs}
        ref={scrollRef}
        onScrollDown={() => setIsTabsVisible(false)}
        onScrollUp={() => setIsTabsVisible(true)}
      >
        {/* Render the child component that safely calls the hook for padding */}
        <ElasticScrollContent scrollRef={scrollRef} appBarArgs={appBarArgs} />
      </ElasticScrollArea>

      <AnimatePresence>
        {isTabsVisible && (
          <motion.div
            initial={{ y: "100%" }}
            animate={{ y: "0%" }}
            exit={{ y: "100%" }}
            transition={{ type: "spring", stiffness: 400, damping: 40 }}
            className="absolute bottom-0 left-0 right-0"
          >
            <BottomTabs.Navigator
              mode="detached"
              shape="minimal"
              activeTab={
                activeTab === "/" ? initialTab : activeTab.substring(1)
              }
              onTabPress={(tab) => onTabPress(`/${tab}`)}
            >
              <BottomTabs.Screen
                name="home"
                label="Home"
                icon={() => <Home size={24} />}
              />
              <BottomTabs.Screen
                name="browse"
                label="Browse"
                icon={() => <Compass size={24} />}
              />
              <BottomTabs.Screen
                name="library"
                label="Library"
                icon={() => <Library size={24} />}
              />
            </BottomTabs.Navigator>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export const WithAppBarAndBottomTabs: Story = {
  name: "6. With AppBar & BottomTabs",
  args: {
    orientation: "vertical",
    elasticity: true,
    dampingFactor: 0.25,
    scrollbarVisibility: "auto",
  },
  parameters: {
    docs: {
      description: {
        story:
          "Use the `onScrollUp` and `onScrollDown` callbacks to react to scroll direction. This example shows a common mobile pattern: hiding/showing a `BottomTabs` component while a collapsible `AppBar` also reacts to the scroll position of the `ElasticScrollArea`.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter>
      <RenderWithAppBarAndBottomTabs elasticScrollArgs={args} />
    </ShallowRouter>
  ),
};
```


### Component: `fab`

This section contains the source code for the `fab` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\fab\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import {
  AnimatePresence,
  type HTMLMotionProps,
  motion,
  type Transition,
} from "framer-motion";
import React from "react";
import useRipple from "use-ripple-hook";

const fabVariants = cva(
  // Base styles: Removed specific color classes
  "font-semibold focus:outline-none flex transition-shadow duration-200  items-center justify-start relative overflow-hidden group shadow-lg hover:shadow-xl focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
  {
    variants: {
      // --- NEW: Variant property for color schemes ---
      variant: {
        primary: "bg-graphite-primary text-graphite-primaryForeground",
        secondary: "bg-graphite-secondary text-graphite-secondaryForeground",
      },
      size: {
        sm: "h-10",
        md: "h-14",
        lg: "h-16",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      variant: "primary", // Default to the primary style
      size: "md",
      shape: "full",
    },
  }
);

export interface FABProps
  extends Omit<HTMLMotionProps<"button">, "children" | "ref"> {
  variant?: "primary" | "secondary";
  size?: "sm" | "md" | "lg";
  shape?: "full" | "minimal" | "sharp";
  icon: React.ReactNode;
  isExtended?: boolean;
  children?: React.ReactNode;
}

const transition = {
  type: "spring",
  stiffness: 500,
  damping: 40,
  mass: 1,
} as Transition;

export const FAB = React.forwardRef<HTMLButtonElement, FABProps>(
  (
    {
      className,
      variant, // Destructure the new variant prop
      size,
      shape,
      children,
      disabled,
      icon,
      isExtended,
      ...props
    },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);
    const rippleRef = localRef as React.RefObject<HTMLElement>;

    // Adjust ripple color based on variant
    const rippleColor =
      variant === "primary" ? "rgba(255, 255, 255, 0.3)" : "rgba(0, 0, 0, 0.1)";

    const [, event] = useRipple({
      ref: rippleRef,
      color: rippleColor,
      duration: 400,
      disabled: disabled,
    });

    const fabSize = fabSizeMap[size || "md"];

    return (
      <motion.button
        initial={{ scale: 0, opacity: 0 }}
        animate={{
          scale: 1,
          opacity: 1,
          paddingLeft: isExtended ? fabSize / 2 : fabSize / 4,
          paddingRight: isExtended ? fabSize / 2 : fabSize / 4,
        }}
        transition={transition}
        className={clsx(
          fabVariants({ variant, size, shape, className }), // Pass variant to CVA
          !isExtended && "justify-center"
        )}
        ref={localRef}
        onPointerDown={event}
        disabled={disabled}
        {...props}
      >
        <motion.span layout="position" className="flex-shrink-0 z-10">
          {icon}
        </motion.span>

        <AnimatePresence>
          {isExtended && (
            <motion.div
              initial={{ width: 0, opacity: 0 }}
              animate={{ width: "auto", opacity: 1, marginLeft: "0.75rem" }}
              exit={{ width: 0, opacity: 0, marginLeft: 0 }}
              transition={transition}
              className="whitespace-nowrap overflow-hidden"
            >
              {children}
            </motion.div>
          )}
        </AnimatePresence>
      </motion.button>
    );
  }
);

const fabSizeMap: Record<string, number> = {
  sm: 40,
  md: 56,
  lg: 64,
};

FAB.displayName = "FAB";
```

**Storybook Stories (`FAB.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { CreditCard, LogOut, Plus, Settings, User } from "lucide-react";
import { useState } from "react";
import { Button } from "../button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuTrigger,
} from "../dropdown-menu"; // Assuming this is the correct path
import { FAB } from "./index";

const meta: Meta<typeof FAB> = {
  title: "Components/Buttons/FAB",
  component: FAB,
  tags: ["autodocs"],
  argTypes: {
    // --- NEW: Added variant control ---
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    isExtended: { control: "boolean" },
    disabled: { control: "boolean" },
    onClick: { action: "clicked" },
  },
  args: {
    icon: <Plus className="h-7 w-7" />,
    children: "Create New",
    "aria-label": "Create New Item",
    variant: "primary", // Set default variant for controls
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    isExtended: false,
    shape: "full",
  },
};

// --- NEW STORY to showcase variants ---
export const AllVariants: Story = {
  name: "All Variants",
  render: (args) => (
    <div className="flex flex-col items-start space-y-6">
      <p className="font-semibold">Primary</p>
      <div className="flex items-center gap-4">
        <FAB {...args} variant="primary" isExtended={false} />
        <FAB {...args} variant="primary" isExtended={true} />
      </div>
      <p className="font-semibold">Secondary</p>
      <div className="flex items-center gap-4">
        <FAB {...args} variant="secondary" isExtended={false} />
        <FAB {...args} variant="secondary" isExtended={true} />
      </div>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: (args) => (
    <div className="flex flex-col items-start space-y-6">
      <p className="font-semibold">Shape: Full</p>
      <div className="flex items-center gap-4">
        <FAB {...args} shape="full" isExtended={false} />
        <FAB {...args} shape="full" isExtended={true} />
      </div>
      <p className="font-semibold">Shape: Minimal</p>
      <div className="flex items-center gap-4">
        <FAB {...args} shape="minimal" isExtended={false} />
        <FAB {...args} shape="minimal" isExtended={true} />
      </div>
      <p className="font-semibold">Shape: Sharp</p>
      <div className="flex items-center gap-4">
        <FAB {...args} shape="sharp" isExtended={false} />
        <FAB {...args} shape="sharp" isExtended={true} />
      </div>
    </div>
  ),
};

export const InteractiveAnimation: Story = {
  name: "Interactive Animation",
  parameters: {
    docs: {
      description: {
        story:
          "This story uses Framer Motion's layout animations for a perfectly smooth transition between extended and collapsed states.",
      },
    },
  },
  render: (args) => {
    const [isExtended, setIsExtended] = useState(false);

    return (
      <div className="space-y-4 flex flex-col">
        <p>Click the button below to see the smooth FAB animation.</p>
        <Button
          variant="secondary"
          size="sm"
          onClick={() => setIsExtended((prev) => !prev)}
        >
          {isExtended ? "Collapse FAB" : "Extend FAB"}
        </Button>
        <div>
          <FAB {...args} isExtended={isExtended} />
        </div>
      </div>
    );
  },
};

export const WithDropdownMenu: Story = {
  name: "With Dropdown Menu",
  parameters: {
    layout: "centered",
    docs: {
      description: {
        story:
          "A FAB can be used as a trigger for a Dropdown Menu. Wrap the FAB with the `DropdownMenuTrigger` component and pass the `asChild` prop.",
      },
    },
  },
  render: (args) => (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        {/* Render the FAB as the trigger, using args from Storybook controls */}
        <FAB {...args} isExtended={false} />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuItem>
          <User className="mr-2 h-4 w-4" />
          <span>Profile</span>
          <DropdownMenuShortcut>⇧⌘P</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <CreditCard className="mr-2 h-4 w-4" />
          <span>Billing</span>
          <DropdownMenuShortcut>⌘B</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <Settings className="mr-2 h-4 w-4" />
          <span>Settings</span>
          <DropdownMenuShortcut>⌘S</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
          <DropdownMenuShortcut>⇧⌘Q</DropdownMenuShortcut>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};
```


### Component: `icon-button`

This section contains the source code for the `icon-button` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\icon-button\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import { AnimatePresence, motion } from "framer-motion";
import { Loader2 } from "lucide-react"; // Import Loader from lucide-react
import React from "react";
import useRipple from "use-ripple-hook";

export const iconButtonVariants = cva(
  "font-semibold focus:outline-none min-w-max transition-all duration-300 ease-in-out flex items-center justify-center relative overflow-hidden p-0",
  {
    variants: {
      variant: {
        primary:
          "bg-graphite-primary disabled:bg-graphite-primary/70 text-graphite-primaryForeground hover:opacity-90 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        secondary:
          "bg-graphite-secondary disabled:bg-graphite-secondary/70 text-graphite-secondaryForeground hover:bg-graphite-secondary/80  focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        destructive:
          "bg-red-500 text-graphite-primaryForeground disabled:bg-red-500/70 hover:bg-red-600/80 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        ghost:
          "bg-transparent disabled:opacity-70 text-graphite-foreground hover:bg-graphite-secondary focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        link: "bg-transparent disabled:opacity-70 text-graphite-primary hover:text-graphite-primary hover:underline !p-1 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
      },
      size: {
        xs: "h-8 w-8",
        sm: "h-10 w-10",
        md: "h-12 w-12",
        lg: "h-14 w-14",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
      isLoading: {
        true: "cursor-wait",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      shape: "full",
    },
  }
);

export interface IconButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: "primary" | "secondary" | "destructive" | "ghost" | "link";
  size?: "xs" | "sm" | "md" | "lg";
  shape?: "full" | "minimal" | "sharp";
  isLoading?: boolean;
}

export const IconButton = React.forwardRef<HTMLButtonElement, IconButtonProps>(
  (
    {
      className,
      variant,
      size,
      shape,
      children,
      disabled,
      isLoading,
      ...props
    },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);
    const rippleColor =
      variant === "primary" || variant === "destructive"
        ? "rgba(255, 255, 255, 0.4)"
        : "rgba(0, 0, 0, 0.1)";
    const rippleRef = localRef as React.RefObject<HTMLElement>;
    const [, event] = useRipple({
      ref: rippleRef,
      color: rippleColor,
      duration: 400,
      disabled: disabled || isLoading,
    });

    const loaderSizeMap = {
      xs: "h-4 w-4",
      sm: "h-5 w-5",
      md: "h-6 w-6",
      lg: "h-8 w-8",
    };

    return (
      <button
        className={iconButtonVariants({
          variant,
          size,
          shape,
          className,
          isLoading,
        })}
        ref={localRef}
        onPointerDown={(e) => {
          e.stopPropagation();
          event(e);
        }}
        disabled={disabled || isLoading}
        {...props}
      >
        <AnimatePresence mode="wait" initial={false}>
          {isLoading ? (
            <motion.div
              key="spinner"
              initial={{ opacity: 0, scale: 0.5 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.5 }}
              transition={{ duration: 0.2 }}
            >
              {/* Use lucide-react Loader with animate-spin */}
              <Loader2
                className={`animate-spin ${loaderSizeMap[size || "md"]}`}
              />
            </motion.div>
          ) : (
            <motion.span
              key="content"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
              className="relative z-10"
            >
              {children}
            </motion.span>
          )}
        </AnimatePresence>
      </button>
    );
  }
);

IconButton.displayName = "IconButton";
```

**Storybook Stories (`Icon-button.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Plus } from "lucide-react";
import { useState } from "react";
import { IconButton } from "./index";

const meta: Meta<typeof IconButton> = {
  title: "Components/Buttons/IconButton",
  component: IconButton,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "destructive", "ghost", "link"],
    },
    size: {
      control: "select",
      options: ["xs", "sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "The border radius of the icon button.",
    },
    isLoading: { control: "boolean" }, // Added isLoading control
    disabled: { control: "boolean" },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    variant: "primary",
    size: "md",
    shape: "full",
    children: <Plus className="h-6 w-6" />,
    "aria-label": "Add new item",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton variant="primary" size="md" aria-label="Primary">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="secondary" size="md" aria-label="Secondary">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="destructive" size="md" aria-label="Destructive">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="ghost" size="md" aria-label="Ghost">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="link" size="md" aria-label="Link">
        <Plus className="h-6 w-6" />
      </IconButton>
    </div>
  ),
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton variant="primary" size="lg" aria-label="Large">
        <Plus className="h-8 w-8" />
      </IconButton>
      <IconButton variant="primary" size="md" aria-label="Medium">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="primary" size="sm" aria-label="Small">
        <Plus className="h-5 w-5" />
      </IconButton>
      <IconButton variant="primary" size="xs" aria-label="Extra Small">
        <Plus className="h-4 w-4" />
      </IconButton>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton
        variant="primary"
        size="md"
        shape="full"
        aria-label="Full Shape"
      >
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton
        variant="primary"
        size="md"
        shape="minimal"
        aria-label="Minimal Shape"
      >
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton
        variant="primary"
        size="md"
        shape="sharp"
        aria-label="Sharp Shape"
      >
        <Plus className="h-6 w-6" />
      </IconButton>
    </div>
  ),
};

// --- NEW STORIES FOR LOADING STATE ---

export const Loading: Story = {
  name: "Loading State",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton variant="primary" size="md" aria-label="Loading" isLoading>
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="secondary" size="md" aria-label="Loading" isLoading>
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="ghost" size="md" aria-label="Loading" isLoading>
        <Plus className="h-6 w-6" />
      </IconButton>
    </div>
  ),
};

export const InteractiveLoading: Story = {
  name: "Interactive Loading",
  render: () => {
    const [isLoading, setIsLoading] = useState(false);
    const handleClick = () => {
      setIsLoading(true);
      setTimeout(() => {
        setIsLoading(false);
      }, 2000);
    };
    return (
      <IconButton
        variant="primary"
        size="lg"
        aria-label="Submit"
        isLoading={isLoading}
        onClick={handleClick}
      >
        <Plus className="h-8 w-8" />
      </IconButton>
    );
  },
};
```


### Component: `input`

This section contains the source code for the `input` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\input\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import React from "react";

export const inputWrapperVariants = cva(
  "flex items-center transition-all duration-200 w-full",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card border-2 px-4",
        secondary: "bg-graphite-secondary border-2 px-4",
        // MODIFIED: Truly minimal variant with no borders or padding on the wrapper.
        minimal: "bg-transparent p-0",
      },
      shape: {
        full: "rounded-4xl",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
      size: {
        sm: "h-10 text-sm",
        md: "h-12 text-base",
        lg: "h-14 text-lg",
      },
      isErrored: { true: "" },
      isFocused: { true: "" },
      disabled: {
        true: "bg-graphite-secondary opacity-50 cursor-not-allowed",
      },
    },
    compoundVariants: [
      // Primary states
      {
        variant: "primary",
        isErrored: false,
        isFocused: false,
        className: "border-graphite-border",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "primary",
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
      // Secondary states
      {
        variant: "secondary",
        isErrored: false,
        isFocused: false,
        className: "border-transparent",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "secondary",
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
      // MODIFIED: Remove all focus/error border effects for the minimal variant.
      // Also ensure it ignores the 'shape' prop by forcing no rounding.
      {
        variant: "minimal",
        className: "rounded-none border-0",
      },
    ],
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
      size: "md",
    },
  }
);

// FIX #2: Use VariantProps to remove the unused import warning and keep types in sync.
export interface InputProps
  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "size"> {
  variant?: "primary" | "secondary" | "minimal";
  shape?: "full" | "minimal" | "sharp";
  size?: "sm" | "md" | "lg";
  label?: string;
  startAdornment?: React.ReactNode;
  endAdornment?: React.ReactNode;
  error?: string;
  wrapperClassName?: string;
}

export const Input = React.forwardRef<HTMLInputElement, InputProps>(
  (
    {
      className,
      id,
      label,
      startAdornment,
      endAdornment,
      error,
      disabled,
      shape,
      size,
      wrapperClassName,
      variant,
      onFocus,
      onBlur,
      onKeyDown,
      onPaste,
      type,
      ...props
    },
    ref
  ) => {
    const uniqueId = React.useId();
    const inputId = id || uniqueId;
    const hasError = !!error;
    const [isFocused, setIsFocused] = React.useState(false);

    const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
      setIsFocused(true);
      onFocus?.(e);
    };

    const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
      setIsFocused(false);
      onBlur?.(e);
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (type === "number") {
        // FIX #1: Corrected the syntax error here.
        const { value } = e.currentTarget;
        const allowedKeys = [
          "Backspace",
          "Delete",
          "Tab",
          "Escape",
          "Enter",
          "ArrowLeft",
          "ArrowRight",
          "Home",
          "End",
        ];
        if (e.key === "." && !value.includes(".")) {
          return;
        }
        if (allowedKeys.includes(e.key)) {
          return;
        }
        if (e.ctrlKey || e.metaKey) {
          return;
        }
        if (!/^[0-9]$/.test(e.key)) {
          e.preventDefault();
        }
      }
      onKeyDown?.(e);
    };

    const handlePaste = (e: React.ClipboardEvent<HTMLInputElement>) => {
      if (type === "number") {
        const pastedText = e.clipboardData.getData("text");
        if (!/^\d*\.?\d*$/.test(pastedText)) {
          e.preventDefault();
        }
      }
      onPaste?.(e);
    };

    return (
      <div className="w-full flex flex-col gap-2">
        {label && (
          <label
            htmlFor={inputId}
            className="block text-sm font-medium text-graphite-primary"
          >
            {label}
          </label>
        )}
        <div
          className={inputWrapperVariants({
            variant,
            shape,
            size,
            isErrored: hasError,
            isFocused,
            disabled,
            className: wrapperClassName,
          })}
        >
          {startAdornment && (
            <div className="flex items-center mr-2">{startAdornment}</div>
          )}
          <input
            id={inputId}
            ref={ref}
            disabled={disabled}
            type={type}
            onFocus={handleFocus}
            onBlur={handleBlur}
            onKeyDown={handleKeyDown}
            onPaste={handlePaste}
            className={clsx(
              "w-full flex-1 bg-transparent focus:outline-none",
              "disabled:cursor-not-allowed",
              variant === "secondary" && "placeholder:text-gray-500",
              className
            )}
            {...props}
          />
          {endAdornment && (
            <div className="flex items-center ml-2">{endAdornment}</div>
          )}
        </div>
        {hasError && <p className="mt-2 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);

Input.displayName = "Input";
```

**Storybook Stories (`Input.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Eye, EyeOff, Mail, Search } from "lucide-react";
import { useState } from "react";
import { Input } from "./index";
import { Card } from "../card";
import { Typography } from "../typography";

const meta: Meta<typeof Input> = {
  title: "Components/Forms & Inputs/Input",
  component: Input,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "minimal"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    label: { control: "text" },
    placeholder: { control: "text" },
    disabled: { control: "boolean" },
    error: { control: "text" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
    size: "md", // Default size
    label: "Email Address",
    placeholder: "you@example.com",
    startAdornment: <Mail className="h-4 w-4" />,
  },
};

export const CompositionWithMinimal: Story = {
  name: "Composition with Minimal Variant",
  render: () => (
    <div className="flex flex-col gap-8 max-w-sm">
      <Typography variant="h4">Custom Search Bar</Typography>
      <Card variant="secondary" shape="full" padding="none">
        <Input
          variant="minimal"
          size="md"
          placeholder="Search..."
          startAdornment={<Search className="h-5 w-5 ml-4" />}
          wrapperClassName="h-12"
        />
      </Card>
      <Typography variant="h4">Error State</Typography>
      <Card variant="primary" shape="minimal" padding="sm" isSelected>
        <Input
          variant="minimal"
          size="md"
          placeholder="Search..."
          startAdornment={<Search className="h-5 w-5 mr-2" />}
          error="Search term is required."
          wrapperClassName="h-12"
        />
      </Card>
    </div>
  ),
  parameters: {
    docs: {
      description: {
        story:
          "The `minimal` variant is completely unstyled, making it perfect for composing custom input components. Here, it's placed inside a `Card` to create a search bar. The card provides the background and border, while the input only provides the text functionality.",
      },
    },
  },
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-col gap-6 max-w-sm">
      <Input
        size="sm"
        label="Small"
        placeholder="Small input (sm)"
        startAdornment={<Search className="h-4 w-4" />}
      />
      <Input
        size="md"
        label="Medium (Default)"
        placeholder="Medium input (md)"
        startAdornment={<Search className="h-5 w-5" />}
      />
      <Input
        size="lg"
        label="Large"
        placeholder="Large input (lg)"
        startAdornment={<Search className="h-6 w-6" />}
      />
    </div>
  ),
};

export const AllVariantsAndShapes: Story = {
  name: "All Variants & Shapes",
  render: () => (
    <div className="flex flex-col gap-8 max-w-sm">
      <div>
        <h3 className="font-bold mb-4">Primary Variant</h3>
        <div className="flex flex-col gap-4">
          <Input variant="primary" shape="full" placeholder="Full Shape" />
          <Input
            variant="primary"
            shape="minimal"
            placeholder="Minimal Shape"
          />
          <Input variant="primary" shape="sharp" placeholder="Sharp Shape" />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary Variant</h3>
        <div className="flex flex-col gap-4">
          <Input variant="secondary" shape="full" placeholder="Full Shape" />
          <Input
            variant="secondary"
            shape="minimal"
            placeholder="Minimal Shape"
          />
          <Input variant="secondary" shape="sharp" placeholder="Sharp Shape" />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Minimal Variant (Standalone)</h3>
        <div className="flex flex-col gap-4 p-4 bg-graphite-secondary rounded-lg">
          <Input variant="minimal" placeholder="No background or border" />
        </div>
      </div>
    </div>
  ),
};

export const AllStates: Story = {
  name: "All States",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl">
      <div>
        <h3 className="font-bold mb-4">Primary States</h3>
        <div className="flex flex-col gap-4">
          <Input
            variant="primary"
            label="Default"
            placeholder="Enter text..."
          />
          <Input
            variant="primary"
            label="With Value"
            defaultValue="Some text"
          />
          <Input
            variant="primary"
            label="Focused"
            placeholder="This input is focused"
            autoFocus
          />
          <Input
            variant="primary"
            label="Error State"
            defaultValue="invalid-email@"
            error="Please enter a valid email address."
          />
          <Input
            variant="primary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary States</h3>
        <div className="flex flex-col gap-4">
          <Input
            variant="secondary"
            label="Default"
            placeholder="Enter text..."
          />
          <Input
            variant="secondary"
            label="With Value"
            defaultValue="Some text"
          />
          <Input
            variant="secondary"
            label="Focused"
            placeholder="This input is focused"
            autoFocus
          />
          <Input
            variant="secondary"
            label="Error State"
            defaultValue="invalid-email@"
            error="Please enter a valid email address."
          />
          <Input
            variant="secondary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
    </div>
  ),
};

export const WithAdornments: Story = {
  name: "With Adornments",
  render: () => (
    <div className="space-y-4 max-w-sm">
      <Input
        label="Search"
        placeholder="Search for anything..."
        startAdornment={<Search className="h-5 w-5" />}
      />
      <Input
        variant="secondary"
        label="Website"
        startAdornment={<span className="text-gray-400 text-sm">https://</span>}
        endAdornment={<span className="text-gray-400 text-sm">.com</span>}
        defaultValue="chesai"
      />
    </div>
  ),
};

export const NumberInput: Story = {
  name: "Number Input",
  args: {
    label: "Age",
    placeholder: "Enter numbers only",
    type: "number",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `type='number'`, this input prevents non-numeric characters from being typed or pasted.",
      },
    },
  },
};

export const PasswordInput: Story = {
  name: "Password Input Example",
  render: () => {
    const [isVisible, setIsVisible] = useState(false);
    return (
      <div className="max-w-sm">
        <Input
          label="Password"
          type={isVisible ? "text" : "password"}
          placeholder="Enter your password"
          endAdornment={
            <button
              type="button"
              onClick={() => setIsVisible(!isVisible)}
              aria-label={isVisible ? "Hide password" : "Show password"}
              className="p-1 hover:text-gray-600"
            >
              {isVisible ? (
                <EyeOff className="h-5 w-5" />
              ) : (
                <Eye className="h-5 w-5" />
              )}
            </button>
          }
        />
      </div>
    );
  },
};
```


### Component: `item`

This section contains the source code for the `item` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\item\index.tsx`)**
```tsx
"use client";

import { Slot } from "@radix-ui/react-slot";
import { useLongPress } from "@uidotdev/usehooks";
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import * as React from "react";
import useRipple from "use-ripple-hook";

// --- Context for Item Configuration ---
interface ItemContextProps {
  variant: "primary" | "secondary" | "ghost";
  size: "sm" | "md" | "lg";
  direction: "horizontal" | "vertical";
}

const ItemContext = React.createContext<ItemContextProps>({
  variant: "primary",
  size: "md",
  direction: "horizontal",
});

const useItemContext = () => React.useContext(ItemContext);

// --- CVA Variants ---
const itemVariants = cva(
  "group/item relative flex flex-wrap items-center border text-sm outline-none transition-colors duration-150 focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2 overflow-hidden",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card border-graphite-border",
        secondary: "bg-graphite-secondary border-transparent",
        ghost:
          "bg-transparent border-transparent hover:bg-graphite-secondary/60",
      },
      size: {
        sm: "gap-3",
        md: "gap-4",
        lg: "gap-4",
      },
      padding: {
        none: "p-0",
        sm: "p-3",
        md: "p-4",
        lg: "p-5",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
      direction: {
        horizontal: "flex-row",
        vertical: "flex-col justify-center text-center",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      padding: "md",
      shape: "minimal",
      direction: "horizontal",
    },
  }
);

const itemMediaVariants = cva(
  "flex shrink-0 items-center justify-center gap-2 [&_svg]:pointer-events-none",
  {
    variants: {
      variant: {
        default: "",
        icon: "bg-graphite-secondary border border-graphite-border [&_svg:not([class*='size-'])]:text-graphite-foreground/80",
        avatar: "overflow-hidden",
      },
      size: {
        sm: "size-8 rounded-lg [&_svg:not([class*='size-'])]:size-4",
        md: "size-10 rounded-lg [&_svg:not([class*='size-'])]:size-5",
        lg: "size-12 rounded-xl [&_svg:not([class*='size-'])]:size-6",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "md",
      shape: "minimal",
    },
  }
);

// --- Compound Components ---

const ItemGroup = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    role="list"
    data-slot="item-group"
    className={clsx("group/item-group flex flex-col gap-2", className)}
    {...props}
  />
));
ItemGroup.displayName = "ItemGroup";

const ItemSeparator = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-slot="item-separator"
    className={clsx("h-px w-full bg-graphite-border", className)}
    {...props}
  />
));
ItemSeparator.displayName = "ItemSeparator";

const Item = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & {
    variant?: "primary" | "secondary" | "ghost";
    size?: "sm" | "md" | "lg";
    padding?: "none" | "sm" | "md" | "lg";
    shape?: "full" | "minimal" | "sharp";
    direction?: "horizontal" | "vertical";
    asChild?: boolean;
    disabled?: boolean;
    /** If true, the ripple effect on click will be disabled. */
    disableRipple?: boolean;
    /** Callback fired when the item is pressed for 500ms. */
    onLongPress?: (
      event:
        | React.PointerEvent<HTMLDivElement>
        | React.MouseEvent<HTMLDivElement>
    ) => void;
  }
>(
  (
    {
      className,
      variant = "primary",
      size = "md",
      shape = "minimal",
      direction = "horizontal",
      padding = "md",
      asChild = false,
      disabled,
      disableRipple = false,
      onLongPress,
      onPointerDown,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "div";

    const localRef = React.useRef<HTMLDivElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLDivElement);

    const [, event] = useRipple({
      ref: localRef,
      color: "rgba(0, 0, 0, 0.1)",
      duration: 400,
      disabled: disabled || disableRipple,
    });

    // --- NEW: Long Press Logic ---
    // @ts-ignore
    const longPressBindings = useLongPress(onLongPress || null);

    // Combine event handlers: onLongPress bindings, ripple effect, and user's onPointerDown
    const handlePointerDown = (e: React.PointerEvent<HTMLDivElement>) => {
      // Conditionally trigger the long press hook's pointer down handler
      if (
        onLongPress &&
        // @ts-ignore
        typeof longPressBindings.onPointerDown === "function"
      ) {
        // @ts-ignore
        longPressBindings.onPointerDown(e);
      }
      // Trigger the ripple effect
      event(e);
      // Trigger the user's custom onPointerDown handler
      onPointerDown?.(e);
    };

    // Construct the final props, merging our event handlers with the long press ones
    const finalProps = {
      ...props,
      ...(onLongPress ? longPressBindings : {}), // Spread all handlers from the hook
      onPointerDown: handlePointerDown, // Override with our combined handler
    };

    return (
      <ItemContext.Provider value={{ variant, size, direction }}>
        <Comp
          ref={localRef}
          data-slot="item"
          // @ts-ignore
          disabled={disabled}
          className={clsx(
            itemVariants({
              variant,
              size,
              shape,
              direction,
              padding,
              className,
            }),
            disabled && "opacity-50 cursor-not-allowed"
          )}
          {...finalProps}
        />
      </ItemContext.Provider>
    );
  }
);
Item.displayName = "Item";

const ItemMedia = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & {
    variant?: "default" | "icon" | "avatar";
    shape?: "full" | "minimal" | "sharp";
  }
>(({ className, variant, shape = "minimal", ...props }, ref) => {
  const { size: contextSize, direction } = useItemContext();
  return (
    <div
      ref={ref}
      data-slot="item-media"
      className={clsx(
        itemMediaVariants({
          variant,
          size: contextSize,
          shape,
          className,
        }),
        direction === "horizontal" ? "mb-auto" : "mb-2"
      )}
      {...props}
    />
  );
});
ItemMedia.displayName = "ItemMedia";

const ItemContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { direction } = useItemContext();
  return (
    <div
      ref={ref}
      data-slot="item-content"
      className={clsx(
        "flex flex-1 flex-col gap-0.5 min-w-0",
        direction === "vertical" && "items-center",
        className
      )}
      {...props}
    />
  );
});
ItemContent.displayName = "ItemContent";

const ItemTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { direction } = useItemContext();
  return (
    <div
      ref={ref}
      data-slot="item-title"
      className={clsx(
        "flex w-fit items-center gap-2 text-base font-semibold leading-snug truncate",
        direction === "vertical" && "justify-center",
        className
      )}
      {...props}
    />
  );
});
ItemTitle.displayName = "ItemTitle";

const ItemDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    data-slot="item-description"
    className={clsx(
      "text-graphite-foreground/70 line-clamp-2 text-sm font-normal leading-normal",
      className
    )}
    {...props}
  />
));
ItemDescription.displayName = "ItemDescription";

const ItemActions = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { direction } = useItemContext();
  return (
    <div
      ref={ref}
      data-slot="item-actions"
      className={clsx(
        "flex items-center gap-2",
        direction === "horizontal" ? "ml-auto pl-4" : "mt-2",
        className
      )}
      {...props}
    />
  );
});
ItemActions.displayName = "ItemActions";

const ItemHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-slot="item-header"
    className={clsx(
      "flex basis-full items-center justify-between gap-2",
      className
    )}
    {...props}
  />
));
ItemHeader.displayName = "ItemHeader";

const ItemFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-slot="item-footer"
    className={clsx(
      "flex basis-full items-center justify-between gap-2 mt-2",
      className
    )}
    {...props}
  />
));
ItemFooter.displayName = "ItemFooter";

export {
  Item,
  ItemActions,
  ItemContent,
  ItemDescription,
  ItemFooter,
  ItemGroup,
  ItemHeader,
  ItemMedia,
  ItemSeparator,
  ItemTitle,
};
```

**Storybook Stories (`Item.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Bell,
  ChevronRight,
  File,
  Lock,
  MoreVertical,
  Palette,
  Star,
} from "lucide-react";
import React, { useState } from "react";
import { Avatar } from "../avatar";
import { Badge } from "../badge";
import { Checkbox } from "../checkbox";
import { IconButton } from "../icon-button";
import { Switch } from "../switch";
import { Typography } from "../typography";
import {
  Item,
  ItemActions,
  ItemContent,
  ItemDescription,
  ItemFooter,
  ItemGroup,
  ItemHeader,
  ItemMedia,
  ItemSeparator,
  ItemTitle,
} from "./index";

const meta: Meta<typeof Item> = {
  title: "Components/Data/Item",
  component: Item,
  subcomponents: {
    ItemGroup,
    ItemSeparator,
    ItemMedia,
    ItemContent,
    ItemTitle,
    ItemDescription,
    ItemActions,
    ItemHeader,
    ItemFooter,
  },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A versatile compound component for building list items, profiles, notifications, and more complex layouts. Items now have a subtle, fast ripple effect on click.",
      },
    },
  },
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "ghost"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    direction: {
      control: "select",
      options: ["horizontal", "vertical"],
    },
    padding: {
      control: "select",
      options: ["none", "sm", "md", "lg"],
    },
    asChild: { control: "boolean" },
    disabled: { control: "boolean" },
    disableRipple: { control: "boolean" },
    onLongPress: { action: "longPressed" },
  },
};

export default meta;
type Story = StoryObj<typeof Item>;

export const Default: Story = {
  name: "1. Default",
  args: {
    variant: "primary",
    size: "md",
    shape: "minimal",
    direction: "horizontal",
  },
  render: (args) => (
    <div className="w-96">
      <Item {...args}>
        <ItemMedia variant="icon">
          <File />
        </ItemMedia>
        <ItemContent>
          <ItemTitle>Annual Report</ItemTitle>
          <ItemDescription>
            Finalized version of the 2023 report.
          </ItemDescription>
        </ItemContent>
        <ItemActions>
          <IconButton variant="ghost" size="sm" aria-label="More options">
            <MoreVertical size={16} />
          </IconButton>
        </ItemActions>
      </Item>
    </div>
  ),
};

export const AllVariants: Story = {
  name: "2. All Variants",
  render: () => (
    <div className="w-96">
      <ItemGroup>
        <Item variant="primary" onClick={() => {}}>
          <ItemContent>
            <ItemTitle>Primary (Click for Ripple)</ItemTitle>
          </ItemContent>
        </Item>
        <Item variant="secondary" onClick={() => {}}>
          <ItemContent>
            <ItemTitle>Secondary</ItemTitle>
          </ItemContent>
        </Item>
        <Item variant="ghost" onClick={() => {}}>
          <ItemContent>
            <ItemTitle>Ghost</ItemTitle>
          </ItemContent>
        </Item>
      </ItemGroup>
    </div>
  ),
};

export const AllSizes: Story = {
  name: "3. All Sizes",
  render: () => (
    <div className="w-96">
      <ItemGroup>
        <Item size="sm">
          <ItemMedia variant="icon">
            <Star />
          </ItemMedia>
          <ItemContent>
            <ItemTitle>Small Item</ItemTitle>
          </ItemContent>
        </Item>
        <Item size="md">
          <ItemMedia variant="icon">
            <Star />
          </ItemMedia>
          <ItemContent>
            <ItemTitle>Medium Item (Default)</ItemTitle>
          </ItemContent>
        </Item>
        <Item size="lg">
          <ItemMedia variant="icon">
            <Star />
          </ItemMedia>
          <ItemContent>
            <ItemTitle>Large Item</ItemTitle>
          </ItemContent>
        </Item>
      </ItemGroup>
    </div>
  ),
};

export const VerticalProductCard: Story = {
  name: "4. Vertical (Product Card Style)",
  args: {
    direction: "vertical",
    shape: "minimal",
    variant: "primary",
    padding: "none",
  },
  render: (args) => (
    <div className="flex items-start gap-4">
      <Item
        {...args}
        className="w-60 text-left cursor-pointer"
        onClick={() => alert("Product card clicked!")}
      >
        <ItemMedia className="!mb-0 !p-0 !rounded-t-xl !rounded-b-none overflow-hidden w-full h-[150px]">
          <img
            src="https://images.unsplash.com/photo-1588421357574-87938a86fa28?q=80&w=600&auto=format&fit=crop"
            alt="Abstract dark texture"
            className="w-full h-40 object-cover"
          />
        </ItemMedia>
        <ItemContent className="p-4 w-full !items-start">
          <ItemTitle>v0-1.5-sm</ItemTitle>
          <ItemDescription>Everyday tasks and UI generation.</ItemDescription>
        </ItemContent>
      </Item>
    </div>
  ),
};

export const AsLink: Story = {
  name: "5. Polymorphic (as link)",
  parameters: {
    docs: {
      description: {
        story:
          "Using `asChild` prop, the `Item` component can wrap an anchor tag to become a fully clickable link, while maintaining all styling and layout.",
      },
    },
  },
  render: () => (
    <div className="w-96">
      <Item asChild variant="ghost" className="cursor-pointer">
        <a href="#" onClick={(e) => e.preventDefault()}>
          <ItemMedia variant="icon">
            <File />
          </ItemMedia>
          <ItemContent>
            <ItemTitle>Project Proposal</ItemTitle>
            <ItemDescription>Click to view the document.</ItemDescription>
          </ItemContent>
          <ItemActions>
            <ChevronRight size={20} className="text-graphite-foreground/50" />
          </ItemActions>
        </a>
      </Item>
    </div>
  ),
};

export const RippleControl: Story = {
  name: "6. Ripple Control",
  parameters: {
    docs: {
      description: {
        story:
          "You can explicitly disable the ripple effect on an item by setting `disableRipple={true}`.",
      },
    },
  },
  render: () => (
    <div className="w-96">
      <ItemGroup>
        <Item onClick={() => {}} className="cursor-pointer">
          <ItemMedia variant="icon">
            <Star />
          </ItemMedia>
          <ItemContent>
            <ItemTitle>Ripple Enabled (Default)</ItemTitle>
            <ItemDescription>Click me to see the effect.</ItemDescription>
          </ItemContent>
        </Item>
        <Item onClick={() => {}} disableRipple className="cursor-pointer">
          <ItemMedia variant="icon">
            <Star />
          </ItemMedia>
          <ItemContent>
            <ItemTitle>Ripple Disabled</ItemTitle>
            <ItemDescription>
              This item will not have a ripple effect.
            </ItemDescription>
          </ItemContent>
        </Item>
      </ItemGroup>
    </div>
  ),
};

export const WithLongPress: Story = {
  name: "7. With Long Press",
  parameters: {
    docs: {
      description: {
        story:
          "The `onLongPress` prop allows you to trigger an action when an item is pressed for 500ms. This is particularly useful for context menus on touch devices.",
      },
    },
  },
  render: (args) => (
    <div className="w-96">
      <ItemGroup>
        <Item
          onLongPress={() => {
            alert("Long press triggered!");
          }}
          onClick={() => alert("Item clicked!")}
          className="cursor-pointer"
        >
          <ItemMedia variant="icon">
            <File />
          </ItemMedia>
          <ItemContent>
            <ItemTitle>Long Press Me</ItemTitle>
            <ItemDescription>
              Press and hold this item for half a second.
            </ItemDescription>
          </ItemContent>
        </Item>
      </ItemGroup>
    </div>
  ),
};

export const TeamMembersList: Story = {
  name: "8. Use Case: Interactive Team List",
  parameters: {
    docs: {
      description: {
        story:
          "Clicking anywhere on the Item toggles the checkbox. Clicking the checkbox itself is handled separately to prevent the event from firing twice.",
      },
    },
  },
  render: () => {
    const members = [
      {
        id: "1",
        name: "Alisa Hester",
        role: "Frontend Developer",
        avatar: "https://i.pravatar.cc/150?img=1",
        badge: "Admin",
        active: null,
      },
      {
        id: "2",
        name: "Barry Cuda",
        role: "Backend Developer",
        avatar: "https://i.pravatar.cc/150?img=2",
        badge: null,
        active: null,
      },
      {
        id: "3",
        name: "Charlie Enderson",
        role: "Product Designer",
        avatar: "https://i.pravatar.cc/150?img=3",
        badge: null,
        active: "Last active: 2 hours ago",
      },
    ];

    const [selected, setSelected] = useState(new Set(["1"]));

    const toggleSelection = (id: string) => {
      setSelected((prev) => {
        const newSet = new Set(prev);
        if (newSet.has(id)) {
          newSet.delete(id);
        } else {
          newSet.add(id);
        }
        return newSet;
      });
    };

    return (
      <div className="max-w-4xl w-full">
        <Typography variant="h4" className="mb-4">
          Team Members
        </Typography>
        <ItemGroup>
          {members.map((member, index) => (
            <React.Fragment key={member.id}>
              <Item
                size="lg"
                shape="minimal"
                variant={member.badge ? "primary" : "secondary"}
                className="cursor-pointer"
                onClick={() => toggleSelection(member.id)}
              >
                <ItemMedia variant="avatar">
                  <Avatar
                    src={member.avatar}
                    fallback={member.name.slice(0, 2)}
                  />
                </ItemMedia>
                <ItemContent>
                  <ItemHeader>
                    <ItemTitle>{member.name}</ItemTitle>
                    {member.badge && (
                      <Badge shape="full" variant="secondary">
                        {member.badge}
                      </Badge>
                    )}
                  </ItemHeader>
                  <ItemDescription>{member.role}</ItemDescription>
                  {member.active && (
                    <ItemFooter>
                      <Typography variant="muted" className="!text-xs">
                        {member.active}
                      </Typography>
                    </ItemFooter>
                  )}
                </ItemContent>
                <ItemActions onClick={(e) => e.stopPropagation()}>
                  <Checkbox
                    checked={selected.has(member.id)}
                    onChange={() => toggleSelection(member.id)}
                    aria-label={`Select ${member.name}`}
                  />
                </ItemActions>
              </Item>
              {index < members.length - 1 && <ItemSeparator />}
            </React.Fragment>
          ))}
        </ItemGroup>
      </div>
    );
  },
};

export const SettingsList: Story = {
  name: "9. Use Case: Interactive Settings List",
  parameters: {
    docs: {
      description: {
        story:
          "A common pattern for settings pages. Clicking the entire item toggles the switch, providing a larger touch target.",
      },
    },
  },
  render: () => {
    const [notifications, setNotifications] = useState(true);
    const [darkMode, setDarkMode] = useState(false);
    return (
      <div className="w-96">
        <Typography variant="h4" className="mb-4">
          Settings
        </Typography>
        <ItemGroup>
          <Item
            variant="ghost"
            size="md"
            className="cursor-pointer"
            onClick={() => setNotifications((prev) => !prev)}
          >
            <ItemMedia variant="icon" shape="full">
              <Bell />
            </ItemMedia>
            <ItemContent>
              <ItemTitle>Push Notifications</ItemTitle>
              <ItemDescription>
                Receive updates on new messages.
              </ItemDescription>
            </ItemContent>
            <ItemActions onClick={(e) => e.stopPropagation()}>
              <Switch
                checked={notifications}
                onChange={(e) => setNotifications(e.target.checked)}
                aria-label="Toggle push notifications"
              />
            </ItemActions>
          </Item>
          <Item
            variant="ghost"
            size="md"
            className="cursor-pointer"
            onClick={() => setDarkMode((prev) => !prev)}
          >
            <ItemMedia variant="icon" shape="full">
              <Palette />
            </ItemMedia>
            <ItemContent>
              <ItemTitle>Dark Mode</ItemTitle>
              <ItemDescription>
                Toggle between light and dark themes.
              </ItemDescription>
            </ItemContent>
            <ItemActions onClick={(e) => e.stopPropagation()}>
              <Switch
                checked={darkMode}
                onChange={(e) => setDarkMode(e.target.checked)}
                aria-label="Toggle dark mode"
              />
            </ItemActions>
          </Item>
          <Item asChild variant="ghost" size="md" className="cursor-pointer">
            <a href="#" onClick={(e) => e.preventDefault()}>
              <ItemMedia variant="icon" shape="full">
                <Lock />
              </ItemMedia>
              <ItemContent>
                <ItemTitle>Account & Security</ItemTitle>
              </ItemContent>
              <ItemActions>
                <ChevronRight
                  size={20}
                  className="text-graphite-foreground/50"
                />
              </ItemActions>
            </a>
          </Item>
        </ItemGroup>
      </div>
    );
  },
};

export const NotificationList: Story = {
  name: "10. Use Case: Notification List",
  parameters: {
    docs: {
      description: {
        story:
          "Displaying a feed of notifications with avatars and timestamps.",
      },
    },
  },
  render: () => (
    <div className="w-[450px]">
      <ItemGroup>
        <Item variant="secondary" shape="minimal">
          <ItemMedia variant="avatar">
            <Avatar src="https://i.pravatar.cc/150?img=4" />
          </ItemMedia>
          <ItemContent>
            <ItemDescription>
              <b>Diana Prince</b> mentioned you in the <b>Q4 Planning</b>{" "}
              document.
            </ItemDescription>
            <ItemFooter>
              <Typography variant="muted" className="!text-xs">
                2 minutes ago
              </Typography>
            </ItemFooter>
          </ItemContent>
          <ItemActions>
            <div className="size-2.5 rounded-full bg-blue-500" />
          </ItemActions>
        </Item>
        <Item variant="secondary" shape="minimal">
          <ItemMedia variant="avatar">
            <Avatar src="https://i.pravatar.cc/150?img=5" />
          </ItemMedia>
          <ItemContent>
            <ItemDescription>
              <b>Clark Kent</b> completed the task "Deploy to production".
            </ItemDescription>
            <ItemFooter>
              <Typography variant="muted" className="!text-xs">
                1 hour ago
              </Typography>
            </ItemFooter>
          </ItemContent>
        </Item>
      </ItemGroup>
    </div>
  ),
};
```


### Component: `layout-router`

This section contains the source code for the `layout-router` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\layout-router\index.tsx`)**
```tsx
"use client";

import {
  AnimatePresence,
  motion,
  type Easing,
  type Transition,
} from "framer-motion";
import React, {
  createContext,
  useContext,
  useEffect,
  useLayoutEffect,
  useMemo,
  useState,
  type ReactElement,
  type ReactNode,
} from "react";
import { EASING } from "../stack-router/transitions";

// --- TYPES & CONSTANTS ---
const defaultEasing: Easing | Easing[] = EASING.iOS;
const defaultDuration = 0.5;

// --- CONTEXTS ---
interface LayoutRouterContextType {
  selectedId: string | null;
  navigate: (id: string) => void;
  goBack: () => void;
}
const LayoutRouterContext = createContext<LayoutRouterContextType | null>(null);

interface LayoutRouterConfigContextType {
  transition: Transition;
}
const LayoutRouterConfigContext = createContext<LayoutRouterConfigContextType>({
  transition: { duration: defaultDuration, ease: defaultEasing },
});

interface LayoutIdContextType {
  baseId: string;
}
const LayoutIdContext = createContext<LayoutIdContextType | null>(null);

// --- HOOKS ---
export const useLayoutRouter = () => {
  const context = useContext(LayoutRouterContext);
  if (!context) {
    throw new Error("useLayoutRouter must be used within a LayoutRouter.Root");
  }
  return context;
};

// --- COMPOUND COMPONENTS ---
interface LayoutRouterRootProps {
  children: ReactNode;
  duration?: number;
  easing?: Easing | Easing[];
}
const LayoutRouterRoot = ({
  children,
  duration = defaultDuration,
  easing = defaultEasing,
}: LayoutRouterRootProps) => {
  // --- NEW: HISTORY-BASED STATE MANAGEMENT ---
  const [stack, setStack] = useState<string[]>(
    () => (typeof window !== "undefined" && window.history.state?.stack) || []
  );

  const selectedId = stack.length > 0 ? stack[stack.length - 1] : null;

  useLayoutEffect(() => {
    // Set initial history state if it doesn't exist
    if (typeof window !== "undefined" && !window.history.state?.stack) {
      window.history.replaceState({ stack }, "");
    }
  }, [stack]);

  useEffect(() => {
    const handlePopState = (event: PopStateEvent) => {
      if (event.state && Array.isArray(event.state.stack)) {
        setStack(event.state.stack);
      }
    };
    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  const navigationValue = useMemo(
    () => ({
      selectedId,
      navigate: (id: string) => {
        const newStack = [...stack, id];
        window.history.pushState({ stack: newStack }, "");
        setStack(newStack);
      },
      goBack: () => {
        window.history.back();
      },
    }),
    [selectedId, stack]
  );
  // --- END: HISTORY-BASED STATE MANAGEMENT ---

  const configValue = useMemo(
    () => ({
      transition: { duration, ease: easing },
    }),
    [duration, easing]
  );

  const listChild = React.Children.toArray(children).find(
    (child): child is ReactElement =>
      React.isValidElement(child) && child.type === LayoutRouterList
  );
  const screenChildren = React.Children.toArray(children).filter(
    (child): child is ReactElement<{ id: string }> =>
      React.isValidElement(child) && child.type === LayoutRouterScreen
  );

  const activeScreen = screenChildren.find(
    (child) => child.props.id === selectedId
  );

  return (
    <LayoutRouterContext.Provider value={navigationValue}>
      <LayoutRouterConfigContext.Provider value={configValue}>
        {listChild}
        <AnimatePresence>{activeScreen}</AnimatePresence>
      </LayoutRouterConfigContext.Provider>
    </LayoutRouterContext.Provider>
  );
};
LayoutRouterRoot.displayName = "LayoutRouter.Root";

const LayoutRouterList = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>((props, ref) => <div ref={ref} {...props} />);
LayoutRouterList.displayName = "LayoutRouter.List";

const LayoutRouterLink = ({
  id,
  children,
  className,
}: {
  id: string;
  children: ReactNode;
  className?: string;
}) => {
  const { navigate } = useLayoutRouter();
  const { transition } = useContext(LayoutRouterConfigContext);
  return (
    <LayoutIdContext.Provider value={{ baseId: id }}>
      <motion.div
        layoutId={`card-${id}`}
        onClick={() => navigate(id)}
        className={className}
        transition={transition}
        style={{ willChange: "transform, opacity" }}
      >
        {children}
      </motion.div>
    </LayoutIdContext.Provider>
  );
};
LayoutRouterLink.displayName = "LayoutRouter.Link";

const LayoutRouterSharedElement = ({
  tag,
  children,
  className,
}: {
  tag: string;
  children: ReactNode;
  className?: string;
}) => {
  const context = useContext(LayoutIdContext);
  const { transition } = useContext(LayoutRouterConfigContext);
  if (!context) {
    throw new Error("SharedElement must be used inside a Link or Screen");
  }
  return (
    <motion.div
      layoutId={`${context.baseId}-${tag}`}
      className={className}
      transition={transition}
      style={{ willChange: "transform, opacity" }}
    >
      {children}
    </motion.div>
  );
};
LayoutRouterSharedElement.displayName = "LayoutRouter.SharedElement";

const LayoutRouterScreen = ({
  id,
  children,
}: {
  id: string;
  children: ReactNode;
}) => {
  const { transition } = useContext(LayoutRouterConfigContext);
  return (
    <LayoutIdContext.Provider value={{ baseId: id }}>
      {/* This div is the fullscreen container */}
      <div className="fixed inset-0 z-50 pointer-events-none">
        <motion.div
          layoutId={`card-${id}`}
          className="w-full h-full pointer-events-auto bg-graphite-background" // Ensure it has a background
          transition={transition}
          style={{ willChange: "transform, opacity" }}
        >
          {children}
        </motion.div>
      </div>
    </LayoutIdContext.Provider>
  );
};
LayoutRouterScreen.displayName = "LayoutRouter.Screen";

export const LayoutRouter = Object.assign(LayoutRouterRoot, {
  List: LayoutRouterList,
  Link: LayoutRouterLink,
  Screen: LayoutRouterScreen,
  SharedElement: LayoutRouterSharedElement,
});
```

**Storybook Stories (`Layout-router.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Archive,
  ArrowLeft,
  Delete,
  MoreVertical,
  Pencil,
  Search,
  Star,
} from "lucide-react";
import { useRef } from "react";
import { useAppBar } from "../../hooks/useAppBar";
import { AppBar } from "../appbar";
import { Avatar } from "../avatar";
import DeviceFrame from "../device";
import { ElasticScrollArea } from "../elastic-scroll-area";
import { IconButton } from "../icon-button";
import { Input } from "../input";
import {
  Item,
  ItemContent,
  ItemDescription,
  ItemMedia,
  ItemTitle,
} from "../item";
import { Typography } from "../typography";
import { LayoutRouter, useLayoutRouter } from "./index";

const meta: Meta<typeof LayoutRouter> = {
  title: "Components/Navigators/LayoutRouter",
  component: LayoutRouter,
  // ... (rest of meta config is unchanged)
  subcomponents: {
    List: LayoutRouter.List,
    Link: LayoutRouter.Link,
    Screen: LayoutRouter.Screen,
    SharedElement: LayoutRouter.SharedElement,
  },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A declarative router for creating multi-element shared layout transitions. This version supports browser history and fullscreen transitions, demonstrated with a full mail client UI.",
      },
    },
  },
  argTypes: {
    duration: {
      control: { type: "range", min: 0.2, max: 2, step: 0.1 },
      description: "The duration of the transition in seconds.",
    },
    easing: {
      control: "object",
      description: "An array of 4 numbers for a cubic bezier easing curve.",
    },
  },
  decorators: [
    (Story) => (
      <DeviceFrame>
        <Story />
      </DeviceFrame>
    ),
  ],
};

export default meta;
type Story = StoryObj;

// --- Sample Data (Unchanged) ---
const sampleEmails = [
  {
    id: "email-1",
    sender: "Alisa Hester",
    avatar: "https://i.pravatar.cc/150?img=1",
    subject: "Project Update & Next Steps",
    preview: "Hey team, just wanted to give a quick update...",
    timestamp: "2m ago",
    fullBody: "...",
  },
  {
    id: "email-2",
    sender: "Barry Cuda",
    avatar: "https://i.pravatar.cc/150?img=2",
    subject: "Lunch Plans?",
    preview: "Anyone up for lunch today? I'm craving tacos.",
    timestamp: "15m ago",
    fullBody: "...",
  },
  {
    id: "email-3",
    sender: "Charlie Enderson",
    avatar: "https://i.pravatar.cc/150?img=3",
    subject: "Design Feedback Required",
    preview: "Hi, I've just pushed the latest mockups...",
    timestamp: "1h ago",
    fullBody: "...",
  },
  {
    id: "email-4",
    sender: "Diana Prince",
    avatar: "https://i.pravatar.cc/150?img=4",
    subject: "Re: Q3 Budget",
    preview: "Thanks for sending that over, I'll take a look.",
    timestamp: "3h ago",
    fullBody: "...",
  },
  {
    id: "email-5",
    sender: "Ethan Hunt",
    avatar: "https://i.pravatar.cc/150?img=5",
    subject: "Your Mission, Should You Choose to Accept It",
    preview: "This message will self-destruct in 5 seconds.",
    timestamp: "Yesterday",
    fullBody: "...",
  },
];

// --- Reusable UI Components for the Story ---

const MailListItem = ({ email }: { email: (typeof sampleEmails)[0] }) => (
  <Item variant="secondary" shape="minimal" padding="sm">
    <ItemMedia>
      <LayoutRouter.SharedElement tag="avatar">
        <Avatar src={email.avatar} fallback={email.sender.slice(0, 2)} />
      </LayoutRouter.SharedElement>
    </ItemMedia>
    <ItemContent>
      <div className="flex justify-between items-start">
        <LayoutRouter.SharedElement tag="sender">
          <ItemTitle>{email.sender}</ItemTitle>
        </LayoutRouter.SharedElement>
        <LayoutRouter.SharedElement tag="timestamp">
          <Typography
            variant="muted"
            className="!mt-0 !text-xs whitespace-nowrap"
          >
            {email.timestamp}
          </Typography>
        </LayoutRouter.SharedElement>
      </div>
      <LayoutRouter.SharedElement tag="subject">
        <ItemDescription className="font-semibold !text-graphite-foreground/90">
          {email.subject}
        </ItemDescription>
      </LayoutRouter.SharedElement>
      <ItemDescription>{email.preview}</ItemDescription>
    </ItemContent>
  </Item>
);

const MailDetailScreen = ({ email }: { email: (typeof sampleEmails)[0] }) => {
  const { goBack } = useLayoutRouter();
  return (
    <div className="overflow-hidden h-full flex flex-col bg-graphite-card">
      <AppBar
        appBarColor="card"
        startAdornment={
          <IconButton
            type="button"
            variant="ghost"
            size="sm"
            onClick={goBack}
            aria-label="Go back"
          >
            <ArrowLeft />
          </IconButton>
        }
        endAdornments={[
          <IconButton
            key="archive"
            type="button"
            variant="ghost"
            size="sm"
            aria-label="Archive"
          >
            <Archive size={20} />
          </IconButton>,
          <IconButton
            key="delete"
            type="button"
            variant="ghost"
            size="sm"
            aria-label="Delete"
          >
            <Delete size={20} />
          </IconButton>,
          <IconButton
            key="more"
            type="button"
            variant="ghost"
            size="sm"
            aria-label="More options"
          >
            <MoreVertical size={20} />
          </IconButton>,
        ]}
      />

      <ElasticScrollArea className="flex-1">
        <div className="p-6 pt-2">
          <LayoutRouter.SharedElement tag="subject">
            <Typography variant="h3" className="mb-6">
              {email.subject}
            </Typography>
          </LayoutRouter.SharedElement>

          <div className="flex items-center gap-4">
            <LayoutRouter.SharedElement tag="avatar">
              <Avatar
                size="lg"
                src={email.avatar}
                fallback={email.sender.slice(0, 2)}
              />
            </LayoutRouter.SharedElement>
            <div className="flex-1">
              <LayoutRouter.SharedElement tag="sender">
                <Typography variant="large">{email.sender}</Typography>
              </LayoutRouter.SharedElement>
              <Typography variant="muted" className="!mt-0">
                to me
              </Typography>
            </div>
            <LayoutRouter.SharedElement tag="timestamp">
              <Typography variant="muted" className="!mt-0 !text-xs">
                {email.timestamp}
              </Typography>
            </LayoutRouter.SharedElement>
            <IconButton variant="ghost" size="sm" aria-label="Favorite">
              <Star size={20} />
            </IconButton>
          </div>
          <Typography variant="p" className="mt-8">
            {email.fullBody} {email.fullBody} {email.fullBody}
          </Typography>
        </div>
      </ElasticScrollArea>
    </div>
  );
};

const InboxScreen = () => {
  const scrollRef = useRef<HTMLDivElement>(null);
  const appBarProps = {
    scrollContainerRef: scrollRef,
    size: "lg" as const,
    scrollBehavior: "conditionally-sticky" as const,
    animatedBehavior: ["shadow"] as Array<"shadow">,
    appBarColor: "card" as const,
    largeHeaderRowHeight: 50,
  };
  const { contentPaddingTop } = useAppBar(appBarProps);

  return (
    <div className="w-full h-full relative bg-graphite-background flex flex-col">
      <AppBar
        {...appBarProps}
        children={<Typography variant="h4">Inbox</Typography>}
        endAdornments={[
          <IconButton key="compose" variant="ghost" aria-label="Compose">
            <Pencil size={20} />
          </IconButton>,
        ]}
        largeHeaderContent={
          <Input
            variant="secondary"
            shape="full"
            startAdornment={<Search className="h-5 w-5 text-gray-500" />}
            placeholder="Search mail..."
          />
        }
      />
      <ElasticScrollArea ref={scrollRef} className="flex-1">
        <div style={{ paddingTop: contentPaddingTop }}>
          <div className="p-2 flex flex-col gap-2">
            {sampleEmails.map((email) => (
              <LayoutRouter.Link
                key={email.id}
                id={email.id}
                className="cursor-pointer"
              >
                <MailListItem email={email} />
              </LayoutRouter.Link>
            ))}
          </div>
        </div>
      </ElasticScrollArea>
    </div>
  );
};

export const MailClientApp: Story = {
  name: "Mail Client App",
  args: {
    duration: 0.5,
  },
  render: (args) => (
    <LayoutRouter {...args}>
      <LayoutRouter.List>
        <InboxScreen />
      </LayoutRouter.List>

      {sampleEmails.map((email) => (
        <LayoutRouter.Screen key={email.id} id={email.id}>
          <MailDetailScreen email={email} />
        </LayoutRouter.Screen>
      ))}
    </LayoutRouter>
  ),
};
```


### Component: `menubar`

This section contains the source code for the `menubar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\menubar\index.tsx`)**
```tsx
"use client";

import * as RadixMenubar from "@radix-ui/react-menubar";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { Check, ChevronRight, Circle } from "lucide-react";
import React, { createContext, useContext, useRef } from "react";
import useRipple from "use-ripple-hook";

type MenubarShape = "full" | "minimal" | "sharp";

// --- Context to pass shape down the tree ---
interface MenubarContextProps {
  shape: MenubarShape;
}

const MenubarContext = createContext<MenubarContextProps>({
  shape: "minimal",
});

const useMenubarContext = () => useContext(MenubarContext);

// --- Root Component (Wrapped to provide context) ---
interface MenubarProps extends RadixMenubar.MenubarProps {
  shape?: MenubarShape;
}

const MenubarRoot: React.FC<MenubarProps> = ({
  shape = "minimal",
  className,
  ...props
}) => {
  return (
    <MenubarContext.Provider value={{ shape }}>
      <RadixMenubar.Root
        className={clsx(
          "flex h-10 items-center space-x-1 rounded-lg bg-transparent p-1",
          className
        )}
        {...props}
      />
    </MenubarContext.Provider>
  );
};

// --- CVA for Content Components ---
const contentVariants = cva(
  [
    "z-50 min-w-[12rem] max-h-[var(--radix-menubar-content-available-height)] overflow-y-auto overflow-x-hidden",
    "border border-graphite-border bg-graphite-card p-1.5",
    "shadow-md",
  ],
  {
    variants: {
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      shape: "minimal",
    },
  }
);

// --- Re-exported Primitives ---
const MenubarMenu = RadixMenubar.Menu;
const MenubarGroup = RadixMenubar.Group;
const MenubarPortal = RadixMenubar.Portal;
const MenubarSub = RadixMenubar.Sub;
const MenubarRadioGroup = RadixMenubar.RadioGroup;

// --- Styled Trigger ---
const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.Trigger>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.Trigger>
>((props, ref) => (
  <RadixMenubar.Trigger
    ref={ref}
    className={clsx(
      "flex cursor-pointer select-none items-center rounded-md px-3 py-1.5 text-sm font-semibold outline-none",
      "transition-colors duration-150 ease-in-out",
      "hover:bg-graphite-secondary focus:bg-graphite-secondary",
      "data-[state=open]:bg-graphite-secondary"
    )}
    {...props}
  />
));
MenubarTrigger.displayName = RadixMenubar.Trigger.displayName;

// --- Animated Content Container ---
const MenubarContent = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.Content>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => {
    const { shape } = useMenubarContext();
    return (
      <MenubarPortal>
        <RadixMenubar.Content
          ref={ref}
          align={align}
          alignOffset={alignOffset}
          sideOffset={sideOffset}
          className={clsx(
            contentVariants({ shape }),
            "data-[state=open]:animate-menu-enter",
            "data-[state=closed]:animate-menu-exit",
            "data-[side=top]:origin-bottom",
            "data-[side=bottom]:origin-top",
            "data-[side=left]:origin-right",
            "data-[side=right]:origin-left",
            className
          )}
          {...props}
        />
      </MenubarPortal>
    );
  }
);
MenubarContent.displayName = RadixMenubar.Content.displayName;

// --- Enhanced Menu Item ---
const MenubarItem = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.Item>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => {
  const { shape } = useMenubarContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current as HTMLDivElement);

  return (
    <RadixMenubar.Item
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        "relative flex cursor-pointer select-none items-center gap-2 rounded-lg px-3 py-2.5 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        "[&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    />
  );
});
MenubarItem.displayName = RadixMenubar.Item.displayName;

// --- Enhanced Checkbox Item ---
const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.CheckboxItem>
>(({ className, children, ...props }, ref) => {
  const { shape } = useMenubarContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current as HTMLDivElement);

  return (
    <RadixMenubar.CheckboxItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        "relative flex cursor-pointer select-none items-center rounded-lg py-2.5 pl-8 pr-3 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixMenubar.ItemIndicator>
          <Check className="h-4 w-4 animate-check-in" />
        </RadixMenubar.ItemIndicator>
      </span>
      {children}
    </RadixMenubar.CheckboxItem>
  );
});
MenubarCheckboxItem.displayName = RadixMenubar.CheckboxItem.displayName;

// --- Enhanced Radio Item ---
const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.RadioItem>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.RadioItem>
>(({ className, children, ...props }, ref) => {
  const { shape } = useMenubarContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current as HTMLDivElement);

  return (
    <RadixMenubar.RadioItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        "relative flex cursor-pointer select-none items-center rounded-lg py-2.5 pl-8 pr-3 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixMenubar.ItemIndicator>
          <Circle className="h-2 w-2 fill-current animate-check-in" />
        </RadixMenubar.ItemIndicator>
      </span>
      {children}
    </RadixMenubar.RadioItem>
  );
});
MenubarRadioItem.displayName = RadixMenubar.RadioItem.displayName;

// --- Enhanced Sub-Menu Trigger ---
const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, children, inset, ...props }, ref) => {
  const { shape } = useMenubarContext();
  const localRef = useRef<HTMLDivElement>(null);
  const [, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current as HTMLDivElement);

  return (
    <RadixMenubar.SubTrigger
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        "relative flex cursor-pointer select-none items-center gap-2 rounded-lg px-3 py-2.5 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary",
        "data-[state=open]:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "[&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRight className="ml-auto h-4 w-4" />
    </RadixMenubar.SubTrigger>
  );
});
MenubarSubTrigger.displayName = RadixMenubar.SubTrigger.displayName;

// --- Enhanced Sub-Menu Content ---
const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.SubContent>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.SubContent>
>(({ className, ...props }, ref) => {
  const { shape } = useMenubarContext();
  return (
    <RadixMenubar.SubContent
      ref={ref}
      className={clsx(
        contentVariants({ shape }),
        "data-[state=open]:data-[side=right]:animate-submenu-enter-right",
        "data-[state=closed]:data-[side=right]:animate-submenu-exit-right",
        "data-[state=open]:data-[side=left]:animate-submenu-enter-left",
        "data-[state=closed]:data-[side=left]:animate-submenu-exit-left",
        className
      )}
      {...props}
    />
  );
});
MenubarSubContent.displayName = RadixMenubar.SubContent.displayName;

// --- Other Components (Unchanged) ---
const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.Label>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <RadixMenubar.Label
    ref={ref}
    className={clsx(
      "px-3 py-2 text-xs font-medium text-graphite-foreground/70 tracking-wide",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
MenubarLabel.displayName = RadixMenubar.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof RadixMenubar.Separator>,
  React.ComponentPropsWithoutRef<typeof RadixMenubar.Separator>
>(({ className, ...props }, ref) => (
  <RadixMenubar.Separator
    ref={ref}
    className={clsx("-mx-1 my-1.5 h-px bg-graphite-border/60", className)}
    {...props}
  />
));
MenubarSeparator.displayName = RadixMenubar.Separator.displayName;

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={clsx(
        "ml-auto text-xs font-mono tracking-wider text-graphite-foreground/50",
        className
      )}
      {...props}
    />
  );
};
MenubarShortcut.displayName = "MenubarShortcut";

export const Menubar = Object.assign(MenubarRoot, {
  Menu: MenubarMenu,
  Trigger: MenubarTrigger,
  Content: MenubarContent,
  Item: MenubarItem,
  Separator: MenubarSeparator,
  Label: MenubarLabel,
  CheckboxItem: MenubarCheckboxItem,
  RadioGroup: MenubarRadioGroup,
  RadioItem: MenubarRadioItem,
  Portal: MenubarPortal,
  Group: MenubarGroup,
  Sub: MenubarSub,
  SubContent: MenubarSubContent,
  SubTrigger: MenubarSubTrigger,
  Shortcut: MenubarShortcut,
});
```

**Storybook Stories (`Menubar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Cloud,
  CreditCard,
  Github,
  LifeBuoy,
  LogOut,
  Mail,
  MessageSquare,
  Plus,
  PlusCircle,
  Settings,
  User,
  UserPlus,
  Users,
} from "lucide-react";
import { useState } from "react";
import { Menubar } from "./index";

const meta: Meta<typeof Menubar> = {
  title: "Components/Navigators/Menubar",
  component: Menubar,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A horizontal menu bar, similar to those found in native desktop applications. Built on Radix UI for accessibility and keyboard navigation.",
      },
    },
  },
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "Controls the border-radius of the content popovers.",
    },
  },
};

export default meta;
type Story = StoryObj<typeof Menubar>;

const FakeWindow = ({ children }: { children: React.ReactNode }) => (
  <div className="w-[720px] h-[480px] flex flex-col shadow-2xl overflow-hidden bg-graphite-background ring-1 ring-black/5 rounded-xl">
    <div className="bg-graphite-card border-b border-graphite-border">
      {children}
    </div>
    <div className="flex-1 p-6 bg-graphite-background">
      <p>App Content Area</p>
    </div>
  </div>
);

export const Default: Story = {
  name: "1. Default Menubar",
  args: {
    shape: "minimal",
  },
  render: (args) => (
    <FakeWindow>
      <Menubar {...args}>
        <Menubar.Menu>
          <Menubar.Trigger>File</Menubar.Trigger>
          <Menubar.Content>
            <Menubar.Item>
              New Tab <Menubar.Shortcut>⌘T</Menubar.Shortcut>
            </Menubar.Item>
            <Menubar.Item>
              New Window <Menubar.Shortcut>⌘N</Menubar.Shortcut>
            </Menubar.Item>
            <Menubar.Item disabled>New Incognito Window</Menubar.Item>
            <Menubar.Separator />
            <Menubar.Item>
              Print... <Menubar.Shortcut>⌘P</Menubar.Shortcut>
            </Menubar.Item>
          </Menubar.Content>
        </Menubar.Menu>
        <Menubar.Menu>
          <Menubar.Trigger>Edit</Menubar.Trigger>
          <Menubar.Content>
            <Menubar.Item>
              Undo <Menubar.Shortcut>⌘Z</Menubar.Shortcut>
            </Menubar.Item>
            <Menubar.Item>
              Redo <Menubar.Shortcut>⇧⌘Z</Menubar.Shortcut>
            </Menubar.Item>
            <Menubar.Separator />
            <Menubar.Item>Cut</Menubar.Item>
            <Menubar.Item>Copy</Menubar.Item>
            <Menubar.Item>Paste</Menubar.Item>
          </Menubar.Content>
        </Menubar.Menu>
        <Menubar.Menu>
          <Menubar.Trigger>View</Menubar.Trigger>
          <Menubar.Content>
            <Menubar.Item>Reload</Menubar.Item>
            <Menubar.Item>Force Reload</Menubar.Item>
            <Menubar.Separator />
            <Menubar.Item>Toggle Fullscreen</Menubar.Item>
          </Menubar.Content>
        </Menubar.Menu>
      </Menubar>
    </FakeWindow>
  ),
};

export const KitchenSink: Story = {
  name: "2. Kitchen Sink",
  args: {
    shape: "minimal",
  },
  render: (args) => {
    const [showStatusBar, setShowStatusBar] = useState(true);
    const [person, setPerson] = useState("benoit");

    return (
      <FakeWindow>
        <Menubar {...args}>
          <Menubar.Menu>
            <Menubar.Trigger>Account</Menubar.Trigger>
            <Menubar.Content>
              <Menubar.Item>
                <User className="mr-2" /> Profile{" "}
                <Menubar.Shortcut>⇧⌘P</Menubar.Shortcut>
              </Menubar.Item>
              <Menubar.Item>
                <CreditCard className="mr-2" /> Billing
              </Menubar.Item>
              <Menubar.Item>
                <Settings className="mr-2" /> Settings{" "}
                <Menubar.Shortcut>⌘,</Menubar.Shortcut>
              </Menubar.Item>
              <Menubar.Separator />
              <Menubar.Sub>
                <Menubar.SubTrigger>
                  <UserPlus className="mr-2" /> Invite users...
                </Menubar.SubTrigger>
                {/* --- THIS IS THE FIX --- */}
                <Menubar.Portal>
                  <Menubar.SubContent>
                    <Menubar.Item>
                      <Mail className="mr-2" /> Email
                    </Menubar.Item>
                    <Menubar.Item>
                      <MessageSquare className="mr-2" /> Message
                    </Menubar.Item>
                    <Menubar.Separator />
                    <Menubar.Item>
                      <PlusCircle className="mr-2" /> More...
                    </Menubar.Item>
                  </Menubar.SubContent>
                </Menubar.Portal>
                {/* --- END OF FIX --- */}
              </Menubar.Sub>
              <Menubar.Separator />
              <Menubar.Item>
                <LogOut className="mr-2" /> Log out
              </Menubar.Item>
            </Menubar.Content>
          </Menubar.Menu>
          <Menubar.Menu>
            <Menubar.Trigger>View</Menubar.Trigger>
            <Menubar.Content>
              <Menubar.CheckboxItem
                checked={showStatusBar}
                onCheckedChange={setShowStatusBar}
              >
                Show Status Bar
              </Menubar.CheckboxItem>
              <Menubar.Separator />
              <Menubar.RadioGroup value={person} onValueChange={setPerson}>
                <Menubar.Label>Panel Position</Menubar.Label>
                <Menubar.RadioItem value="pedro">Pedro</Menubar.RadioItem>
                <Menubar.RadioItem value="benoit">Benoit</Menubar.RadioItem>
                <Menubar.RadioItem value="colm">Colm</Menubar.RadioItem>
              </Menubar.RadioGroup>
            </Menubar.Content>
          </Menubar.Menu>
        </Menubar>
      </FakeWindow>
    );
  },
};

export const AllShapes: Story = {
  name: "3. All Shapes",
  render: () => (
    <div className="flex flex-col gap-8">
      <FakeWindow>
        <Menubar shape="full">
          <Menubar.Menu>
            <Menubar.Trigger>Full</Menubar.Trigger>
            <Menubar.Content>
              <Menubar.Item>Item 1</Menubar.Item>
              <Menubar.Item>Item 2</Menubar.Item>
            </Menubar.Content>
          </Menubar.Menu>
        </Menubar>
      </FakeWindow>
      <FakeWindow>
        <Menubar shape="minimal">
          <Menubar.Menu>
            <Menubar.Trigger>Minimal</Menubar.Trigger>
            <Menubar.Content>
              <Menubar.Item>Item 1</Menubar.Item>
              <Menubar.Item>Item 2</Menubar.Item>
            </Menubar.Content>
          </Menubar.Menu>
        </Menubar>
      </FakeWindow>
      <FakeWindow>
        <Menubar shape="sharp">
          <Menubar.Menu>
            <Menubar.Trigger>Sharp</Menubar.Trigger>
            <Menubar.Content>
              <Menubar.Item>Item 1</Menubar.Item>
              <Menubar.Item>Item 2</Menubar.Item>
            </Menubar.Content>
          </Menubar.Menu>
        </Menubar>
      </FakeWindow>
    </div>
  ),
};
```


### Component: `navigation-menu`

This section contains the source code for the `navigation-menu` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\navigation-menu\index.tsx`)**
```tsx
"use client";

import * as RadixNavigationMenu from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { ChevronDown } from "lucide-react";
import React, { useImperativeHandle, useRef } from "react";
import useRipple from "use-ripple-hook";
import { Typography } from "../typography";

// --- CVA Variants ---
export const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-lg bg-transparent px-4 py-2 text-sm font-semibold transition-colors hover:bg-graphite-secondary focus:bg-graphite-secondary focus:outline-none focus:ring-2 focus:ring-graphite-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-graphite-secondary/50 data-[state=open]:bg-graphite-secondary/50"
);

// --- NEW: CVA for ContentItem ---
// FIX #1: Wrapped the base classes in an array to fix the cva argument error.
const contentItemVariants = cva([
  "relative block w-full select-none space-y-1 rounded-lg p-3 text-left leading-none no-underline outline-none transition-colors duration-150 ease-in-out overflow-hidden",
  "hover:bg-graphite-secondary focus:bg-graphite-secondary",
  "focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2 focus-visible:ring-offset-graphite-card",
]);

// --- Core Components (Unchanged) ---
const NavigationMenuRoot = React.forwardRef<
  React.ElementRef<typeof RadixNavigationMenu.Root>,
  React.ComponentPropsWithoutRef<typeof RadixNavigationMenu.Root>
>(({ className, children, ...props }, ref) => (
  <RadixNavigationMenu.Root
    ref={ref}
    className={clsx(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </RadixNavigationMenu.Root>
));
NavigationMenuRoot.displayName = RadixNavigationMenu.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof RadixNavigationMenu.List>,
  React.ComponentPropsWithoutRef<typeof RadixNavigationMenu.List>
>(({ className, ...props }, ref) => (
  <RadixNavigationMenu.List
    ref={ref}
    className={clsx(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
));
NavigationMenuList.displayName = RadixNavigationMenu.List.displayName;

const NavigationMenuItem = RadixNavigationMenu.Item;

// --- Trigger (Unchanged) ---
const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof RadixNavigationMenu.Trigger>,
  React.ComponentPropsWithoutRef<typeof RadixNavigationMenu.Trigger>
>(({ className, children, ...props }, ref) => (
  <RadixNavigationMenu.Trigger
    ref={ref}
    className={clsx(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}
    <ChevronDown
      className="relative top-[1px] ml-1 h-4 w-4 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </RadixNavigationMenu.Trigger>
));
NavigationMenuTrigger.displayName = RadixNavigationMenu.Trigger.displayName;

// --- Content (Unchanged) ---
const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof RadixNavigationMenu.Content>,
  React.ComponentPropsWithoutRef<typeof RadixNavigationMenu.Content>
>(({ className, ...props }, ref) => (
  <RadixNavigationMenu.Content
    ref={ref}
    className={clsx(
      "left-0 top-0 w-full data-[motion^=from-]:animate-nav-enter-from data-[motion^=to-]:animate-nav-exit-to data-[motion=from-end]:animate-nav-enter-from-right data-[motion=from-start]:animate-nav-enter-from-left data-[motion=to-end]:animate-nav-exit-to-right data-[motion=to-start]:animate-nav-exit-to-left md:absolute md:w-auto",
      className
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = RadixNavigationMenu.Content.displayName;

const NavigationMenuLink = RadixNavigationMenu.Link;

// --- NEW: ContentList Component ---
const NavigationMenuContentList = React.forwardRef<
  HTMLUListElement,
  React.HTMLAttributes<HTMLUListElement> & {
    grid?: "cols-1" | "cols-2" | "cols-3";
  }
>(({ className, grid = "cols-1", ...props }, ref) => {
  const gridClasses = {
    "cols-1": "md:grid-cols-1",
    "cols-2": "md:grid-cols-2",
    "cols-3": "md:grid-cols-3",
  };
  return (
    <ul
      ref={ref}
      className={clsx(
        "grid gap-3 p-4",
        "w-[400px]",
        gridClasses[grid],
        className
      )}
      {...props}
    />
  );
});
NavigationMenuContentList.displayName = "NavigationMenu.ContentList";

// --- NEW: ContentItem Component ---
// FIX #2: Omitted the conflicting 'title' prop from the base Radix props.
interface ContentItemProps
  extends Omit<
    React.ComponentPropsWithoutRef<typeof NavigationMenuLink>,
    "title"
  > {
  title: React.ReactNode;
  startIcon?: React.ReactNode;
  endAdornment?: React.ReactNode;
}

const NavigationMenuContentItem = React.forwardRef<
  React.ElementRef<typeof NavigationMenuLink>,
  ContentItemProps
>(
  (
    {
      className,
      title,
      children,
      startIcon,
      endAdornment,
      onPointerDown,
      ...props
    },
    ref
  ) => {
    const localRef = useRef<HTMLAnchorElement>(null);
    // FIX #3: Replaced the non-null assertion with a type assertion.
    useImperativeHandle(ref, () => localRef.current as HTMLAnchorElement);
    const [, event] = useRipple({
      ref: localRef,
      color: "rgba(0, 0, 0, 0.1)",
      duration: 400,
    });

    return (
      <li>
        <NavigationMenuLink
          ref={localRef}
          onPointerDown={(e) => {
            event(e);
            onPointerDown?.(e);
          }}
          className={contentItemVariants({ className })}
          {...props}
        >
          <div className="flex items-start gap-4">
            {startIcon && (
              <div className="mt-0.5 text-graphite-primary flex-shrink-0">
                {startIcon}
              </div>
            )}
            <div className="flex-1">
              <div className="flex justify-between items-center">
                <Typography
                  variant="small"
                  className="font-semibold !leading-none"
                >
                  {title}
                </Typography>
                {endAdornment}
              </div>
              {children && (
                <Typography
                  variant="muted"
                  className="!text-sm !leading-snug line-clamp-2"
                >
                  {children}
                </Typography>
              )}
            </div>
          </div>
        </NavigationMenuLink>
      </li>
    );
  }
);
NavigationMenuContentItem.displayName = "NavigationMenu.ContentItem";

// --- Viewport & Indicator (Unchanged) ---
const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof RadixNavigationMenu.Viewport>,
  React.ComponentPropsWithoutRef<typeof RadixNavigationMenu.Viewport>
>(({ className, ...props }, ref) => (
  <div className={clsx("absolute left-0 top-full flex justify-center")}>
    <RadixNavigationMenu.Viewport
      className={clsx(
        "origin-top-center relative mt-2 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-xl border border-graphite-border bg-graphite-card text-graphite-foreground shadow-lg data-[state=open]:animate-nav-scale-in data-[state=closed]:animate-nav-scale-out md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName = RadixNavigationMenu.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof RadixNavigationMenu.Indicator>,
  React.ComponentPropsWithoutRef<typeof RadixNavigationMenu.Indicator>
>(({ className, ...props }, ref) => (
  <RadixNavigationMenu.Indicator
    ref={ref}
    className={clsx(
      "top-full z-[1] flex h-2.5 items-end justify-center overflow-hidden data-[state=visible]:animate-nav-fade-in data-[state=hidden]:animate-nav-fade-out",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-3 w-3 rotate-45 rounded-tl-sm bg-graphite-border" />
  </RadixNavigationMenu.Indicator>
));
NavigationMenuIndicator.displayName = RadixNavigationMenu.Indicator.displayName;

// --- Compound Export ---
export const NavigationMenu = Object.assign(NavigationMenuRoot, {
  List: NavigationMenuList,
  Item: NavigationMenuItem,
  Content: NavigationMenuContent,
  Trigger: NavigationMenuTrigger,
  Link: NavigationMenuLink,
  Indicator: NavigationMenuIndicator,
  Viewport: NavigationMenuViewport,
  ContentList: NavigationMenuContentList,
  ContentItem: NavigationMenuContentItem,
});
```

**Storybook Stories (`navigation-menu.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Code,
  Component,
  GitCommit,
  Github,
  LifeBuoy,
  LogOut,
  Settings,
  User,
} from "lucide-react";
import React from "react";
import { Badge } from "../badge";
import { Typography } from "../typography";
import { NavigationMenu, navigationMenuTriggerStyle } from "./index";

const meta: Meta<typeof NavigationMenu> = {
  title: "Components/Navigators/NavigationMenu",
  component: NavigationMenu,
  subcomponents: {
    "NavigationMenu.ContentList": NavigationMenu.ContentList,
    "NavigationMenu.ContentItem": NavigationMenu.ContentItem,
  },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A modern, accessible navigation menu with smooth, animated transitions for dropdowns. Built on Radix UI. Now includes `ContentList` and `ContentItem` for building rich dropdown layouts.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof NavigationMenu>;

export const Default: Story = {
  name: "1. Default Menu",
  render: () => (
    <div className="flex h-96 w-full items-start justify-center pt-12">
      <NavigationMenu>
        <NavigationMenu.List>
          <NavigationMenu.Item>
            <NavigationMenu.Trigger>Getting started</NavigationMenu.Trigger>
            <NavigationMenu.Content>
              <ul className="grid gap-3 p-4 md:w-[400px] lg:w-[500px] lg:grid-cols-[.75fr_1fr]">
                <li className="row-span-3">
                  <NavigationMenu.Link asChild>
                    <a
                      className="flex h-full w-full select-none flex-col justify-end rounded-lg bg-gradient-to-b from-graphite-secondary to-graphite-border p-6 no-underline outline-none focus:shadow-md"
                      href="#"
                    >
                      <Component className="h-6 w-6" />
                      <div className="mb-2 mt-4 text-lg font-bold">
                        chesai-ui
                      </div>
                      <p className="text-sm leading-tight text-gray-500">
                        A modern, accessible component library for React.
                      </p>
                    </a>
                  </NavigationMenu.Link>
                </li>
                {/* Replaced old ListItem with new ContentItem */}
                <NavigationMenu.ContentItem href="#" title="Introduction">
                  Learn the basics of the library and its design principles.
                </NavigationMenu.ContentItem>
                <NavigationMenu.ContentItem href="#" title="Installation">
                  How to get started and integrate with your project.
                </NavigationMenu.ContentItem>
                <NavigationMenu.ContentItem href="#" title="Theming">
                  Customize colors, fonts, and more to match your brand.
                </NavigationMenu.ContentItem>
              </ul>
            </NavigationMenu.Content>
          </NavigationMenu.Item>
          <NavigationMenu.Item>
            <NavigationMenu.Link
              href="#"
              className={navigationMenuTriggerStyle()}
            >
              <Typography variant="small" className="font-semibold">
                Changelog
              </Typography>
            </NavigationMenu.Link>
          </NavigationMenu.Item>
        </NavigationMenu.List>
      </NavigationMenu>
    </div>
  ),
};

// --- NEW STORY ---
export const WithIconsAndAdornments: Story = {
  name: "2. With Icons and Adornments",
  parameters: {
    docs: {
      description: {
        story:
          "The new `ContentList` and `ContentItem` components make it easy to build rich, descriptive navigation menus with icons and other adornments like badges.",
      },
    },
  },
  render: () => (
    <div className="flex h-96 w-full items-start justify-center pt-12">
      <NavigationMenu>
        <NavigationMenu.List>
          <NavigationMenu.Item>
            <NavigationMenu.Trigger>Product</NavigationMenu.Trigger>
            <NavigationMenu.Content>
              {/* Use ContentList for consistent styling */}
              <NavigationMenu.ContentList
                grid="cols-2"
                className="md:w-[500px]"
              >
                <NavigationMenu.ContentItem
                  title="API Documentation"
                  startIcon={<Code size={20} />}
                  href="#"
                >
                  Access our full suite of REST and GraphQL APIs.
                </NavigationMenu.ContentItem>
                <NavigationMenu.ContentItem
                  title="Contribution Guide"
                  startIcon={<GitCommit size={20} />}
                  href="#"
                >
                  Help us improve the library by contributing.
                </NavigationMenu.ContentItem>
                <NavigationMenu.ContentItem
                  title="GitHub Repository"
                  startIcon={<Github size={20} />}
                  href="#"
                >
                  View the source code and report issues.
                </NavigationMenu.ContentItem>
                <NavigationMenu.ContentItem
                  title="Support"
                  startIcon={<LifeBuoy size={20} />}
                  href="#"
                  endAdornment={
                    <Badge variant="secondary" shape="full">
                      New
                    </Badge>
                  }
                >
                  Get help from our dedicated support team.
                </NavigationMenu.ContentItem>
              </NavigationMenu.ContentList>
            </NavigationMenu.Content>
          </NavigationMenu.Item>

          <NavigationMenu.Item>
            <NavigationMenu.Trigger>Account</NavigationMenu.Trigger>
            <NavigationMenu.Content>
              {/* A single-column list */}
              <NavigationMenu.ContentList grid="cols-1" className="w-[300px]">
                <NavigationMenu.ContentItem
                  title="Profile"
                  startIcon={<User size={16} />}
                  href="#"
                />
                <NavigationMenu.ContentItem
                  title="Settings"
                  startIcon={<Settings size={16} />}
                  href="#"
                />
                <NavigationMenu.ContentItem
                  title="Log out"
                  startIcon={<LogOut size={16} />}
                  href="#"
                />
              </NavigationMenu.ContentList>
            </NavigationMenu.Content>
          </NavigationMenu.Item>
        </NavigationMenu.List>
      </NavigationMenu>
    </div>
  ),
};
```


### Component: `otp-field`

This section contains the source code for the `otp-field` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\otp-field\index.tsx`)**
```tsx
"use client";

import clsx from "clsx";
import { OTPInput, OTPInputContext } from "input-otp";
import { Dot } from "lucide-react";
import * as React from "react";

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={clsx(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={clsx("disabled:cursor-not-allowed", className)}
    {...props}
  />
));
InputOTP.displayName = "InputOTP";

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={clsx("flex items-center", className)} {...props} />
));
InputOTPGroup.displayName = "InputOTPGroup";

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={clsx(
        // --- THEME ALIGNED STYLES ---
        "relative flex h-12 w-12 items-center justify-center border-y border-r border-graphite-border text-base font-semibold transition-all",
        "first:rounded-l-2xl first:border-l last:rounded-r-2xl", // Matches 'minimal' shape
        isActive &&
          "z-10 border-graphite-border ring-2 ring-graphite-ring ring-offset-2 ring-offset-graphite-background",
        // --- END OF THEME ALIGNED STYLES ---
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          {/* Use theme's primary color for the caret */}
          <div className="h-4 w-px animate-caret-blink bg-graphite-primary duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = "InputOTPSlot";

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    {/* Use theme's foreground color for the separator */}
    <Dot className="text-graphite-foreground" />
  </div>
));
InputOTPSeparator.displayName = "InputOTPSeparator";

export { InputOTP, InputOTPGroup, InputOTPSeparator, InputOTPSlot };
```

**Storybook Stories (`otp-field.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { Button } from "../button";
import { Typography } from "../typography";
import {
  InputOTP,
  InputOTPGroup,
  InputOTPSeparator,
  InputOTPSlot,
} from "./index";

const meta: Meta<typeof InputOTP> = {
  title: "Components/Forms & Inputs/InputOTP",
  component: InputOTP,
  subcomponents: { InputOTPGroup, InputOTPSlot, InputOTPSeparator },
  tags: ["autodocs"],
  argTypes: {
    maxLength: {
      control: "number",
      description: "The total number of characters in the OTP input.",
    },
    onComplete: {
      action: "completed",
      description: "Callback fired when all slots are filled.",
    },
    disabled: {
      control: "boolean",
    },
  },
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A flexible and accessible One-Time Password (OTP) input component, built on `input-otp` and styled for the chesai-ui theme.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof InputOTP>;

export const Default: Story = {
  name: "1. Default (6-Digit)",
  args: {
    maxLength: 6,
  },
  render: (args) => {
    const [value, setValue] = useState("");
    return (
      <div className="flex flex-col items-center gap-4">
        <Typography variant="h4">Enter Verification Code</Typography>
        {/* --- FIX: Explicitly pass props instead of spreading args --- */}
        <InputOTP
          maxLength={args.maxLength}
          disabled={args.disabled}
          value={value}
          onChange={setValue}
          onComplete={args.onComplete}
        >
          <InputOTPGroup>
            <InputOTPSlot index={0} />
            <InputOTPSlot index={1} />
            <InputOTPSlot index={2} />
            <InputOTPSlot index={3} />
            <InputOTPSlot index={4} />
            <InputOTPSlot index={5} />
          </InputOTPGroup>
        </InputOTP>
        <Typography variant="muted">Current value: {value}</Typography>
      </div>
    );
  },
};

export const WithSeparator: Story = {
  name: "2. With Separator",
  args: {
    maxLength: 6,
  },
  parameters: {
    docs: {
      description: {
        story:
          "Use the `InputOTPSeparator` component to visually group digits.",
      },
    },
  },
  render: (args) => (
    <div className="flex flex-col items-center gap-4">
      <Typography variant="h4">Enter Access Code</Typography>
      {/* --- FIX: Explicitly pass props instead of spreading args --- */}
      <InputOTP
        maxLength={args.maxLength}
        disabled={args.disabled}
        onComplete={args.onComplete}
      >
        <InputOTPGroup>
          <InputOTPSlot index={0} />
          <InputOTPSlot index={1} />
          <InputOTPSlot index={2} />
        </InputOTPGroup>
        <InputOTPSeparator />
        <InputOTPGroup>
          <InputOTPSlot index={3} />
          <InputOTPSlot index={4} />
          <InputOTPSlot index={5} />
        </InputOTPGroup>
      </InputOTP>
    </div>
  ),
};

export const ControlledWithOnComplete: Story = {
  name: "3. Controlled with onComplete",
  args: {
    maxLength: 4,
  },
  render: function Render(args) {
    const [value, setValue] = useState("");
    const [isComplete, setIsComplete] = useState(false);

    const handleComplete = (completedValue: string) => {
      // Simulate an API call
      console.log("OTP Completed:", completedValue);
      setIsComplete(true);
      // Forward the action to Storybook's actions panel
      args.onComplete?.(completedValue);
    };

    const handleReset = () => {
      setValue("");
      setIsComplete(false);
    };

    return (
      <div className="flex flex-col items-center gap-4 w-80">
        <Typography variant="h4">Enter 4-Digit PIN</Typography>
        {/* --- FIX: Explicitly pass props instead of spreading args --- */}
        <InputOTP
          maxLength={args.maxLength}
          disabled={args.disabled}
          value={value}
          onChange={setValue}
          onComplete={handleComplete}
        >
          <InputOTPGroup>
            <InputOTPSlot index={0} />
            <InputOTPSlot index={1} />
            <InputOTPSlot index={2} />
            <InputOTPSlot index={3} />
          </InputOTPGroup>
        </InputOTP>
        {isComplete ? (
          <Typography variant="p" className="text-green-600">
            Verification successful!
          </Typography>
        ) : (
          <Typography variant="muted">
            The onComplete event will fire when all digits are entered.
          </Typography>
        )}
        <Button variant="secondary" size="sm" onClick={handleReset}>
          Reset
        </Button>
      </div>
    );
  },
};
```


### Component: `pull-to-refresh`

This section contains the source code for the `pull-to-refresh` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\pull-to-refresh\index.tsx`)**
```tsx
"use client";

import { clsx } from "clsx";
import { animate, motion, useMotionValue, useTransform } from "framer-motion";
import { ArrowDown, Loader2 } from "lucide-react";
import React, { useEffect, useRef, useState } from "react";

// --- CONSTANTS ---
const PULL_THRESHOLD = 100;
const REFRESH_Y_POSITION = 160;

// --- TYPE DEFINITIONS ---
interface RefreshIndicatorProps {
  /** The current pull distance as a motion value. */
  pullProgress: ReturnType<typeof useMotionValue<number>>;
  /** Whether the component is in the "refreshing" state. */
  isRefreshing: boolean;
}

export interface PullToRefreshProps {
  children: React.ReactNode;
  onRefresh: () => Promise<unknown>;
  IndicatorComponent?: React.ComponentType<RefreshIndicatorProps>;
  pullThreshold?: number;
  className?: string;
}

// --- DEFAULT INDICATOR ---
const DefaultRefreshIndicator: React.FC<RefreshIndicatorProps> = ({
  pullProgress,
  isRefreshing,
}) => {
  const rotation = useTransform(pullProgress, [0, PULL_THRESHOLD], [0, 180]);

  return isRefreshing ? (
    <Loader2 className="h-6 w-6 animate-spin text-graphite-primary" />
  ) : (
    <motion.div style={{ rotate: rotation }}>
      <ArrowDown className="h-6 w-6 text-graphite-foreground/70" />
    </motion.div>
  );
};

// --- MAIN COMPONENT ---
export const PullToRefresh = ({
  children,
  onRefresh,
  IndicatorComponent = DefaultRefreshIndicator,
  pullThreshold = PULL_THRESHOLD,
  className,
}: PullToRefreshProps) => {
  const [isRefreshing, setIsRefreshing] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const isDraggingRef = useRef(false);
  const startTouchYRef = useRef(0);

  const y = useMotionValue(0);
  const pullProgress = useTransform(y, (v) => (v > 0 ? v : 0));

  // Dampen the pull distance for the elastic effect on the content
  const contentY = useTransform(pullProgress, (v) => v * 0.4);
  const indicatorOpacity = useTransform(
    pullProgress,
    [0, pullThreshold * 0.75],
    [0, 1]
  );
  const indicatorScale = useTransform(
    pullProgress,
    [pullThreshold * 0.5, pullThreshold],
    [0.5, 1]
  );

  const handleTouchStart = (event: TouchEvent): void => {
    if (isRefreshing) return;

    const container = containerRef.current;
    if (!container) return;

    // Only start if we're at the top and touching with a single finger
    if (container.scrollTop === 0 && event.touches.length === 1) {
      startTouchYRef.current = event.touches[0].clientY;
      isDraggingRef.current = true;
    }
  };

  const handleTouchMove = (event: TouchEvent): void => {
    if (!isDraggingRef.current || isRefreshing) return;

    const touch = event.touches[0];
    if (!touch) return;

    const currentY = touch.clientY;
    const deltaY = currentY - startTouchYRef.current;

    // Only handle downward pulls
    if (deltaY > 0) {
      // Prevent default scroll behavior when pulling down
      event.preventDefault();

      // Apply some resistance to make it feel natural
      const resistance = Math.min(deltaY * 0.6, pullThreshold * 1.2);
      y.set(resistance);
    } else {
      // If pulling up, reset and allow normal scrolling
      isDraggingRef.current = false;
      y.set(0);
    }
  };

  const handleTouchEnd = async (): Promise<void> => {
    if (!isDraggingRef.current || isRefreshing) return;

    isDraggingRef.current = false;
    const currentY = y.get();

    if (currentY >= pullThreshold) {
      setIsRefreshing(true);
      animate(y, REFRESH_Y_POSITION, {
        type: "spring",
        stiffness: 300,
        damping: 30,
      });

      try {
        await onRefresh();
      } finally {
        setIsRefreshing(false);
        animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
      }
    } else {
      animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
    }
  };

  // Mouse events for desktop support
  const handleMouseDown = (event: MouseEvent): void => {
    if (isRefreshing) return;

    const container = containerRef.current;
    if (!container) return;

    if (container.scrollTop === 0) {
      startTouchYRef.current = event.clientY;
      isDraggingRef.current = true;
    }
  };

  const handleMouseMove = (event: MouseEvent): void => {
    if (!isDraggingRef.current || isRefreshing) return;

    const currentY = event.clientY;
    const deltaY = currentY - startTouchYRef.current;

    if (deltaY > 0) {
      event.preventDefault();
      const resistance = Math.min(deltaY * 0.6, pullThreshold * 1.2);
      y.set(resistance);
    } else {
      isDraggingRef.current = false;
      y.set(0);
    }
  };

  const handleMouseUp = async (): Promise<void> => {
    if (!isDraggingRef.current || isRefreshing) return;

    isDraggingRef.current = false;
    const currentY = y.get();

    if (currentY >= pullThreshold) {
      setIsRefreshing(true);
      animate(y, REFRESH_Y_POSITION, {
        type: "spring",
        stiffness: 300,
        damping: 30,
      });

      try {
        await onRefresh();
      } finally {
        setIsRefreshing(false);
        animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
      }
    } else {
      animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
    }
  };

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // Add touch event listeners
    container.addEventListener("touchstart", handleTouchStart, {
      passive: false,
    });
    container.addEventListener("touchmove", handleTouchMove, {
      passive: false,
    });
    container.addEventListener("touchend", handleTouchEnd, { passive: true });

    // Add mouse event listeners for desktop
    container.addEventListener("mousedown", handleMouseDown);

    // Mouse move and up need to be on document to handle cases where
    // the mouse moves outside the container
    const handleDocumentMouseMove = (event: MouseEvent) =>
      handleMouseMove(event);
    const handleDocumentMouseUp = () => handleMouseUp();

    document.addEventListener("mousemove", handleDocumentMouseMove);
    document.addEventListener("mouseup", handleDocumentMouseUp);

    return () => {
      container.removeEventListener("touchstart", handleTouchStart);
      container.removeEventListener("touchmove", handleTouchMove);
      container.removeEventListener("touchend", handleTouchEnd);
      container.removeEventListener("mousedown", handleMouseDown);
      document.removeEventListener("mousemove", handleDocumentMouseMove);
      document.removeEventListener("mouseup", handleDocumentMouseUp);
    };
  }, [isRefreshing]);

  return (
    <div
      className={clsx(
        "relative w-full h-full overflow-hidden bg-graphite-background",
        className
      )}
    >
      {/* Indicator */}
      <motion.div
        className="absolute inset-x-0 top-[-50px] z-10 flex justify-center pt-4"
        style={{
          opacity: indicatorOpacity,
          scale: indicatorScale,
          y: contentY,
        }}
      >
        <div className="flex h-10 w-10 items-center justify-center rounded-full bg-graphite-card shadow-md">
          <IndicatorComponent
            pullProgress={pullProgress}
            isRefreshing={isRefreshing}
          />
        </div>
      </motion.div>

      {/* Scrollable Content */}
      <motion.div
        ref={containerRef}
        style={{
          y: contentY,
          // Remove touch-action to allow our custom handling
        }}
        className="absolute inset-0 z-0 h-full overflow-y-auto"
      >
        {children}
      </motion.div>
    </div>
  );
};
```

**Storybook Stories (`pull-to-refresh.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { motion, useTransform, type MotionValue } from "framer-motion";
import { Sun } from "lucide-react";
import { Typography } from "../typography";
import { PullToRefresh } from "./index";

const meta: Meta<typeof PullToRefresh> = {
  title: "Components/PullToRefresh",
  component: PullToRefresh,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "An elastic pull-to-refresh component built with Framer Motion's pan gesture. It wraps scrollable content and triggers an async `onRefresh` action. Requires a container with a defined height.",
      },
    },
  },
  argTypes: {
    onRefresh: { action: "refreshed" },
    pullThreshold: {
      control: { type: "range", min: 50, max: 200, step: 10 },
    },
    children: { control: false },
    IndicatorComponent: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof PullToRefresh>;

// Helper component to generate scrollable content
const DummyContent = () => (
  <main className="p-6 pt-4">
    <Typography variant="h3">Pull Down to Refresh</Typography>
    <Typography variant="muted">
      This container is scrollable. The pull gesture only works when you are at
      the very top.
    </Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
      {Array.from({ length: 30 }).map((_, i) => (
        <div key={i} className="h-24 rounded-2xl bg-graphite-secondary" />
      ))}
    </div>
  </main>
);

// A mock async function for the onRefresh prop
const simulateRefresh = () => {
  return new Promise((resolve) => setTimeout(resolve, 2000));
};

export const Default: Story = {
  name: "1. Default Behavior",
  args: {
    onRefresh: simulateRefresh,
    pullThreshold: 100,
  },
  render: (args) => (
    <div className="w-96 h-[600px] rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
      <PullToRefresh {...args}>
        <DummyContent />
      </PullToRefresh>
    </div>
  ),
};

// --- Custom Indicator Example ---

interface CustomIndicatorProps {
  pullProgress: MotionValue<number>;
  isRefreshing: boolean;
}

const CustomWeatherIndicator = ({
  pullProgress,
  isRefreshing,
}: CustomIndicatorProps) => {
  // Use the motion value passed from the parent for transforms
  const rotation = useTransform(pullProgress, [0, 150], [0, 360]);

  return (
    <motion.div style={{ rotate: rotation }}>
      <Sun
        className={
          isRefreshing
            ? "h-6 w-6 text-yellow-500 animate-spin"
            : "h-6 w-6 text-yellow-500"
        }
      />
    </motion.div>
  );
};

export const CustomIndicator: Story = {
  name: "2. With a Custom Indicator",
  args: {
    ...Default.args,
    IndicatorComponent: CustomWeatherIndicator,
    pullThreshold: 150,
  },
  parameters: {
    docs: {
      description: {
        story:
          "You can pass any component to the `IndicatorComponent` prop. It will receive `pullProgress` (a MotionValue) and `isRefreshing` props, allowing you to create custom, fluid animations.",
      },
    },
  },
  render: (args) => (
    <div className="w-96 h-[600px] rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
      <PullToRefresh {...args}>
        <DummyContent />
      </PullToRefresh>
    </div>
  ),
};
```


### Component: `radio-group`

This section contains the source code for the `radio-group` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\radio-group\index.tsx`)**
```tsx
import React from "react";
import { clsx } from "clsx";

// --- Individual Radio Item ---
export interface RadioGroupItemProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  value?: string; // Added explicit value prop
}

const RadioGroupItem = React.forwardRef<HTMLInputElement, RadioGroupItemProps>(
  ({ className, id, label, ...props }, ref) => {
    const uniqueId = React.useId();
    const radioId = id || uniqueId;

    return (
      <div className="inline-flex items-center">
        <div className="relative flex h-5 w-5 items-center justify-center">
          <input
            type="radio"
            ref={ref}
            id={radioId}
            className={clsx(
              "peer h-5 w-5 shrink-0 appearance-none rounded-full border-2 transition-colors duration-200",
              // Unchecked state
              "border-graphite-border",
              // Checked state
              "checked:border-graphite-primary",
              // Focus state
              "focus:outline-none focus:ring-2 focus:ring-graphite-ring focus:ring-offset-2",
              // Disabled state
              "disabled:cursor-not-allowed disabled:opacity-50 disabled:checked:border-graphite-border",
              className
            )}
            {...props}
          />
          {/* The Inner Dot */}
          <div
            className={clsx(
              "pointer-events-none absolute h-2.5 w-2.5 rounded-full bg-graphite-primary",
              "transition-transform duration-200 ease-in-out transform scale-0 peer-checked:scale-100"
            )}
          />
        </div>
        {label && (
          <label
            htmlFor={radioId}
            className="ml-3 select-none text-sm font-medium text-graphite-foreground"
          >
            {label}
          </label>
        )}
      </div>
    );
  }
);
RadioGroupItem.displayName = "RadioGroup.Item";

// --- Radio Group Container ---
interface RadioGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  label?: string;
  value?: string;
  onValueChange?: (value: string) => void;
  name?: string;
  disabled?: boolean;
}

const RadioGroup = React.forwardRef<HTMLDivElement, RadioGroupProps>(
  (
    {
      className,
      label,
      children,
      value,
      onValueChange,
      name,
      disabled,
      ...props
    },
    ref
  ) => {
    const uniqueId = React.useId();
    const groupName = name || uniqueId;
    const labelId = `radiogroup-label-${uniqueId}`;

    return (
      <div className="flex flex-col gap-2">
        {label && (
          <div
            id={labelId}
            className="mb-2 block text-sm font-medium text-graphite-primary"
          >
            {label}
          </div>
        )}
        <div
          ref={ref}
          role="radiogroup"
          aria-labelledby={label ? labelId : undefined}
          className={clsx("flex flex-col gap-3", className)}
          {...props}
        >
          {React.Children.map(children, (child) => {
            if (!React.isValidElement<RadioGroupItemProps>(child)) return child;

            // Inject props into each RadioGroup.Item
            return React.cloneElement(child, {
              name: groupName,
              checked: child.props.value === value,
              disabled: disabled || child.props.disabled,
              onChange: (e: React.ChangeEvent<HTMLInputElement>) => {
                onValueChange?.(e.currentTarget.value);
                child.props.onChange?.(e);
              },
            });
          })}
        </div>
      </div>
    );
  }
);
RadioGroup.displayName = "RadioGroup";

// Export as a compound component
const Radio = Object.assign(RadioGroup, { Item: RadioGroupItem });
export { Radio, RadioGroup, RadioGroupItem };
```

**Storybook Stories (`Radio-group.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { Radio } from "./index";

const meta: Meta<typeof Radio> = {
  title: "Components/Forms & Inputs/RadioGroup",
  component: Radio,
  tags: ["autodocs"],
  argTypes: {
    label: { control: "text" },
    disabled: { control: "boolean" },
  },
  // We render the group with items for all stories
  render: (args) => {
    const [plan, setPlan] = useState("basic");

    return (
      <Radio {...args} value={plan} onValueChange={setPlan}>
        <Radio.Item value="basic" label="Basic" />
        <Radio.Item value="premium" label="Premium" />
        <Radio.Item value="enterprise" label="Enterprise (Disabled)" disabled />
      </Radio>
    );
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  name: "Interactive",
  args: {
    label: "Select a Plan",
  },
};

export const Disabled: Story = {
  name: "Disabled Group",
  args: {
    label: "This entire group is disabled",
    disabled: true,
  },
};
```


### Component: `select`

This section contains the source code for the `select` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\select\index.tsx`)**
```tsx
"use client";

import * as SelectPrimitive from "@radix-ui/react-select";
import { useMediaQuery } from "@uidotdev/usehooks";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { Check, ChevronDown } from "lucide-react";
import React, { createContext, useContext, useRef, useState } from "react";
import useRipple from "use-ripple-hook";
import { Button } from "../button";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "../dialog";

// --- CONTEXT ---
interface SelectContextProps {
  variant: "primary" | "secondary";
  shape: "full" | "minimal" | "sharp";
  size: "sm" | "md" | "lg";
}

const SelectContext = createContext<SelectContextProps>({
  variant: "primary",
  shape: "minimal",
  size: "md",
});

const useSelectContext = () => useContext(SelectContext);

// --- CVA VARIANTS ---
const selectTriggerVariants = cva(
  "flex items-center justify-between transition-all duration-200 w-full px-4 border-2 text-left",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
      size: {
        sm: "h-10 text-sm",
        md: "h-12 text-base",
        lg: "h-14 text-lg",
      },
      isErrored: { true: "" },
      disabled: {
        true: "bg-graphite-secondary opacity-50 cursor-not-allowed",
      },
    },
    compoundVariants: [
      {
        variant: "primary",
        isErrored: false,
        className:
          "border-graphite-border data-[state=open]:border-graphite-primary",
      },
      {
        variant: "secondary",
        isErrored: false,
        className:
          "border-transparent data-[state=open]:border-graphite-primary",
      },
      {
        isErrored: true,
        className: "border-red-500 data-[state=open]:border-red-600",
      },
    ],
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
      size: "md",
    },
  }
);

const selectContentVariants = cva(
  "relative z-50 min-w-[8rem] overflow-hidden border shadow-md",
  {
    variants: {
      variant: {
        primary:
          "bg-graphite-card text-graphite-foreground border-graphite-border",
        secondary:
          "bg-graphite-secondary text-graphite-secondaryForeground border-transparent",
      },
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
    },
  }
);

const selectItemVariants = cva(
  "relative flex w-full cursor-pointer select-none items-center rounded-lg pr-2 pl-8 outline-none overflow-hidden transition-colors duration-150 ease-in-out data-[highlighted]:bg-graphite-secondary/80 focus:bg-graphite-secondary/80 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
  {
    variants: {
      size: {
        sm: "py-2 text-sm",
        md: "py-2 text-base",
        lg: "py-2.5 text-lg",
      },
      shape: {
        full: "",
        minimal: "",
        sharp: "!rounded-none",
      },
    },
    defaultVariants: {
      size: "md",
    },
  }
);

// --- PRIMITIVE COMPONENTS (For Desktop Popover) ---

const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value;

interface SelectProps extends SelectPrimitive.SelectProps {
  children: React.ReactNode;
  variant?: SelectContextProps["variant"];
  shape?: SelectContextProps["shape"];
  size?: SelectContextProps["size"];
}

const Select: React.FC<SelectProps> = ({
  children,
  variant = "primary",
  shape = "minimal",
  size = "md",
  ...props
}) => {
  return (
    <SelectContext.Provider value={{ variant, shape, size }}>
      <SelectPrimitive.Root {...props}>{children}</SelectPrimitive.Root>
    </SelectContext.Provider>
  );
};

interface SelectTriggerProps
  extends React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger> {
  error?: string;
  variant?: "primary" | "secondary";
  shape?: "full" | "minimal" | "sharp";
  size?: "sm" | "md" | "lg";
}

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  SelectTriggerProps
>(
  (
    { className, children, variant, shape, size, error, disabled, ...props },
    ref
  ) => {
    const context = useSelectContext();
    return (
      <SelectPrimitive.Trigger
        ref={ref}
        disabled={disabled}
        className={selectTriggerVariants({
          variant: variant || context.variant,
          shape: shape || context.shape,
          size,
          isErrored: !!error,
          disabled,
          className,
        })}
        {...props}
      >
        {children}
        <SelectPrimitive.Icon asChild>
          <ChevronDown className="h-4 w-4 opacity-50" />
        </SelectPrimitive.Icon>
      </SelectPrimitive.Trigger>
    );
  }
);
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "item-aligned", ...props }, ref) => {
  const { variant, shape } = useSelectContext();
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        ref={ref}
        className={clsx(
          selectContentVariants({ variant, shape }),
          position === "popper"
            ? "data-[state=open]:animate-menu-enter data-[state=closed]:animate-menu-exit w-[var(--radix-select-trigger-width)]"
            : "data-[state=open]:animate-select-enter data-[state=closed]:animate-select-exit",
          "data-[side=bottom]:origin-top data-[side=top]:origin-bottom ",
          className
        )}
        position={position}
        {...props}
      >
        <SelectPrimitive.Viewport
          className={clsx(
            "p-1",
            // Only apply max-height and fade mask for popper position (which supports scrolling)
            position === "popper" && [
              "max-h-64",
              "[mask-image:linear-gradient(to_bottom,transparent,black_1rem,black_calc(100%-1rem),transparent)]",
            ],
            position === "popper" && "w-full"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
});
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => {
  const { shape, variant, size } = useSelectContext();
  const localRef = useRef<HTMLDivElement>(null);
  const rippleColor =
    variant === "primary" ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)";

  const [, event] = useRipple({
    ref: localRef,
    color: rippleColor,
    duration: 400,
    disabled: props.disabled,
  });

  React.useImperativeHandle(ref, () => localRef.current as HTMLDivElement);

  return (
    <SelectPrimitive.Item
      ref={localRef}
      onPointerDown={event}
      className={clsx(selectItemVariants({ size, shape }), className)}
      {...props}
    >
      <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <Check className="h-4 w-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText className="truncate">
        {children}
      </SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
});
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => {
  const { size } = useSelectContext();
  return (
    <SelectPrimitive.Label
      ref={ref}
      className={clsx(
        "py-1.5 pl-8 pr-2 font-semibold",
        {
          "text-sm": size === "sm",
          "text-base": size === "md",
          "text-lg": size === "lg",
        },
        className
      )}
      {...props}
    />
  );
});
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={clsx("-mx-1 my-1 h-px bg-graphite-border", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

// --- HELPER COMPONENT FOR MOBILE DIALOG ITEMS ---
interface DialogSelectItemProps {
  item: { value: string; label: string; disabled?: boolean };
  isSelected: boolean;
  onSelect: (value: string) => void;
  variant: "primary" | "secondary";
}

const DialogSelectItem: React.FC<DialogSelectItemProps> = ({
  item,
  isSelected,
  onSelect,
  variant,
}) => {
  const localRef = useRef<HTMLButtonElement>(null);
  const rippleColor =
    variant === "primary" ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)";

  const [, event] = useRipple({
    ref: localRef,
    color: rippleColor,
    duration: 400,
    disabled: item.disabled,
  });

  return (
    <button
      ref={localRef}
      type="button"
      onPointerDown={event}
      disabled={item.disabled}
      onClick={() => onSelect(item.value)}
      className={clsx(
        "relative flex w-full cursor-pointer select-none items-center rounded-lg py-3 pl-8 pr-2 text-left text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-in-out",
        "focus:bg-graphite-secondary/80",
        isSelected && "font-semibold text-graphite-primary",
        "disabled:pointer-events-none disabled:opacity-50"
      )}
    >
      <span className="relative z-10 flex items-center w-full">
        {isSelected && (
          <span className="absolute -left-6 flex h-3.5 w-3.5 items-center justify-center">
            <Check className="h-4 w-4" />
          </span>
        )}
        <span className="truncate">{item.label}</span>
      </span>
    </button>
  );
};

// --- MAIN WRAPPER COMPONENT ---

interface SelectWrapperProps
  extends Omit<SelectProps, "children" | "onChange"> {
  variant?: "primary" | "secondary";
  shape?: "full" | "minimal" | "sharp";
  size?: "sm" | "md" | "lg";
  label?: string;
  error?: string;
  placeholder?: string;
  items: { value: string; label: string; disabled?: boolean }[];
  id?: string;
  contentPosition?: React.ComponentProps<typeof SelectContent>["position"];
  onValueChange?: (value: string) => void;
  value?: string;
}

const SelectInput = React.forwardRef<HTMLButtonElement, SelectWrapperProps>(
  (
    {
      label,
      error,
      placeholder,
      items,
      id,
      variant = "primary",
      shape = "minimal",
      size = "md",
      disabled,
      contentPosition = "item-aligned",
      value,
      onValueChange,
      ...props
    },
    ref
  ) => {
    const isMobile = useMediaQuery("(max-width: 768px)");
    const uniqueId = React.useId();
    const [isOpen, setIsOpen] = useState(false);
    const [tempValue, setTempValue] = useState(value);
    const selectId = id || uniqueId;

    // --- Mobile Dialog Version ---
    if (isMobile && contentPosition === "popper") {
      const handleOpenChange = (open: boolean) => {
        if (open) {
          setTempValue(value);
        }
        setIsOpen(open);
      };

      const handleConfirm = () => {
        if (tempValue !== undefined) {
          onValueChange?.(tempValue);
        }
        setIsOpen(false);
      };

      const displayLabel =
        items.find((item) => item.value === value)?.label || placeholder;

      return (
        <div className="w-full flex flex-col gap-2">
          {label && (
            <div className="block text-sm font-medium text-graphite-primary">
              {label}
            </div>
          )}
          <Dialog open={isOpen} onOpenChange={handleOpenChange}>
            <DialogTrigger asChild>
              <button
                ref={ref}
                type="button"
                id={selectId}
                disabled={disabled}
                className={selectTriggerVariants({
                  variant,
                  shape,
                  size,
                  isErrored: !!error,
                  disabled,
                })}
              >
                <span className="truncate">{displayLabel}</span>
                <ChevronDown className="h-4 w-4 opacity-50" />
              </button>
            </DialogTrigger>
            <DialogContent
              shape={shape}
              className="fixed bottom-0 m-0 w-full max-w-full rounded-b-none rounded-t-2xl p-4"
            >
              <DialogHeader className="text-left">
                <DialogTitle>{label || placeholder}</DialogTitle>
              </DialogHeader>
              <div
                className={clsx(
                  "mt-4 max-h-[40vh] overflow-y-auto ",
                  "[mask-image:linear-gradient(to_bottom,transparent,black_1rem,black_calc(100%-1rem),transparent)]"
                )}
              >
                {items.map((item) => (
                  <DialogSelectItem
                    key={item.value}
                    item={item}
                    isSelected={tempValue === item.value}
                    onSelect={setTempValue}
                    variant={variant}
                  />
                ))}
              </div>
              <DialogFooter className="flex justify-end gap-4">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setIsOpen(false)}
                >
                  Cancel
                </Button>
                <Button size="sm" variant="primary" onClick={handleConfirm}>
                  Done
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
          {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
        </div>
      );
    }

    // --- Desktop Popover / Item-Aligned Version ---
    return (
      <div className="w-full flex flex-col gap-2">
        {label && (
          <label
            htmlFor={selectId}
            className="block text-sm font-medium text-graphite-primary"
          >
            {label}
          </label>
        )}
        <Select
          disabled={disabled}
          variant={variant}
          shape={shape}
          size={size}
          value={value}
          onValueChange={onValueChange}
          {...props}
        >
          <SelectTrigger
            id={selectId}
            ref={ref}
            size={size}
            error={error}
            disabled={disabled}
          >
            <span className="truncate">
              <SelectValue placeholder={placeholder} />
            </span>
          </SelectTrigger>
          <SelectContent position={contentPosition}>
            {items.map((item) => (
              <SelectItem
                key={item.value}
                value={item.value}
                disabled={item.disabled}
              >
                {item.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);
SelectInput.displayName = "SelectInput";

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectInput,
  SelectItem,
  SelectLabel,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};
```

**Storybook Stories (`Select.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { SelectInput } from "./index";

const meta: Meta<typeof SelectInput> = {
  title: "Components/Forms & Inputs/Select",
  component: SelectInput,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    label: { control: "text" },
    placeholder: { control: "text" },
    disabled: { control: "boolean" },
    error: { control: "text" },
    contentPosition: {
      control: "select",
      options: ["item-aligned", "popper"],
      description: "Controls the positioning and animation of the dropdown.",
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

const fruitItems = [
  {
    value: "apple loremfwekfkweiofkjweifjwoeifoifwejfiowejfiowejfowiejfwi",
    label: "Apple loremfwekfkweiofkjweifjwoeifoifwejfiowejfiowejfowiejfwi",
  },
  { value: "banana", label: "Banana" },
  { value: "blueberry", label: "Blueberry" },
  { value: "grapes", label: "Grapes" },
  { value: "pineapple", label: "Pineapple", disabled: true },
  { value: "strawberry", label: "Strawberry" },
  { value: "orange", label: "Orange" },
  { value: "mango", label: "Mango" },
  { value: "kiwi", label: "Kiwi" },
  { value: "peach", label: "Peach" },
  { value: "pear", label: "Pear" },
  { value: "watermelon", label: "Watermelon" },
  { value: "cherry", label: "Cherry" },
  { value: "raspberry", label: "Raspberry" },
  { value: "lemon", label: "Lemon" },
];
export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
    size: "md",
    label: "Favorite Fruit",
    placeholder: "Select a fruit...",
    items: fruitItems,
    contentPosition: "item-aligned", // Default
  },
  render: (args) => {
    const [value, setValue] = useState("");
    return <SelectInput {...args} value={value} onValueChange={setValue} />;
  },
};

export const PopperPosition: Story = {
  name: "Popper Position",
  args: {
    ...Default.args,
    label: "Popper Positioned Select",
    placeholder: "Select a fruit...",
    contentPosition: "popper",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `contentPosition` is set to `popper`, the content detaches and uses a scale/fade animation, similar to a dropdown menu.",
      },
    },
  },
  render: (args) => {
    const [value, setValue] = useState("");
    return <SelectInput {...args} value={value} onValueChange={setValue} />;
  },
};

// ... keep your other stories like AllSizes, AllVariantsAndShapes, and AllStates
export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-col gap-6 max-w-sm">
      <SelectInput
        size="sm"
        label="Small"
        placeholder="Select size..."
        items={fruitItems}
      />
      <SelectInput
        size="md"
        label="Medium (Default)"
        placeholder="Select size..."
        items={fruitItems}
      />
      <SelectInput
        size="lg"
        label="Large"
        placeholder="Select size..."
        items={fruitItems}
      />
    </div>
  ),
};

export const AllVariantsAndShapes: Story = {
  name: "All Variants & Shapes",
  render: () => (
    <div className="flex flex-col gap-8 max-w-sm">
      <div>
        <h3 className="font-bold mb-4">Primary Variant</h3>
        <div className="flex flex-col gap-4">
          <SelectInput
            variant="primary"
            shape="full"
            placeholder="Full Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="primary"
            shape="minimal"
            placeholder="Minimal Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="primary"
            shape="sharp"
            placeholder="Sharp Shape"
            items={fruitItems}
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary Variant</h3>
        <div className="flex flex-col gap-4">
          <SelectInput
            variant="secondary"
            shape="full"
            placeholder="Full Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="secondary"
            shape="minimal"
            placeholder="Minimal Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="secondary"
            shape="sharp"
            placeholder="Sharp Shape"
            items={fruitItems}
          />
        </div>
      </div>
    </div>
  ),
};

export const AllStates: Story = {
  name: "All States",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl">
      <div className="flex flex-col gap-4">
        <h3 className="font-bold mb-2">Primary States</h3>
        <SelectInput
          variant="primary"
          label="Default"
          placeholder="Select..."
          items={fruitItems}
        />
        <SelectInput
          variant="primary"
          label="With Value"
          defaultValue="apple"
          items={fruitItems}
        />
        <SelectInput
          variant="primary"
          label="Error State"
          error="Please select a fruit."
          items={fruitItems}
        />
        <SelectInput
          variant="primary"
          label="Disabled"
          placeholder="Cannot select"
          disabled
          items={fruitItems}
        />
      </div>
      <div className="flex flex-col gap-4">
        <h3 className="font-bold mb-2">Secondary States</h3>
        <SelectInput
          variant="secondary"
          label="Default"
          placeholder="Select..."
          items={fruitItems}
        />
        <SelectInput
          variant="secondary"
          label="With Value"
          defaultValue="banana"
          items={fruitItems}
        />
        <SelectInput
          variant="secondary"
          label="Error State"
          error="Please select a fruit."
          items={fruitItems}
        />
        <SelectInput
          variant="secondary"
          label="Disabled"
          placeholder="Cannot select"
          disabled
          items={fruitItems}
        />
      </div>
    </div>
  ),
};
```


### Component: `shallow-router`

This section contains the source code for the `shallow-router` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\shallow-router\index.tsx`)**
```tsx
import React, {
  createContext,
  type HTMLAttributes,
  type ReactNode,
  useContext,
  useMemo,
} from "react";
import useShallowRouter from "../../hooks/useShallowRouter";

// --- TYPE DEFINITIONS ---

type RouterMode = "search" | "pathname";

interface RouterOptions {
  mode: RouterMode;
  paramName: string;
  basePath: string;
}

interface ShallowRouterContextType {
  router: ReturnType<typeof useShallowRouter>;
  options: RouterOptions;
}

// --- CONTEXT CREATION & HOOKS ---

const ShallowRouterContext = createContext<ShallowRouterContextType | null>(
  null
);

/**
 * A custom hook to consume the ShallowRouter context.
 * Provides access to routing functions like `push`, `replace`, and the current `path`.
 *
 * @returns {ReturnType<typeof useShallowRouter>} The router instance.
 * @throws {Error} If used outside of a `<ShallowRouter>` provider.
 */
export const useRouter = (): ReturnType<typeof useShallowRouter> => {
  const context = useContext(ShallowRouterContext);
  if (!context) {
    throw new Error("useRouter must be used within a <ShallowRouter> provider");
  }
  return context.router;
};

/**
 * A custom hook to access the configuration options of the nearest ShallowRouter provider.
 * Useful for components that need to behave differently based on the routing mode.
 *
 * @returns {RouterOptions} The router's configuration options.
 * @throws {Error} If used outside of a `<ShallowRouter>` provider.
 */
export const useRouterOptions = (): RouterOptions => {
  const context = useContext(ShallowRouterContext);
  if (!context) {
    throw new Error(
      "useRouterOptions must be used within a <ShallowRouter> provider"
    );
  }
  return context.options;
};

// --- MAIN PROVIDER COMPONENT ---

interface ShallowRouterProps {
  children: ReactNode;
  mode?: RouterMode;
  paramName?: string;
  basePath?: string;
}

/**
 * A provider component that initializes the shallow router and makes its
 * state and methods available to all descendant components.
 */
export const ShallowRouter: React.FC<ShallowRouterProps> = ({
  children,
  mode = "search",
  paramName = "path",
  basePath = "/",
}) => {
  const router = useShallowRouter({ mode, paramName, basePath });
  const options = useMemo(
    () => ({ mode, paramName, basePath }),
    [mode, paramName, basePath]
  );

  const contextValue = useMemo(() => ({ router, options }), [router, options]);

  return (
    <ShallowRouterContext.Provider value={contextValue}>
      {children}
    </ShallowRouterContext.Provider>
  );
};

// --- NEW: ShallowRoute Component ---
interface ShallowRouteProps {
  /** The path to match. Supports a trailing wildcard `*` for prefix matching. */
  path: string;
  children: ReactNode;
}

/**
 * Conditionally renders its children only when its `path` prop matches the current router path.
 * Supports a trailing wildcard `*` for prefix matching (e.g., `/users/*`).
 */
export const ShallowRoute: React.FC<ShallowRouteProps> = ({
  path,
  children,
}) => {
  const { path: currentPath } = useRouter();

  const isWildcard = path.endsWith("/*");
  const basePath = isWildcard ? path.slice(0, -2) : path;

  const isActive = isWildcard
    ? currentPath.startsWith(basePath)
    : currentPath === path;

  return isActive ? <>{children}</> : null;
};

// --- NEW: ShallowPage Component ---
interface ShallowPageProps extends HTMLAttributes<HTMLDivElement> {
  /** The path that this page corresponds to. Used by `ShallowSwitch` to identify the active page. */
  path: string;
}

/**
 * A simple container for a page's content.
 * It should be used as a direct child of `ShallowSwitch`.
 */
export const ShallowPage = React.forwardRef<HTMLDivElement, ShallowPageProps>(
  ({ children, path, ...props }, ref) => {
    return (
      <div ref={ref} key={path} {...props}>
        {children}
      </div>
    );
  }
);
ShallowPage.displayName = "ShallowPage";

// --- NEW: ShallowSwitch Component ---
interface ShallowSwitchProps {
  children:
    | React.ReactElement<ShallowPageProps>
    | React.ReactElement<ShallowPageProps>[];
}

/**
 * Manages rendering `<ShallowPage>` components. It identifies the active
 * page based on the current route and renders only that page.
 */
export const ShallowSwitch: React.FC<ShallowSwitchProps> = ({ children }) => {
  const { path } = useRouter();

  const pages = React.Children.toArray(children).filter(
    (child): child is React.ReactElement<ShallowPageProps> =>
      React.isValidElement(child) && child.type === ShallowPage
  );

  const activePage = pages.find((page) => page.props.path === path) || null;

  return <>{activePage}</>;
};
```

**Storybook Stories (`Shallow-router.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { ArrowLeft } from "lucide-react";
import { Button } from "../button";
import { ButtonGroup } from "../button-group";
import { Card } from "../card";
import { IconButton } from "../icon-button";
import { Typography } from "../typography";
import {
  ShallowPage,
  ShallowRoute,
  ShallowRouter,
  ShallowSwitch,
  useRouter,
  useRouterOptions,
} from "./index";

const meta: Meta<typeof ShallowRouter> = {
  title: "Components/Navigators/ShallowRouter",
  component: ShallowRouter,
  subcomponents: { ShallowRoute, ShallowSwitch, ShallowPage },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A provider for the `useShallowRouter` hook. It enables shallow, client-side navigation using either URL search parameters or the URL pathname, without causing a full page reload. It also includes declarative components like `<ShallowRoute>`, `<ShallowSwitch>`, and `<ShallowPage>` for building navigable UIs.",
      },
    },
  },
  argTypes: {
    mode: {
      control: "select",
      options: ["search", "pathname"],
    },
    paramName: {
      control: "text",
      if: { arg: "mode", eq: "search" },
    },
    basePath: {
      control: "text",
      if: { arg: "mode", eq: "pathname" },
    },
  },
};

export default meta;
type Story = StoryObj<typeof ShallowRouter>;

// --- Demo Components ---

const NavBar = () => {
  const { path, push } = useRouter();
  const { mode } = useRouterOptions();

  return (
    <div className="mb-4 p-4 bg-gray-100 rounded-xl">
      <Typography variant="small" className="font-bold mb-2">
        Navigation (mode: {mode})
      </Typography>
      <ButtonGroup shape="minimal">
        <Button
          size="sm"
          variant={path === "/" ? "primary" : "secondary"}
          onClick={() => push("/")}
        >
          Home
        </Button>
        <Button
          size="sm"
          variant={path === "/profile" ? "primary" : "secondary"}
          onClick={() => push("/profile")}
        >
          Profile
        </Button>
        <Button
          size="sm"
          variant={path === "/settings" ? "primary" : "secondary"}
          onClick={() => push("/settings")}
        >
          Settings
        </Button>
      </ButtonGroup>
    </div>
  );
};

const Header = ({ title }: { title: string }) => {
  const { path, goBack } = useRouter();
  return (
    <div className="flex items-center gap-2 mb-4">
      {path !== "/" && (
        <IconButton
          variant="ghost"
          size="sm"
          onClick={goBack}
          aria-label="Go back"
        >
          <ArrowLeft />
        </IconButton>
      )}
      <Typography variant="h4">{title}</Typography>
    </div>
  );
};

// --- Stories ---

export const BasicRouting: Story = {
  name: "1. Basic Routing with <ShallowRoute>",
  args: {
    mode: "search",
  },
  render: (args) => (
    <ShallowRouter {...args}>
      <Card className="w-96">
        <NavBar />
        <div className="mt-4">
          <ShallowRoute path="/">
            <Typography variant="large">Welcome Home!</Typography>
            <Typography variant="p">
              This content is rendered when the path is exactly `/`.
            </Typography>
          </ShallowRoute>
          <ShallowRoute path="/profile">
            <Typography variant="large">User Profile</Typography>
            <Typography variant="p">
              This is the user's profile page content.
            </Typography>
          </ShallowRoute>
          <ShallowRoute path="/settings">
            <Typography variant="large">Application Settings</Typography>
            <Typography variant="p">
              Adjust your application settings here.
            </Typography>
          </ShallowRoute>
        </div>
      </Card>
    </ShallowRouter>
  ),
};

export const PageSwitching: Story = {
  name: "2. Page Switching with <ShallowSwitch>",
  args: {
    mode: "search",
    paramName: "view",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `<ShallowSwitch>` component manages a collection of `<ShallowPage>` components. It ensures only the active page is rendered, switching instantly as the route changes.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter {...args}>
      <Card className="w-96 h-80 flex flex-col">
        <NavBar />
        <div className="flex-1 relative">
          <ShallowSwitch>
            <ShallowPage path="/">
              <Header title="Home" />
              <Typography variant="p">
                This is the main landing page. Navigate to other sections using
                the buttons above.
              </Typography>
            </ShallowPage>
            <ShallowPage path="/profile">
              <Header title="Profile" />
              <Typography variant="p">
                Here you can view and edit your profile details. All changes are
                saved automatically.
              </Typography>
            </ShallowPage>
            <ShallowPage path="/settings">
              <Header title="Settings" />
              <Typography variant="p">
                Customize your experience. Toggle notifications, change your
                theme, and set your language.
              </Typography>
            </ShallowPage>
          </ShallowSwitch>
        </div>
      </Card>
    </ShallowRouter>
  ),
};
```


### Component: `sheet`

This section contains the source code for the `sheet` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\sheet\index.tsx`)**
```tsx
"use client";

import { useMediaQuery } from "@uidotdev/usehooks";
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import React, { createContext, useContext } from "react";
import { Drawer as VaulDrawer } from "vaul";

// --- Context (Unchanged) ---
interface SheetContextProps {
  mode: "normal" | "detached";
  shape: "full" | "minimal" | "sharp";
  hasSnapPoints: boolean;
  direction: "top" | "bottom" | "left" | "right";
}

const SheetContext = createContext<SheetContextProps>({
  mode: "normal",
  shape: "full",
  hasSnapPoints: false,
  direction: "bottom",
});

const useSheetContext = () => useContext(SheetContext);

// --- MODIFIED: Root Component ---
// Added the `forceBottomSheet` prop.
type SheetProps = React.ComponentProps<typeof VaulDrawer.Root> & {
  mode?: "normal" | "detached";
  shape?: "full" | "minimal" | "sharp";
  side?: "left" | "right";
  /**
   * If true, the sheet will always render as a bottom sheet,
   * overriding the responsive behavior on desktop viewports.
   * @default false
   */
  forceBottomSheet?: boolean; // --- THIS IS THE NEW PROP ---
};

const SheetRoot: React.FC<SheetProps> = ({
  mode = "normal",
  shape = "full",
  side = "right",
  forceBottomSheet = false, // --- NEW PROP WITH DEFAULT ---
  snapPoints,
  activeSnapPoint,
  setActiveSnapPoint,
  ...props
}) => {
  const isDesktop = useMediaQuery("(min-width: 768px)");

  // --- MODIFIED LOGIC ---
  // Determine if we should render as a side sheet. This is only true if:
  // 1. The viewport is desktop-sized.
  // 2. The `forceBottomSheet` prop is false.
  const renderAsSideSheet = isDesktop && !forceBottomSheet;

  const direction = renderAsSideSheet ? side : "bottom";
  // --- END OF MODIFIED LOGIC ---

  return (
    <SheetContext.Provider
      value={{
        mode,
        shape,
        // Disable snap points if we are rendering as a side sheet
        hasSnapPoints: renderAsSideSheet
          ? false
          : !!snapPoints && snapPoints.length > 0,
        direction,
      }}
    >
      <VaulDrawer.Root
        direction={direction}
        {...props}
        // Pass snap points only when not rendering as a side sheet
        snapPoints={renderAsSideSheet ? undefined : snapPoints}
        activeSnapPoint={renderAsSideSheet ? undefined : activeSnapPoint}
        setActiveSnapPoint={renderAsSideSheet ? undefined : setActiveSnapPoint}
      />
    </SheetContext.Provider>
  );
};
SheetRoot.displayName = "Sheet";

// --- RE-EXPORTED PRIMITIVES (Unchanged) ---
const SheetTrigger = VaulDrawer.Trigger;
const SheetClose = VaulDrawer.Close;
const SheetPortal = VaulDrawer.Portal;
const SheetTitle = VaulDrawer.Title;
const SheetDescription = VaulDrawer.Description;

// --- CONTENT & OTHER COMPONENTS (Unchanged) ---
// (Your existing SheetContent, SheetHeader, SheetFooter, and SheetGrabber code remains here)
const contentVariants = cva(
  "fixed z-50 flex flex-col bg-graphite-card shadow-lg",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0",
        bottom: "inset-x-0 bottom-0 max-h-[96%]",
        left: "inset-y-0 left-0 w-full max-w-sm",
        right: "inset-y-0 right-0 w-full max-w-sm",
      },
      height: {
        snap: "h-full",
        auto: "h-auto",
      },
      shape: {
        full: "",
        minimal: "",
        sharp: "",
      },
      mode: {
        normal: "",
        detached: "",
      },
    },
    compoundVariants: [
      { side: "bottom", mode: "normal", className: "mx-auto max-w-xl" },
      {
        side: "bottom",
        mode: "detached",
        className: "inset-x-4 bottom-4 mx-auto max-w-lg",
      },
      {
        side: "bottom",
        mode: "normal",
        shape: "full",
        className: "rounded-t-3xl",
      },
      {
        side: "bottom",
        mode: "normal",
        shape: "minimal",
        className: "rounded-t-lg",
      },
      {
        side: "bottom",
        mode: "normal",
        shape: "sharp",
        className: "rounded-t-none",
      },
      {
        side: "bottom",
        mode: "detached",
        shape: "full",
        className: "rounded-2xl",
      },
      {
        side: "bottom",
        mode: "detached",
        shape: "minimal",
        className: "rounded-lg",
      },
      {
        side: "bottom",
        mode: "detached",
        shape: "sharp",
        className: "rounded-none",
      },
      {
        side: "left",
        shape: "full",
        mode: "normal",
        className: "rounded-r-2xl",
      },
      {
        side: "left",
        shape: "minimal",
        mode: "normal",
        className: "rounded-r-lg",
      },
      {
        side: "left",
        shape: "sharp",
        mode: "normal",
        className: "rounded-r-none",
      },
      {
        side: "left",
        shape: "full",
        mode: "detached",
        className: "left-4 rounded-2xl",
      },
      {
        side: "left",
        shape: "minimal",
        mode: "detached",
        className: "left-4 rounded-lg",
      },
      {
        side: "left",
        shape: "sharp",
        mode: "detached",
        className: "left-4 rounded-none",
      },
      {
        side: "right",
        shape: "full",
        mode: "normal",
        className: "rounded-l-2xl",
      },
      {
        side: "right",
        shape: "minimal",
        mode: "normal",
        className: "rounded-l-lg",
      },
      {
        side: "right",
        shape: "sharp",
        mode: "normal",
        className: "rounded-l-none",
      },
      {
        side: "right",
        shape: "full",
        mode: "detached",
        className: "top-4 bottom-4 right-4 rounded-2xl",
      },
      {
        side: "right",
        shape: "minimal",
        mode: "detached",
        className: "top-4 bottom-4 right-4 rounded-lg",
      },
      {
        side: "right",
        shape: "sharp",
        mode: "detached",
        className: "top-4 bottom-4 right-4 rounded-none",
      },
    ],
    defaultVariants: {
      shape: "full",
      mode: "normal",
    },
  }
);
type SheetContentProps = React.ComponentProps<typeof VaulDrawer.Content> &
  VariantProps<typeof contentVariants>;
const SheetContent = React.forwardRef<
  React.ElementRef<typeof VaulDrawer.Content>,
  SheetContentProps
>(({ className, shape: shapeProp, ...props }, ref) => {
  const {
    mode,
    shape: shapeContext,
    hasSnapPoints,
    direction,
  } = useSheetContext();

  const shape = shapeProp || shapeContext;

  const style =
    mode === "detached"
      ? ({ "--vaul-after-display": "0" } as React.CSSProperties)
      : {};

  return (
    <SheetPortal>
      <VaulDrawer.Overlay className="fixed inset-0 z-50 bg-black/50" />
      <VaulDrawer.Content
        ref={ref}
        style={{ ...props.style, ...style }}
        className={clsx(
          contentVariants({
            side: direction,
            mode,
            shape,
            height: direction === "bottom" && hasSnapPoints ? "snap" : "auto",
          }),
          className
        )}
        {...props}
      />
    </SheetPortal>
  );
});
SheetContent.displayName = "Sheet.Content";
const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={clsx(
      "flex flex-col gap-1 p-6 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
SheetHeader.displayName = "Sheet.Header";
const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={clsx("mt-auto flex flex-col gap-2 p-6", className)}
    {...props}
  />
);
SheetFooter.displayName = "Sheet.Footer";
const SheetGrabber = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => {
  const { direction } = useSheetContext();
  if (direction !== "bottom") {
    return null;
  }
  return (
    <div className="flex-shrink-0 p-4">
      <div
        className={clsx(
          "mx-auto h-1.5 w-12 flex-shrink-0 rounded-full bg-graphite-foreground/40",
          className
        )}
        {...props}
      />
    </div>
  );
};
SheetGrabber.displayName = "Sheet.Grabber";

export const Sheet = Object.assign(SheetRoot, {
  Trigger: SheetTrigger,
  Content: SheetContent,
  Close: SheetClose,
  Title: SheetTitle,
  Description: SheetDescription,
  Header: SheetHeader,
  Footer: SheetFooter,
  Grabber: SheetGrabber,
});
```

**Storybook Stories (`sheet.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import clsx from "clsx";
import { useState } from "react";
import { Button } from "../button";
import { Typography } from "../typography";
import { Sheet } from "./index"; // Assuming your component file is named index.tsx

const meta: Meta<typeof Sheet> = {
  title: "Components/Sheet",
  component: Sheet,
  tags: ["autodocs"],
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "A versatile and responsive sheet component. It renders as a bottom sheet on mobile viewports and intelligently transitions to a side sheet (drawer) on desktop. This behavior can be overridden.",
      },
    },
  },
  argTypes: {
    side: {
      control: "select",
      options: ["left", "right"],
      description:
        "Determines which side the sheet appears from on desktop viewports.",
    },
    mode: {
      control: "select",
      options: ["normal", "detached"],
      description:
        "Controls the visual style ('normal' vs. floating 'detached').",
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "Controls the border-radius of the sheet.",
    },
    forceBottomSheet: {
      control: "boolean",
      description:
        "If true, forces the component to render as a bottom sheet on all screen sizes.",
    },
    // Vaul-specific props
    snapPoints: {
      control: "object",
      description: "Array of snap points for the bottom sheet mode.",
    },
    fadeFromIndex: {
      control: "number",
      description:
        "Required when snapPoints are used. Snap points are disabled on desktop.",
    },
    dismissible: {
      control: "boolean",
    },
    // We don't control these directly but show their action
    activeSnapPoint: { control: false },
    setActiveSnapPoint: { action: "snapPointChanged" },
  },
};

export default meta;
type Story = StoryObj<typeof Sheet>;

// Helper for rich, scrollable content
const DummyContent = () => (
  <div className="flex-1 overflow-y-auto p-6">
    <Typography variant="h4" className="mb-2">
      Sheet Content
    </Typography>
    <Typography variant="p">
      This is the main content area. If the content becomes too long, this area
      will automatically become scrollable.
    </Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2">
      {Array.from({ length: 12 }).map((_, i) => (
        <div key={`dummy-item-${i}`} className="h-24 rounded-2xl bg-black/5" />
      ))}
    </div>
  </div>
);

// --- STORIES ---

export const ResponsiveBehavior: Story = {
  name: "1. Responsive Behavior (Default)",
  args: {
    side: "right",
    mode: "normal",
    shape: "full",
  },
  parameters: {
    docs: {
      description: {
        story:
          "**This is the primary use case.** By default, the component is a **bottom sheet** on mobile and a **side sheet** on desktop. Resize your browser window to see the transition.",
      },
    },
  },
  render: (args) => (
    <div className="flex p-12 items-center justify-center bg-graphite-background">
      <Sheet {...args}>
        <Sheet.Trigger asChild>
          <Button>Open Sheet</Button>
        </Sheet.Trigger>
        <Sheet.Content>
          <Sheet.Grabber />
          <Sheet.Header>
            <Sheet.Title>
              <Typography variant="h3">Responsive Sheet</Typography>
            </Sheet.Title>
            <Sheet.Description>
              <Typography variant="muted">
                Adapts to your screen size.
              </Typography>
            </Sheet.Description>
          </Sheet.Header>
          <DummyContent />
          <Sheet.Footer>
            <Button size="lg">Save Changes</Button>
            <Sheet.Close asChild>
              <Button size="lg" variant="secondary">
                Close
              </Button>
            </Sheet.Close>
          </Sheet.Footer>
        </Sheet.Content>
      </Sheet>
    </div>
  ),
};

export const ForceBottomSheet: Story = {
  name: "2. Force Bottom Sheet on Desktop",
  args: {
    ...ResponsiveBehavior.args,
    forceBottomSheet: true,
  },
  parameters: {
    docs: {
      description: {
        story:
          "Set `forceBottomSheet={true}` to override the responsive behavior and always render a bottom sheet, even on large screens.",
      },
    },
  },
  render: (args) => <ResponsiveBehavior.render {...args} />,
};

export const SideSheetLeft: Story = {
  name: "3. Side Sheet (Left)",
  args: {
    ...ResponsiveBehavior.args,
    side: "left",
  },
  parameters: {
    docs: {
      description: {
        story:
          "Use the `side` prop to control the drawer's position on desktop.",
      },
    },
  },
  render: (args) => <ResponsiveBehavior.render {...args} />,
};

export const DetachedMode: Story = {
  name: "4. Detached Mode",
  args: {
    ...ResponsiveBehavior.args,
    mode: "detached",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `detached` mode adds a margin, making the sheet appear to float. This works responsively for both bottom and side sheet variants.",
      },
    },
  },
  render: (args) => <ResponsiveBehavior.render {...args} />,
};

export const WithSnappingPoints: Story = {
  name: "5. With Snapping Points",
  args: {
    snapPoints: [0.3, 0.7, 1],
    fadeFromIndex: 0,
    forceBottomSheet: true, // Snapping is a bottom sheet feature
  },
  parameters: {
    docs: {
      description: {
        story:
          "**Snapping only works in bottom sheet mode.** If the component renders as a side sheet on desktop, snap points are automatically disabled. Here, we use `forceBottomSheet` to demonstrate them on a large screen.",
      },
    },
  },
  render: (args) => (
    <div className="flex p-12 items-center justify-center bg-graphite-background">
      <Sheet {...args}>
        <Sheet.Trigger asChild>
          <Button>Open Snapping Sheet</Button>
        </Sheet.Trigger>
        <Sheet.Content>
          <Sheet.Grabber />
          <DummyContent />
        </Sheet.Content>
      </Sheet>
    </div>
  ),
};

export const ControlledSnapping: Story = {
  name: "6. Controlled Snapping",
  args: {
    snapPoints: ["300px", 1],
    fadeFromIndex: 0,
    forceBottomSheet: true,
  },
  parameters: {
    docs: {
      description: {
        story:
          "Manually control the snap point from outside the component using the `activeSnapPoint` and `setActiveSnapPoint` props. This only works in bottom sheet mode.",
      },
    },
  },
  render: function Render(args) {
    const [activeSnapPoint, setActiveSnapPoint] = useState<
      string | number | null
    >(args.snapPoints![0]);
    return (
      <div className="flex p-12 flex-col items-center justify-center gap-4 bg-graphite-background">
        <Typography variant="large">External Controls</Typography>

        <Sheet
          {...args}
          activeSnapPoint={activeSnapPoint}
          setActiveSnapPoint={setActiveSnapPoint}
        >
          <Sheet.Trigger asChild>
            <Button>Open Controlled Sheet</Button>
          </Sheet.Trigger>
          <Sheet.Content>
            <Sheet.Grabber />
            <Sheet.Header>
              <Typography variant="h3">
                Current Snap: {String(activeSnapPoint)}
              </Typography>
            </Sheet.Header>

            <div
              className={clsx(
                activeSnapPoint === 1 ? "overflow-auto" : "overflow-hidden",
                "p-4"
              )}
            >
              <Typography>
                Lorem ipsum dolor sit amet consectetur adipisicing elit.
                Explicabo, eligendi! Voluptates nobis nam animi similique vero
                tenetur sunt velit? Maxime numquam neque ducimus recusandae quae
                non laudantium eum officiis nostrum. Cupiditate veritatis facere
                reiciendis cum fuga iste, ab qui animi culpa ducimus sed
                molestias? Qui, facilis alias? Ipsum sunt corrupti mollitia
                libero a quibusdam, rerum dignissimos, quam magni id unde.
                Quaerat, modi suscipit odio laboriosam alias, eum recusandae
                quod, aut nobis quidem explicabo impedit optio possimus amet ea.
                Non odio, placeat vel officia iusto vitae accusamus velit sint
                quo facere. Est et eius, esse culpa inventore sequi eum soluta
                perspiciatis illo minima, facilis nobis sed numquam similique.
                Soluta, ipsa eum enim amet dolorum error nemo at ab. Sit,
                repudiandae autem. Reiciendis quo eveniet molestias dolore
                exercitationem? Tenetur deleniti magni facere! Ducimus explicabo
                alias deleniti perferendis delectus accusamus deserunt tenetur
                iste dolor ullam, odio aliquid autem aut illum ad officiis
                vitae. Ipsam repellat neque ab debitis accusantium cupiditate
                laudantium, rem perferendis mollitia repudiandae architecto
                voluptatibus laborum et eius nemo iste harum nisi unde
                asperiores tempora placeat officia esse quia. Vitae, odit? Ipsa,
                similique rem. Minus eveniet totam quidem quia asperiores
                nostrum cupiditate corporis error expedita. Consequatur
                aspernatur, sint eum corporis, nisi earum dicta sed quae
                molestias sunt ipsa ex magni porro. Distinctio animi facilis
                doloremque beatae libero laudantium ducimus aliquam molestias,
                voluptates amet fugiat facere perferendis deserunt harum dicta
                eveniet quis sed deleniti repellendus veniam ullam reiciendis?
                Accusantium reprehenderit laudantium nemo. Quod nemo omnis hic
                optio laudantium saepe magni veniam excepturi, tenetur alias
                eveniet quibusdam, quidem recusandae quasi? Ipsum error
                accusamus corporis. Cum nesciunt ab repellat vitae consequatur
                et qui nemo. Magnam deserunt libero cumque magni ea pariatur,
                iusto consectetur, natus, ducimus sunt eum! Quisquam aliquid
                fugit suscipit architecto sunt quas at optio neque porro
                expedita, placeat dolor perferendis sequi tempora?
              </Typography>
            </div>
          </Sheet.Content>
        </Sheet>
      </div>
    );
  },
};
```


### Component: `sidebar`

This section contains the source code for the `sidebar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\sidebar\index.tsx`)**
```tsx
"use client";

import { useMediaQuery } from "@uidotdev/usehooks";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import {
  animate,
  AnimatePresence,
  motion,
  useMotionValue,
  useTransform,
  type MotionValue,
  type PanInfo,
} from "framer-motion";
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useId,
  useMemo,
  useState,
} from "react";
import useRipple from "use-ripple-hook";
import { Typography } from "../typography";

// --- 1. TYPE DEFINITIONS & CONTEXT (UNIFIED) ---

type DesktopVariant = "permanent" | "modal";
type MobileVariant = "modal" | "push";
type SidebarSide = "left" | "right";

interface SidebarContextProps {
  // State
  isDesktop: boolean;
  isExpanded: boolean;
  isOpen: boolean;
  activeItem: string;
  // Configuration
  desktopVariant: DesktopVariant;
  mobileVariant: MobileVariant;
  side: SidebarSide;
  collapsible: boolean;
  indicatorId: string;
  variant: "primary" | "secondary";
  // For Gestures
  sidebarX: MotionValue<number>;
  expandedWidth: number;
  // Actions
  toggle: () => void;
  onOpenChange: (isOpen: boolean) => void;
  handleItemPress: (itemKey: string) => void;
}

const SidebarContext = createContext<SidebarContextProps | null>(null);

/**
 * Hook to access sidebar state and actions. Must be used within a <Sidebar> component.
 */
export const useSidebar = () => {
  const context = useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a <Sidebar> component.");
  }
  return context;
};

interface SidebarNavContextProps {
  size: "sm" | "md" | "lg";
  shape: "full" | "minimal" | "sharp";
}

const SidebarNavContext = createContext<SidebarNavContextProps>({
  size: "md",
  shape: "full",
});

// --- 2. CVA VARIANTS ---
const containerVariants = cva("flex h-full flex-col", {
  variants: {
    variant: {
      primary: "bg-graphite-primary text-graphite-primaryForeground",
      secondary: "bg-graphite-secondary text-graphite-foreground",
    },
  },
  defaultVariants: {
    variant: "secondary",
  },
});

const primaryActionVariants = cva(
  "flex items-center justify-center font-semibold transition-all duration-300 ease-in-out overflow-hidden relative group shadow-lg hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
  {
    variants: {
      variant: {
        primary: "bg-graphite-primary text-graphite-primaryForeground",
        secondary: "bg-graphite-secondary text-graphite-secondaryForeground",
      },
      isExpanded: {
        true: "rounded-2xl h-14 px-5",
        false: "rounded-2xl h-14 w-14",
      },
    },
    defaultVariants: {
      variant: "secondary",
    },
  }
);

const navItemVariants = cva(
  "relative flex items-center w-full transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2",
  {
    variants: {
      isActive: {
        true: "font-semibold text-graphite-primary",
        false:
          "text-graphite-foreground/70 hover:text-graphite-foreground/90 hover:bg-black/5",
      },
      isExpanded: {
        true: "justify-start px-5",
        false: "justify-center px-0",
      },
      size: {
        sm: "h-10 text-sm",
        md: "h-14 text-base",
        lg: "h-16 text-lg",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      isActive: false,
      isExpanded: false,
      size: "md",
      shape: "full",
    },
  }
);
// --- 3. ROOT COMPONENT (UNIFIED STATE) ---

interface SidebarProps {
  children: [
    React.ReactElement<SidebarContainerProps>,
    React.ReactElement<SidebarContentProps>
  ];
  activeItem: string;
  onItemPress: (itemKey: string) => void;
  isOpen?: boolean;
  onOpenChange?: (isOpen: boolean) => void;
  defaultOpen?: boolean;
  desktopVariant?: DesktopVariant;
  mobileVariant?: MobileVariant;
  side?: SidebarSide;
  collapsible?: boolean;
}

const SidebarRoot: React.FC<SidebarProps> = ({
  children,
  activeItem,
  onItemPress,
  isOpen: controlledOpen,
  onOpenChange,
  defaultOpen = false,
  desktopVariant = "permanent",
  mobileVariant = "modal",
  side = "left",
  collapsible = true,
}) => {
  const [sidebarContainer, mainContent] = React.Children.toArray(children) as [
    React.ReactElement<SidebarContainerProps>,
    React.ReactElement<SidebarContentProps>
  ];
  const containerVariant = sidebarContainer.props.variant || "secondary";

  const isDesktop = useMediaQuery("(min-width: 768px)");
  const indicatorId = useId();

  const [uncontrolledOpen, setUncontrolledOpen] = useState(defaultOpen);
  const isControlled = controlledOpen !== undefined && onOpenChange;
  const isOpen = isControlled ? controlledOpen : uncontrolledOpen;

  const handleOpenChange = isControlled ? onOpenChange : setUncontrolledOpen;

  const expandedWidth = 280;
  const closedX = side === "left" ? -expandedWidth : expandedWidth;
  const sidebarX = useMotionValue(isOpen ? 0 : closedX);

  useEffect(() => {
    if (!isDesktop) {
      const targetX = isOpen ? 0 : closedX;
      animate(sidebarX, targetX, {
        type: "spring",
        stiffness: 500,
        damping: 50,
        mass: 1,
      });
    }
  }, [isOpen, isDesktop, closedX, sidebarX]);

  const pushX = useTransform(sidebarX, (latestX) => {
    if (isDesktop || mobileVariant !== "push") return 0;
    if (side === "left") return latestX + expandedWidth;
    return latestX - expandedWidth;
  });

  const overlayOpacity = useTransform(
    sidebarX,
    side === "left" ? [-expandedWidth, 0] : [expandedWidth, 0],
    [0, 1]
  );

  const toggle = useCallback(() => {
    if (collapsible) {
      handleOpenChange(!isOpen);
    }
  }, [collapsible, isOpen, handleOpenChange]);

  const handleItemPress = useCallback(
    (itemKey: string) => {
      onItemPress(itemKey);
      if (!isDesktop) {
        setTimeout(() => {
          handleOpenChange(false);
        }, 100);
      }
    },
    [isDesktop, onItemPress, handleOpenChange]
  );

  const contextValue = useMemo(
    () => ({
      isDesktop,
      isExpanded: isDesktop ? isOpen : true,
      isOpen,
      activeItem,
      desktopVariant,
      mobileVariant,
      side,
      collapsible,
      indicatorId,
      sidebarX,
      expandedWidth,
      variant: containerVariant,
      toggle,
      onOpenChange: handleOpenChange,
      handleItemPress,
    }),
    [
      isDesktop,
      isOpen,
      activeItem,
      desktopVariant,
      mobileVariant,
      side,
      collapsible,
      indicatorId,
      sidebarX,
      expandedWidth,
      containerVariant,
      toggle,
      handleOpenChange,
      handleItemPress,
    ]
  );

  const collapsedWidth = 80;
  const sidebarWidth = isOpen ? expandedWidth : collapsedWidth;

  return (
    <SidebarContext.Provider value={contextValue}>
      <div className="relative h-screen w-full bg-graphite-background overflow-hidden">
        {isDesktop ? (
          <div
            className={clsx(
              "flex h-full",
              side === "right" && "flex-row-reverse"
            )}
          >
            {desktopVariant === "permanent" && (
              <motion.div
                style={{ transform: "translateZ(0)" }}
                animate={{ width: sidebarWidth }}
                transition={{ type: "spring", stiffness: 400, damping: 40 }}
              >
                {sidebarContainer}
              </motion.div>
            )}
            {mainContent}
          </div>
        ) : (
          <>
            {!isDesktop && mobileVariant === "modal" && (
              <motion.div
                className="fixed inset-0 z-[10000] bg-black/40"
                style={{ opacity: overlayOpacity }}
                onClick={() => handleOpenChange(false)}
                initial={{ pointerEvents: "none" }}
                animate={{ pointerEvents: isOpen ? "auto" : "none" }}
              />
            )}
            {sidebarContainer}
            <motion.div
              className="h-full"
              style={{
                x: pushX,
                transform: "translateZ(0)",
                // NEW: Add touchAction style to prevent conflicts
                touchAction: isOpen ? "none" : "pan-y",
              }}
            >
              {mainContent}
            </motion.div>
          </>
        )}
      </div>
    </SidebarContext.Provider>
  );
};
SidebarRoot.displayName = "Sidebar";

// --- 4. SUB-COMPONENTS ---

interface SidebarContainerProps {
  children: React.ReactNode;
  className?: string;
  variant?: "primary" | "secondary";
}
const SidebarContainer = React.memo(
  React.forwardRef<HTMLElement, SidebarContainerProps>(
    ({ children, className, variant = "secondary" }, ref) => {
      const {
        side,
        isDesktop,
        mobileVariant,
        onOpenChange,
        sidebarX,
        expandedWidth,
      } = useSidebar();

      if (isDesktop) {
        return (
          <aside
            ref={ref}
            className={clsx(containerVariants({ variant }), className)}
          >
            {children}
          </aside>
        );
      }

      const handleDragEnd = (e: MouseEvent | TouchEvent, info: PanInfo) => {
        const closedX = side === "left" ? -expandedWidth : expandedWidth;
        const isClosing =
          (side === "left" &&
            (info.offset.x < -50 || info.velocity.x < -500)) ||
          (side === "right" && (info.offset.x > 50 || info.velocity.x > 500));

        if (isClosing) {
          animate(sidebarX, closedX, {
            type: "spring",
            stiffness: 500,
            damping: 50,
            onComplete: () => onOpenChange(false),
          });
        } else {
          animate(sidebarX, 0, {
            type: "spring",
            stiffness: 500,
            damping: 50,
            onComplete: () => onOpenChange(true),
          });
        }
      };

      return (
        <motion.aside
          ref={ref}
          key={`sidebar-${mobileVariant}`}
          drag="x"
          onDragEnd={handleDragEnd}
          style={{ x: sidebarX, transform: "translateZ(0)" }}
          dragConstraints={{
            left: side === "left" ? -expandedWidth : 0,
            right: side === "left" ? 0 : expandedWidth,
          }}
          dragElastic={{ left: 0.1, right: 0.1 }}
          className={clsx(
            containerVariants({ variant }),
            "fixed top-0 bottom-0 z-[100] flex h-screen flex-col",
            "w-[280px]",
            side === "left" ? "left-0" : "right-0",
            className
          )}
        >
          {children}
        </motion.aside>
      );
    }
  )
);
SidebarContainer.displayName = "Sidebar.Container";

const SidebarHeader = React.memo(
  (props: React.HTMLAttributes<HTMLDivElement>) => (
    <div
      className={clsx(
        "flex h-16 flex-shrink-0 items-center px-4",
        props.className
      )}
      {...props}
    />
  )
);
SidebarHeader.displayName = "Sidebar.Header";

interface PrimaryActionProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  icon: React.ReactNode;
  variant?: "primary" | "secondary";
}
const SidebarPrimaryAction = React.memo(
  React.forwardRef<HTMLButtonElement, PrimaryActionProps>(
    ({ children, icon, variant = "secondary", className, ...props }, ref) => {
      const { isExpanded } = useSidebar();
      return (
        <div className="px-3 py-2">
          {/* @ts-ignore */}
          <motion.button
            ref={ref}
            layout
            transition={{ type: "spring", stiffness: 400, damping: 40 }}
            className={primaryActionVariants({
              variant,
              isExpanded,
              className,
            })}
            {...props}
          >
            <motion.span layout="position" className="flex-shrink-0">
              {icon}
            </motion.span>
            <AnimatePresence>
              {isExpanded && (
                <motion.div
                  initial={{ opacity: 0, width: 0 }}
                  animate={{
                    opacity: 1,
                    width: "auto",
                    marginLeft: "0.75rem",
                    transition: { delay: 0.1 },
                  }}
                  exit={{ opacity: 0, width: 0, marginLeft: 0 }}
                  className="overflow-hidden whitespace-nowrap"
                >
                  {children}
                </motion.div>
              )}
            </AnimatePresence>
          </motion.button>
        </div>
      );
    }
  )
);
SidebarPrimaryAction.displayName = "Sidebar.PrimaryAction";

interface SidebarNavProps extends React.HTMLAttributes<HTMLElement> {
  size?: "sm" | "md" | "lg";
  shape?: "full" | "minimal" | "sharp";
}

const SidebarNav = React.memo(
  ({
    children,
    className,
    size = "md",
    shape = "full",
    ...props
  }: SidebarNavProps) => {
    return (
      <SidebarNavContext.Provider value={{ size, shape }}>
        <nav
          className={clsx("flex-1 space-y-1 px-3 py-2", className)}
          {...props}
        >
          {children}
        </nav>
      </SidebarNavContext.Provider>
    );
  }
);
SidebarNav.displayName = "Sidebar.Nav";

interface NavItemProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  itemKey: string;
  icon: React.ReactNode;
  endAdornment?: React.ReactNode;
  size?: "sm" | "md" | "lg";
  shape?: "full" | "minimal" | "sharp";
}
const SidebarItem = React.memo(
  React.forwardRef<HTMLButtonElement, NavItemProps>(
    (
      {
        itemKey,
        icon,
        children,
        endAdornment,
        className,
        size: propSize,
        shape: propShape,
        ...props
      },
      ref
    ) => {
      const { activeItem, handleItemPress, isExpanded, indicatorId, variant } =
        useSidebar();
      const { size: contextSize, shape: contextShape } =
        useContext(SidebarNavContext);

      const isActive = activeItem === itemKey;
      const size = propSize || contextSize;
      const shape = propShape || contextShape;

      const shapeToBorderRadius = {
        full: 9999,
        minimal: "0.5rem",
        sharp: 0,
      };

      const localRef = React.useRef<HTMLButtonElement>(null);
      React.useImperativeHandle(
        ref,
        () => localRef.current as HTMLButtonElement
      );

      const rippleColor =
        variant === "primary"
          ? "rgba(255, 255, 255, 0.1)"
          : "rgba(0, 0, 0, 0.1)";

      const rippleRef = localRef as React.RefObject<HTMLElement>;
      const [, event] = useRipple({
        ref: rippleRef,
        color: rippleColor,
        duration: 400,
      });

      return (
        <button
          ref={localRef}
          onPointerDown={event}
          onClick={() => handleItemPress(itemKey)}
          className={navItemVariants({
            isActive,
            isExpanded,
            size,
            shape,
            className,
          })}
          {...props}
        >
          {isActive && (
            <motion.div
              layoutId={indicatorId}
              className="absolute inset-0 z-0 bg-graphite-primary/10"
              style={{ borderRadius: shapeToBorderRadius[shape] }}
              transition={{ type: "spring", stiffness: 500, damping: 40 }}
            />
          )}
          <div className="relative z-10 flex-shrink-0">{icon}</div>
          <AnimatePresence initial={false}>
            {isExpanded && (
              <motion.div
                initial={{ opacity: 0, width: 0 }}
                animate={{
                  opacity: 1,
                  width: "auto",
                  marginLeft: "0.75rem",
                  transition: { delay: 0.1, duration: 0.2 },
                }}
                exit={{
                  opacity: 0,
                  width: 0,
                  marginLeft: 0,
                  transition: { duration: 0.1 },
                }}
                className="relative z-10 flex-1 text-left overflow-hidden whitespace-nowrap"
              >
                {children}
              </motion.div>
            )}
          </AnimatePresence>
          {isExpanded && endAdornment && (
            <div className="relative z-10 ml-auto flex-shrink-0">
              {endAdornment}
            </div>
          )}
        </button>
      );
    }
  )
);
SidebarItem.displayName = "Sidebar.Item";

const SidebarFooter = React.memo(
  (props: React.HTMLAttributes<HTMLDivElement>) => (
    <div
      className={clsx("mt-auto flex-shrink-0 p-3", props.className)}
      {...props}
    />
  )
);
SidebarFooter.displayName = "Sidebar.Footer";

const SidebarSeparator = React.memo(
  (props: React.HTMLAttributes<HTMLHRElement>) => (
    <hr
      className={clsx("my-2 border-graphite-border/60", props.className)}
      {...props}
    />
  )
);
SidebarSeparator.displayName = "Sidebar.Separator";

const SidebarSectionHeader = React.memo(
  (props: React.HTMLAttributes<HTMLDivElement>) => {
    const { isExpanded } = useSidebar();
    return (
      <AnimatePresence>
        {isExpanded && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: "auto" }}
            exit={{ opacity: 0, height: 0 }}
            className="overflow-hidden"
          >
            <Typography
              variant="small"
              className={clsx(
                "px-5 py-2 font-bold text-graphite-primary",
                props.className
              )}
              {...props}
            />
          </motion.div>
        )}
      </AnimatePresence>
    );
  }
);
SidebarSectionHeader.displayName = "Sidebar.SectionHeader";

const SidebarDragHandle = React.memo(() => {
  const { isDesktop, isOpen, onOpenChange, side, sidebarX, expandedWidth } =
    useSidebar();

  if (isDesktop || isOpen) return null;

  const handleDragEnd = (event: MouseEvent | TouchEvent, info: PanInfo) => {
    const isOpening =
      (side === "left" && (info.offset.x > 50 || info.velocity.x > 500)) ||
      (side === "right" && (info.offset.x < -50 || info.velocity.x < -500));

    if (isOpening) {
      animate(sidebarX, 0, {
        type: "spring",
        stiffness: 500,
        damping: 50,
        onComplete: () => onOpenChange(true),
      });
    } else {
      const closedX = side === "left" ? -expandedWidth : expandedWidth;
      animate(sidebarX, closedX, {
        type: "spring",
        stiffness: 500,
        damping: 50,
      });
    }
  };

  return (
    <motion.div
      className={clsx(
        "fixed top-0 bottom-0 z-[1000] w-12",
        side === "left" ? "left-0" : "right-0"
      )}
      drag="x"
      dragConstraints={{ left: 0, right: 0 }}
      dragElastic={{ left: 0.1, right: 0.1 }}
      onDragEnd={handleDragEnd}
      onDrag={(e, info) => {
        const isDraggingCorrectly =
          (side === "left" && info.offset.x > 0) ||
          (side === "right" && info.offset.x < 0);

        if (isDraggingCorrectly) {
          sidebarX.set(
            side === "left"
              ? info.offset.x - expandedWidth
              : info.offset.x + expandedWidth
          );
        }
      }}
    />
  );
});
SidebarDragHandle.displayName = "Sidebar.DragHandle";

interface SidebarContentProps extends React.HTMLAttributes<HTMLDivElement> {}

const SidebarContent = React.memo(
  React.forwardRef<HTMLDivElement, SidebarContentProps>((props, ref) => {
    return (
      <div
        ref={ref}
        className={clsx("h-full w-full", props.className)}
        {...props}
      />
    );
  })
);
SidebarContent.displayName = "Sidebar.Content";

// --- 5. COMPOUND EXPORT ---

export const Sidebar = Object.assign(SidebarRoot, {
  Container: SidebarContainer,
  Header: SidebarHeader,
  PrimaryAction: SidebarPrimaryAction,
  Nav: SidebarNav,
  Item: SidebarItem,
  Footer: SidebarFooter,
  Separator: SidebarSeparator,
  SectionHeader: SidebarSectionHeader,
  DragHandle: SidebarDragHandle,
  Content: SidebarContent,
});
```

**Storybook Stories (`Sidebar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Archive,
  File,
  Inbox,
  Menu,
  Pencil,
  Search,
  Send,
  Settings,
  Star,
  Trash2,
  User,
} from "lucide-react";
import { useRef, useState } from "react";
import { AppBar } from "../appbar";
import { Badge } from "../badge";
import { ElasticScrollArea } from "../elastic-scroll-area";
import { IconButton } from "../icon-button";
import { Input } from "../input";
import { ShallowRouter, useRouter } from "../shallow-router";
import { Typography } from "../typography";
import { Sidebar, useSidebar } from "./index";

const meta: Meta<typeof Sidebar> = {
  title: "Components/Navigators/Sidebar",
  component: Sidebar,
  tags: ["autodocs"],
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "A highly responsive and animated navigation sidebar. It functions as a permanent or collapsible rail on desktop, and a modal or push-style drawer on mobile. Integrates with any routing library via `activeItem` and `onItemPress` props.",
      },
    },
  },
  argTypes: {
    desktopVariant: {
      control: "select",
      options: ["permanent", "modal"],
      description: "Behavior on desktop viewports.",
    },
    mobileVariant: {
      control: "select",
      options: ["modal", "push"],
      description: "Behavior on mobile viewports.",
    },
    side: {
      control: "select",
      options: ["left", "right"],
      description: "Which side the sidebar appears on.",
    },
    collapsible: {
      control: "boolean",
      description: "Whether the sidebar can be collapsed on desktop.",
    },
    defaultOpen: {
      control: "boolean",
      description: "Initial open state for uncontrolled components.",
    },
    activeItem: { control: false },
    onItemPress: { action: "itemPressed" },
    isOpen: { control: false },
    onOpenChange: { action: "openChange" },
  },
};

export default meta;
type Story = StoryObj<typeof Sidebar>;

// --- Helper Components for Stories ---

const navItems = [
  { key: "inbox", label: "Inbox", icon: <Inbox size={20} />, count: 24 },
  { key: "sent", label: "Sent", icon: <Send size={20} /> },
  { key: "favorites", label: "Favorites", icon: <Star size={20} /> },
  { key: "drafts", label: "Drafts", icon: <File size={20} /> },
  { key: "archive", label: "Archive", icon: <Archive size={20} /> },
  { key: "trash", label: "Trash", icon: <Trash2 size={20} /> },
];

const labelItems = [
  { key: "work", label: "Work" },
  { key: "personal", label: "Personal" },
  { key: "urgent", label: "Urgent" },
];

const CustomSidebarHeader = () => {
  const { isDesktop, collapsible, toggle, side } = useSidebar();
  return (
    <Sidebar.Header className={side === "right" ? "flex-row-reverse" : ""}>
      <div className="flex justify-center items-center pt-4">
        {isDesktop && collapsible && (
          <IconButton variant="ghost" size="sm" onClick={toggle}>
            <Menu />
          </IconButton>
        )}
      </div>

      {/* You can add a logo or title here */}
    </Sidebar.Header>
  );
};

const SidebarContents = () => (
  <>
    <CustomSidebarHeader />
    <Sidebar.PrimaryAction icon={<Pencil size={24} />}>
      Compose
    </Sidebar.PrimaryAction>
    <Sidebar.Nav>
      <ElasticScrollArea>
        {navItems.map((item) => (
          <Sidebar.Item
            key={item.key}
            itemKey={item.key}
            icon={item.icon}
            endAdornment={
              item.count ? (
                <Badge shape="full" variant="secondary">
                  {item.count}
                </Badge>
              ) : null
            }
          >
            {item.label}
          </Sidebar.Item>
        ))}
        <Sidebar.Separator />
        <Sidebar.SectionHeader>Labels</Sidebar.SectionHeader>
        {labelItems.map((item) => (
          <Sidebar.Item
            key={item.key}
            itemKey={item.key}
            icon={<File size={20} />}
          >
            {item.label}
          </Sidebar.Item>
        ))}
      </ElasticScrollArea>
    </Sidebar.Nav>
    <Sidebar.Footer>
      <Sidebar.Item itemKey="profile" icon={<User size={20} />}>
        Profile
      </Sidebar.Item>
      <Sidebar.Item itemKey="settings" icon={<Settings size={20} />}>
        Settings
      </Sidebar.Item>
    </Sidebar.Footer>
  </>
);

const MainContent = ({ onMenuClick }: { onMenuClick: () => void }) => {
  const { path } = useRouter();
  const { isDesktop } = useSidebar();
  const item =
    [...navItems, ...labelItems].find((i) => i.key === path.substring(1)) ||
    navItems[0];

  return (
    <div className="p-6">
      <Sidebar.DragHandle />
      {!isDesktop && (
        <IconButton
          variant="primary"
          aria-label="Open Menu"
          onClick={onMenuClick}
        >
          <Menu />
        </IconButton>
      )}
      <Typography variant="h1" className="mt-4 capitalize">
        {item?.label || "Inbox"}
      </Typography>
      <Typography variant="lead">
        This is the main content area for the selected page.
      </Typography>
    </div>
  );
};

const RenderWithRouter = (args: any) => {
  const { path, push } = useRouter();
  const activeItem = path === "/" ? "inbox" : path.substring(1);
  const [isOpen, setIsOpen] = useState(args.defaultOpen);

  return (
    <Sidebar
      {...args}
      activeItem={activeItem}
      onItemPress={(key) => push(`/${key}`)}
      isOpen={isOpen}
      onOpenChange={setIsOpen}
    >
      <Sidebar.Container>
        <SidebarContents />
      </Sidebar.Container>
      <Sidebar.Content>
        <MainContent onMenuClick={() => setIsOpen(!isOpen)} />
      </Sidebar.Content>
    </Sidebar>
  );
};

// --- STORIES ---

export const DesktopExpanded: Story = {
  name: "1. Desktop (Expanded & Collapsible)",
  args: {
    desktopVariant: "permanent",
    collapsible: true,
    defaultOpen: true,
  },
  render: (args) => (
    <ShallowRouter>
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const DesktopCollapsed: Story = {
  name: "2. Desktop (Collapsed by Default)",
  args: {
    ...DesktopExpanded.args,
    defaultOpen: false,
  },
  render: (args) => (
    <ShallowRouter>
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const MobileModal: Story = {
  name: "3. Mobile (Modal Drawer)",
  args: {
    mobileVariant: "modal",
    side: "left",
    defaultOpen: false,
  },
  parameters: {
    viewport: { defaultViewport: "mobile1" },
  },
  render: (args) => (
    <ShallowRouter>
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const MobilePush: Story = {
  name: "4. Mobile (Push Drawer)",
  args: {
    mobileVariant: "push",
    side: "left",
    defaultOpen: false,
  },
  parameters: {
    viewport: { defaultViewport: "mobile1" },
    docs: {
      description: {
        story:
          "The 'push' variant moves the main content aside to reveal the sidebar, creating a different spatial relationship.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter>
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const RightSide: Story = {
  name: "5. Right Side Variant",
  args: {
    ...DesktopExpanded.args,
    side: "right",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `side` prop works for all variants on both desktop and mobile.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter>
      <RenderWithRouter {...args} />
    </ShallowRouter>
  ),
};

export const ControlledState: Story = {
  name: "6. Controlled State",
  args: {
    ...DesktopExpanded.args,
  },
  render: function Render(args) {
    const [isOpen, setIsOpen] = useState(false);
    return (
      <ShallowRouter>
        <div className="absolute top-4 right-4 z-10">
          <button
            type="button"
            onClick={() => setIsOpen(!isOpen)}
            className="px-4 py-2 bg-blue-500 text-white rounded-full"
          >
            Toggle Sidebar
          </button>
        </div>
        <RenderWithRouter {...args} isOpen={isOpen} onOpenChange={setIsOpen} />
      </ShallowRouter>
    );
  },
};

const shortNavItems = [
  { key: "inbox", label: "Inbox", icon: <Inbox size={20} /> },
  { key: "sent", label: "Sent", icon: <Send size={20} /> },
  { key: "favorites", label: "Favorites", icon: <Star size={20} /> },
];

export const ItemVariants: Story = {
  name: "7. Item Variants (Size & Shape)",
  args: {
    ...DesktopExpanded.args,
    defaultOpen: true,
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `size` and `shape` of `Sidebar.Item` components can be controlled by props on the parent `<Sidebar.Nav>`. Props on an individual item will override the parent.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter>
      <Sidebar
        {...args}
        activeItem="inbox"
        onItemPress={() => {}}
        isOpen={args.isOpen}
        onOpenChange={args.onOpenChange}
      >
        <Sidebar.Container>
          <CustomSidebarHeader />
          <Sidebar.SectionHeader>Small, Minimal</Sidebar.SectionHeader>
          <Sidebar.Nav size="sm" shape="minimal">
            {shortNavItems.map((item) => (
              <Sidebar.Item key={item.key} itemKey={item.key} icon={item.icon}>
                {item.label}
              </Sidebar.Item>
            ))}
          </Sidebar.Nav>
          <Sidebar.Separator />
          <Sidebar.SectionHeader>Large, Sharp</Sidebar.SectionHeader>
          <Sidebar.Nav size="lg" shape="sharp">
            {shortNavItems.map((item) => (
              <Sidebar.Item key={item.key} itemKey={item.key} icon={item.icon}>
                {item.label}
              </Sidebar.Item>
            ))}
            <Sidebar.Item
              itemKey="override"
              icon={<Archive size={20} />}
              shape="full"
            >
              Override
            </Sidebar.Item>
          </Sidebar.Nav>
        </Sidebar.Container>
        <Sidebar.Content>
          <div className="p-6">
            <Typography variant="h1">Item Variants</Typography>
            <Typography variant="p">
              The sidebar on the left demonstrates different sizes and shapes
              for navigation items.
            </Typography>
          </div>
        </Sidebar.Content>
      </Sidebar>
    </ShallowRouter>
  ),
};

const AppLayoutContent = ({ onMenuClick }: { onMenuClick: () => void }) => {
  const scrollRef = useRef<HTMLDivElement>(null);
  const { path } = useRouter();
  const item =
    [...navItems, ...labelItems].find((i) => i.key === path.substring(1)) ||
    navItems[0];

  const pageTitle = item?.label || "Inbox";

  return (
    <div className="flex h-full flex-col bg-graphite-background">
      <AppBar
        size="lg"
        largeHeaderRowHeight={50}
        scrollBehavior="conditionally-sticky"
        appBarColor="background"
        animatedBehavior={["shadow"]}
        scrollContainerRef={scrollRef}
        startAdornment={
          <IconButton
            variant="ghost"
            aria-label="Toggle Menu"
            onClick={onMenuClick}
          >
            <Menu />
          </IconButton>
        }
        children={
          <Typography variant="h4" className="truncate font-bold">
            {pageTitle}
          </Typography>
        }
        largeHeaderContent={
          <Input
            variant="secondary"
            shape="full"
            startAdornment={<Search className="h-5 w-5 text-gray-500" />}
            placeholder="Search..."
          />
        }
      />
      <Sidebar.DragHandle />

      <ElasticScrollArea ref={scrollRef} className="flex-1">
        <main className="p-6 ">
          <Typography variant="h3" className="mb-4 pt-[100px]">
            Content for {pageTitle}
          </Typography>
          <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
            {Array.from({ length: 30 }).map((_, i) => (
              <div
                key={i}
                className="h-48 rounded-2xl bg-black/5 flex items-center justify-center"
              >
                <Typography
                  variant="small"
                  className="text-graphite-foreground/50"
                >
                  Item {i + 1}
                </Typography>
              </div>
            ))}
          </div>
        </main>
      </ElasticScrollArea>
    </div>
  );
};

const FullAppLayoutRenderer = (args: any) => {
  const { path, push } = useRouter();
  const activeItem = path === "/" ? "inbox" : path.substring(1);
  const [isOpen, setIsOpen] = useState(args.defaultOpen ?? true);

  return (
    <Sidebar
      {...args}
      activeItem={activeItem}
      onItemPress={(key) => push(`/${key}`)}
      isOpen={isOpen}
      onOpenChange={setIsOpen}
    >
      <Sidebar.Container>
        <SidebarContents />
      </Sidebar.Container>
      <Sidebar.Content>
        <AppLayoutContent onMenuClick={() => setIsOpen(!isOpen)} />
      </Sidebar.Content>
    </Sidebar>
  );
};

export const FullAppLayout: Story = {
  name: "8. Full App Layout",
  args: {
    ...DesktopExpanded.args,
    mobileVariant: "push",
  },
  parameters: {
    docs: {
      description: {
        story:
          "This story demonstrates a complete application layout, integrating `Sidebar` with a large, collapsible `AppBar` and a scrollable content area powered by `ElasticScrollArea`. The key is passing the `scrollRef` from the scroll area to the `AppBar` to synchronize their behavior.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter>
      <FullAppLayoutRenderer {...args} />
    </ShallowRouter>
  ),
};
```


### Component: `slider`

This section contains the source code for the `slider` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\slider\index.tsx`)**
```tsx
"use client";

import * as RadixSlider from "@radix-ui/react-slider";
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import { AnimatePresence, motion } from "framer-motion";
import React, { createContext, useContext, useState } from "react";
import { Typography } from "../typography";

// --- CVA Variants for component parts ---

const sliderRootVariants = cva(
  "relative flex touch-none select-none items-center",
  {
    variants: {
      direction: {
        horizontal: "w-full flex-row py-2",
        vertical: "h-48 w-fit flex-col px-2",
      },
    },
    defaultVariants: {
      direction: "horizontal",
    },
  }
);

const sliderTrackVariants = cva("relative grow overflow-hidden rounded-full", {
  variants: {
    variant: {
      linear: "bg-graphite-secondary",
      bar: "bg-graphite-secondary",
    },
    direction: {
      horizontal: "w-full",
      vertical: "h-full",
    },
    size: {
      sm: "",
      md: "",
      lg: "",
      xl: "",
      "2xl": "",
    },
  },
  compoundVariants: [
    { variant: "linear", direction: "horizontal", className: "h-1" },
    { variant: "linear", direction: "vertical", className: "w-1" },
    { variant: "bar", direction: "horizontal", size: "sm", className: "h-2" },
    { variant: "bar", direction: "horizontal", size: "md", className: "h-3" },
    { variant: "bar", direction: "horizontal", size: "lg", className: "h-5" },
    { variant: "bar", direction: "horizontal", size: "xl", className: "h-7" },
    { variant: "bar", direction: "horizontal", size: "2xl", className: "h-10" },
    { variant: "bar", direction: "vertical", size: "sm", className: "w-2" },
    { variant: "bar", direction: "vertical", size: "md", className: "w-3" },
    { variant: "bar", direction: "vertical", size: "lg", className: "w-5" },
    { variant: "bar", direction: "vertical", size: "xl", className: "w-7" },
    { variant: "bar", direction: "vertical", size: "2xl", className: "w-10" },
  ],
  defaultVariants: {
    variant: "linear",
    direction: "horizontal",
    size: "lg",
  },
});

const sliderRangeVariants = cva(
  "absolute bg-graphite-primary data-[disabled]:bg-graphite-primary/50",
  {
    variants: {
      direction: {
        horizontal: "h-full",
        vertical: "w-full",
      },
    },
    defaultVariants: {
      direction: "horizontal",
    },
  }
);

const barThumbVariants = cva(
  // FIX: Add z-10 to ensure the thumb is rendered on top of the range/track
  "relative z-10 block rounded-full bg-graphite-primary outline-4 outline-graphite-secondary  transition-shadow focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2 data-[disabled]:bg-graphite-primary/50 data-[disabled]:cursor-not-allowed",
  {
    variants: {
      direction: {
        horizontal: "",
        vertical: "",
      },
      size: {
        sm: "",
        md: "",
        lg: "",
        xl: "",
        "2xl": "",
      },
    },
    compoundVariants: [
      { direction: "horizontal", size: "sm", className: "h-4 w-1.5" },
      { direction: "horizontal", size: "md", className: "h-5 w-1.5" },
      { direction: "horizontal", size: "lg", className: "h-7 w-2" },
      { direction: "horizontal", size: "xl", className: "h-9 w-2" },
      { direction: "horizontal", size: "2xl", className: "h-12 w-2.5" },
      { direction: "vertical", size: "sm", className: "w-4 h-1.5" },
      { direction: "vertical", size: "md", className: "w-5 h-1.5" },
      { direction: "vertical", size: "lg", className: "w-7 h-2" },
      { direction: "vertical", size: "xl", className: "w-9 h-2" },
      { direction: "vertical", size: "2xl", className: "w-12 h-2.5" },
    ],
    defaultVariants: {
      direction: "horizontal",
      size: "lg",
    },
  }
);

const barThumbHaloVariants = cva(
  "absolute rounded-full bg-graphite-primary/20",
  {
    variants: {
      direction: {
        horizontal: "",
        vertical: "",
      },
      size: {
        sm: "",
        md: "",
        lg: "",
        xl: "",
        "2xl": "",
      },
    },
    compoundVariants: [
      { direction: "horizontal", size: "sm", className: "h-9 w-6" },
      { direction: "horizontal", size: "md", className: "h-10 w-6" },
      { direction: "horizontal", size: "lg", className: "h-12 w-7" },
      { direction: "horizontal", size: "xl", className: "h-14 w-7" },
      { direction: "horizontal", size: "2xl", className: "h-[68px] w-8" },
      { direction: "vertical", size: "sm", className: "w-9 h-6" },
      { direction: "vertical", size: "md", className: "w-10 h-6" },
      { direction: "vertical", size: "lg", className: "w-12 h-7" },
      { direction: "vertical", size: "xl", className: "w-14 h-7" },
      { direction: "vertical", size: "2xl", className: "w-[68px] h-8" },
    ],
    defaultVariants: {
      direction: "horizontal",
      size: "lg",
    },
  }
);

// --- Context to pass props down to thumbs ---
type SliderContextProps = VariantProps<typeof sliderTrackVariants>;

const SliderContext = createContext<SliderContextProps | null>(null);
const useSliderContext = () => {
  const context = useContext(SliderContext);
  if (!context) {
    throw new Error("Slider sub-components must be used within a Slider");
  }
  return context;
};

// --- Internal Thumb Components ---

const LinearThumb = React.forwardRef<
  HTMLSpanElement,
  { value: number } & React.ComponentPropsWithoutRef<typeof RadixSlider.Thumb>
>(({ value, ...props }, ref) => {
  const [isHoveredOrActive, setIsHoveredOrActive] = useState(false);
  return (
    <RadixSlider.Thumb
      ref={ref}
      onPointerEnter={() => setIsHoveredOrActive(true)}
      onPointerLeave={() => setIsHoveredOrActive(false)}
      className={clsx(
        "relative z-10 block h-5 w-5 rounded-full outline-4 outline-graphite-secondary bg-graphite-primary transition-shadow",
        "focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2",
        "data-[disabled]:bg-graphite-primary/50 data-[disabled]:cursor-not-allowed"
      )}
      {...props}
    >
      <span
        className={clsx(
          "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2",
          "h-10 w-10 rounded-full bg-graphite-primary/20 transition-transform",
          isHoveredOrActive ? "scale-100" : "scale-0"
        )}
      />
      <AnimatePresence>
        {isHoveredOrActive && (
          <motion.div
            initial={{ opacity: 0, y: 4, scale: 0.8 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: 4, scale: 0.8 }}
            transition={{ duration: 0.15, ease: "easeOut" }}
            className="absolute bottom-full left-1/2 mb-3 -translate-x-1/2"
          >
            <div className="rounded-lg bg-graphite-secondary px-2 py-1 shadow-md">
              <Typography
                variant="small"
                className="font-semibold text-graphite-secondaryForeground"
              >
                {value}
              </Typography>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </RadixSlider.Thumb>
  );
});
LinearThumb.displayName = "LinearThumb";

const BarThumb = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<typeof RadixSlider.Thumb>
>((props, ref) => {
  const { size, direction } = useSliderContext();
  const [isHoveredOrActive, setIsHoveredOrActive] = useState(false);

  return (
    <RadixSlider.Thumb
      ref={ref}
      onPointerEnter={() => setIsHoveredOrActive(true)}
      onPointerLeave={() => setIsHoveredOrActive(false)}
      className={barThumbVariants({ size, direction })}
      {...props}
    >
      <span
        className={clsx(
          "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-transform",
          isHoveredOrActive ? "scale-100" : "scale-0",
          barThumbHaloVariants({ size, direction })
        )}
      />
    </RadixSlider.Thumb>
  );
});
BarThumb.displayName = "BarThumb";

// --- Main Slider Component ---

type SliderProps = React.ComponentPropsWithoutRef<typeof RadixSlider.Root> & {
  variant?: "linear" | "bar";
  direction?: "horizontal" | "vertical";
  size?: "sm" | "md" | "lg" | "xl" | "2xl";
};

const Slider = React.forwardRef<
  React.ElementRef<typeof RadixSlider.Root>,
  SliderProps
>(
  (
    {
      className,
      value,
      variant = "linear",
      direction = "horizontal",
      size = "lg",
      ...props
    },
    ref
  ) => {
    const isRange = Array.isArray(value);

    return (
      <SliderContext.Provider value={{ variant, direction, size }}>
        <RadixSlider.Root
          ref={ref}
          value={value}
          orientation={direction}
          className={clsx(sliderRootVariants({ direction }), className)}
          {...props}
        >
          <RadixSlider.Track
            className={sliderTrackVariants({ variant, direction, size })}
          >
            <RadixSlider.Range className={sliderRangeVariants({ direction })} />
          </RadixSlider.Track>

          {variant === "linear" ? (
            isRange ? (
              <>
                <LinearThumb value={value[0]} key="thumb-start" />
                <LinearThumb value={value[1]} key="thumb-end" />
              </>
            ) : (
              <LinearThumb value={value?.[0] ?? 0} />
            )
          ) : isRange ? (
            <>
              <BarThumb key="thumb-start" />
              <BarThumb key="thumb-end" />
            </>
          ) : (
            <BarThumb />
          )}
        </RadixSlider.Root>
      </SliderContext.Provider>
    );
  }
);
Slider.displayName = "Slider";

export { Slider };
```

**Storybook Stories (`Slider.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { Typography } from "../typography";
import { Slider } from "./index";

const meta: Meta<typeof Slider> = {
  title: "Components/Forms & Inputs/Slider",
  component: Slider,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A slider component inspired by Material Design 3 for selecting a value or range of values. It supports 'linear' and 'bar' variants, as well as 'horizontal' and 'vertical' directions.",
      },
    },
  },
  argTypes: {
    variant: {
      control: "select",
      options: ["linear", "bar"],
    },
    direction: {
      control: "select",
      options: ["horizontal", "vertical"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg", "xl", "2xl"],
      if: { arg: "variant", eq: "bar" },
    },
    disabled: { control: "boolean" },
    min: { control: "number" },
    max: { control: "number" },
    step: { control: "number" },
    minStepsBetweenThumbs: { control: "number" },
    onValueChange: { action: "value changed" },
  },
};

export default meta;
type Story = StoryObj<typeof Slider>;

export const Linear: Story = {
  name: "1. Linear (Single Value)",
  args: {
    variant: "linear",
    defaultValue: [50],
    max: 100,
    step: 1,
  },
  render: function Render(args) {
    const [value, setValue] = useState(args.defaultValue);

    return (
      <div className="w-80">
        <Typography variant="large" className="text-center">
          Volume: {value?.[0]}
        </Typography>
        <Slider {...args} value={value} onValueChange={setValue} />
      </div>
    );
  },
};

export const LinearRange: Story = {
  name: "2. Linear (Range)",
  args: {
    variant: "linear",
    defaultValue: [25, 75],
    max: 100,
    step: 1,
    minStepsBetweenThumbs: 10,
  },
  render: function Render(args) {
    const [range, setRange] = useState(args.defaultValue);

    return (
      <div className="w-80">
        <Typography variant="large" className="text-center">
          Price Range: ${range?.[0]} - ${range?.[1]}
        </Typography>
        <Slider {...args} value={range} onValueChange={setRange} />
      </div>
    );
  },
};

export const BarVariant: Story = {
  name: "3. Bar Variant (All Sizes)",
  args: {
    variant: "bar",
    defaultValue: [60],
    max: 100,
  },
  render: (args) => (
    <div className="w-80 flex flex-col gap-8">
      <div>
        <Typography variant="small" className="font-semibold">
          Size: sm
        </Typography>
        <Slider {...args} size="sm" />
      </div>
      <div>
        <Typography variant="small" className="font-semibold">
          Size: md
        </Typography>
        <Slider {...args} size="md" />
      </div>
      <div>
        <Typography variant="small" className="font-semibold">
          Size: lg
        </Typography>
        <Slider {...args} size="lg" />
      </div>
      <div>
        <Typography variant="small" className="font-semibold">
          Size: xl
        </Typography>
        <Slider {...args} size="xl" />
      </div>
      <div>
        <Typography variant="small" className="font-semibold">
          Size: 2xl
        </Typography>
        <Slider {...args} size="2xl" />
      </div>
    </div>
  ),
};

export const VerticalDirection: Story = {
  name: "4. Vertical Direction",
  args: {
    direction: "vertical",
    defaultValue: [50],
    max: 100,
  },
  render: (args) => (
    <div className="flex h-64 items-center justify-center gap-16">
      <div>
        <Typography variant="h4" className="mb-4 text-center">
          Linear
        </Typography>
        <Slider {...args} variant="linear" />
      </div>
      <div>
        <Typography variant="h4" className="mb-4 text-center">
          Bar
        </Typography>
        <Slider {...args} variant="bar" size="lg" />
      </div>
      <div>
        <Typography variant="h4" className="mb-4 text-center">
          Bar (Range)
        </Typography>
        <Slider {...args} variant="bar" size="xl" defaultValue={[20, 80]} />
      </div>
    </div>
  ),
};

export const Disabled: Story = {
  name: "5. Disabled State",
  render: () => (
    <div className="w-80 flex flex-col gap-8">
      <div>
        <Typography variant="small" className="mb-2">
          Linear (Disabled)
        </Typography>
        <Slider variant="linear" defaultValue={[50]} disabled />
      </div>
      <div>
        <Typography variant="small" className="mb-2">
          Bar (Disabled)
        </Typography>
        <Slider variant="bar" size="lg" defaultValue={[20, 80]} disabled />
      </div>
    </div>
  ),
};
```


### Component: `split-button`

This section contains the source code for the `split-button` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\split-button\index.tsx`)**
```tsx
import { clsx } from "clsx";
import React from "react";

type ButtonShape = "full" | "minimal" | "sharp";

// Define a type for the children we expect. They must be ReactElements
// and we expect them to have a className prop.
type SplitButtonChildren = [
  React.ReactElement<{ className?: string }>,
  React.ReactElement<{ className?: string }>
];

interface SplitButtonProps extends React.HTMLAttributes<HTMLDivElement> {
  children: SplitButtonChildren;
  shape?: ButtonShape;
}

export const SplitButton = ({
  children,
  className,
  shape = "full",
  ...props
}: SplitButtonProps) => {
  // A runtime check for safety, though TypeScript now enforces the type
  if (React.Children.count(children) !== 2) {
    console.error("SplitButton requires exactly two children.");
    return null;
  }

  // TypeScript now knows mainAction and dropdownTrigger have a .props.className property
  const [mainAction, dropdownTrigger] = children;

  const shapeClasses: Record<ButtonShape, { left: string; right: string }> = {
    full: { left: "rounded-l-full", right: "rounded-r-full" },
    minimal: { left: "rounded-l-lg", right: "rounded-r-lg" },
    sharp: { left: "rounded-l-none", right: "rounded-r-none" },
  };

  const clonedMainAction = React.cloneElement(mainAction, {
    className: clsx(
      mainAction.props.className, // No more error here
      shapeClasses[shape].left,
      shape === "sharp" ? "!rounded-r-none" : "!rounded-r-xs"
    ),
  });

  const clonedDropdownTrigger = React.cloneElement(dropdownTrigger, {
    className: clsx(
      dropdownTrigger.props.className, // No more error here
      shapeClasses[shape].right,
      shape === "sharp" ? "!rounded-l-none" : "!rounded-l-xs"
    ),
  });

  return (
    <div
      className={clsx("inline-flex items-center gap-0.5", className)}
      {...props}
    >
      {clonedMainAction}
      {clonedDropdownTrigger}
    </div>
  );
};

SplitButton.displayName = "SplitButton";
```

**Storybook Stories (`Split-button.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { ChevronDown, Plus } from "lucide-react";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { SplitButton } from "./index";

const meta: Meta<typeof SplitButton> = {
  title: "Components/Buttons/SplitButton",
  component: SplitButton,
  tags: ["autodocs"],
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
  parameters: {
    docs: {
      description: {
        component:
          "A split button combines a primary action button with a secondary trigger button. It maintains a small gap and applies specific rounding to the outer edges.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    shape: "full",
  },
  render: (args) => (
    <SplitButton {...args}>
      <Button variant="primary">
        <Plus className="mr-2 h-4 w-4" />
        Create
      </Button>
      <IconButton variant="primary" aria-label="More options">
        <ChevronDown className="h-4 w-4" />
      </IconButton>
    </SplitButton>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-col items-start gap-6">
      <SplitButton shape="full">
        <Button variant="secondary">Full Shape</Button>
        <IconButton variant="secondary" aria-label="Options for Full Shape">
          <ChevronDown className="h-4 w-4" />
        </IconButton>
      </SplitButton>
      <SplitButton shape="minimal">
        <Button variant="secondary">Minimal Shape</Button>
        <IconButton variant="secondary" aria-label="Options for Minimal Shape">
          <ChevronDown className="h-4 w-4" />
        </IconButton>
      </SplitButton>
      <SplitButton shape="sharp">
        <Button variant="secondary">Sharp Shape</Button>
        <IconButton variant="secondary" aria-label="Options for Sharp Shape">
          <ChevronDown className="h-4 w-4" />
        </IconButton>
      </SplitButton>
    </div>
  ),
};

export const DifferentSizes: Story = {
  name: "Different Button Sizes",
  render: () => (
    <SplitButton shape="minimal">
      <Button variant="primary" size="lg">
        Large Action
      </Button>
      <IconButton
        variant="primary"
        size="lg"
        aria-label="Options for Large Action"
      >
        <ChevronDown className="h-5 w-5" />
      </IconButton>
    </SplitButton>
  ),
};
```


### Component: `stack-router`

This section contains the source code for the `stack-router` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\stack-router\index.tsx`)**
```tsx
"use client";

import { clsx } from "clsx";
import {
  AnimatePresence,
  motion,
  type Transition,
  type Variants,
} from "framer-motion";
import { ArrowLeft } from "lucide-react";
import React, {
  createContext,
  useContext,
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
  type RefObject,
} from "react";
import { AppBar, type AppBarSharedProps } from "../appbar";
import { IconButton } from "../icon-button";
import { STACK_TRANSITIONS } from "./transitions";

// --- INLINED TYPE DEFINITIONS (from types.ts) ---

// Base types
export interface Route<
  T extends Record<string, object | undefined>,
  R extends keyof T
> {
  key: string;
  name: R;
  params: T[R];
}

export type RouteProp<
  T extends Record<string, object | undefined>,
  R extends keyof T
> = Route<T, R>;

export interface NavigationProp<T extends Record<string, object | undefined>> {
  navigate: <R extends keyof T>(name: R, params: T[R]) => void;
  push: <R extends keyof T>(name: R, params?: T[R]) => void;
  replace: <R extends keyof T>(name: R, params: T[R]) => void;
  goBack: () => void;
  pop: (count?: number) => void;
  popToTop: () => void;
  canGoBack: () => boolean;
  addListener: (
    event: NavigationEvent,
    callback: NavigationEventCallback
  ) => () => void;
  removeListener: (
    event: NavigationEvent,
    callback: NavigationEventCallback
  ) => void;
  scrollContainerRef: RefObject<any | null>;
}

export interface StackScreenProps<
  T extends Record<string, object | undefined>,
  R extends keyof T
> {
  navigation: NavigationProp<T>;
  route: RouteProp<T, R>;
}

export type NavigationEvent = "transitionStart" | "transitionEnd";
export type NavigationEventCallback = (event: {
  data: { closing: boolean };
}) => void;

export interface StackNavigationState<
  T extends Record<string, object | undefined>
> {
  index: number;
  routes: Route<T, keyof T>[];
}

// Options for each screen
export interface StackScreenOptions {
  title?: string;
  headerTitle?:
    | React.ReactNode
    | ((props: {
        navigation: NavigationProp<any>;
        route: RouteProp<any, any>; // <-- Pass route here too
      }) => React.ReactNode);
  headerShown?: boolean;
  headerLeft?: (props: { canGoBack: boolean }) => React.ReactNode;
  headerRight?: (props: { canGoBack: boolean }) => React.ReactNode;
  headerStyle?: {
    backgroundColor?: "background" | "card" | "primary" | "secondary";
  };
  appBarProps?: AppBarSharedProps;
  animation?:
    | "default"
    | "none"
    | "fade"
    | "zoom-fade"
    | "flip"
    | "fade-from-right"
    | "fade-from-left"
    | "fade-from-top"
    | "fade-from-bottom"
    | "slide-from-left"
    | "slide-from-right"
    | "slide-from-top"
    | "slide-from-bottom"
    | { variants: any; transition: any };
  pageClassName?: string;
  headerAnimationEnabled?: boolean;
}

export interface StackScreenComponent<
  T extends Record<string, object | undefined>,
  R extends keyof T
> {
  props: {
    name: R;
    component: React.ComponentType<StackScreenProps<T, R>>;
    options?:
      | StackScreenOptions
      | ((props: { route: RouteProp<T, R> }) => StackScreenOptions);
  };
}

// --- Contexts ---
const NavigationContext = createContext<
  NavigationProp<Record<string, object | undefined>> | undefined
>(undefined);
const RouteContext = createContext<
  Route<Record<string, object | undefined>, string> | undefined
>(undefined);

// --- Hooks ---
export function useNavigation<T extends Record<string, object | undefined>>() {
  const navigation = useContext(NavigationContext);
  if (!navigation) {
    throw new Error(
      "useNavigation must be used within a screen of a StackNavigator."
    );
  }
  return navigation as NavigationProp<T>;
}

export function useRoute<
  T extends Record<string, object | undefined>,
  R extends keyof T
>() {
  const route = useContext(RouteContext);
  if (!route) {
    throw new Error(
      "useRoute must be used within a screen of a StackNavigator."
    );
  }
  return route as RouteProp<T, R>;
}

const HeaderLeft = <T extends Record<string, object | undefined>>({
  options,
  navigation,
}: {
  options: StackScreenOptions;
  navigation: NavigationProp<T>;
}) => {
  if (options.headerLeft) {
    return options.headerLeft({ canGoBack: navigation.canGoBack() });
  }
  if (navigation.canGoBack()) {
    return (
      <IconButton variant="ghost" onClick={navigation.goBack}>
        <ArrowLeft />
      </IconButton>
    );
  }
  return null;
};

const HeaderRight = <T extends Record<string, object | undefined>>({
  options,
  navigation,
}: {
  options: StackScreenOptions;
  navigation: NavigationProp<T>;
}) => {
  if (options.headerRight) {
    return options.headerRight({ canGoBack: navigation.canGoBack() });
  }
  return null;
};

// --- MODIFIED: Internal Header Component ---
const Header = <T extends Record<string, object | undefined>>({
  options,
  screenName,
  navigation,
  route,
  scrollContainerRef,
  routeKey,
}: {
  options: StackScreenOptions;
  screenName?: keyof T;
  navigation: NavigationProp<T>;
  route: RouteProp<T, keyof T>;
  scrollContainerRef: React.RefObject<HTMLElement | null>;
  routeKey: string;
}) => {
  if (options.headerShown === false) return null;

  const title = options.headerTitle || options.title || screenName;
  const headerAnimationEnabled = options.headerAnimationEnabled ?? true;

  const contentAnimation: Variants = {
    initial: { opacity: 0.2, y: -5 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0.2, y: 5 },
  };
  const contentTransition: Transition = headerAnimationEnabled
    ? { duration: 0.12, ease: "easeInOut" }
    : { duration: 0 };

  return (
    <AppBar
      {...options.appBarProps}
      routeKey={routeKey}
      scrollContainerRef={scrollContainerRef}
      appBarColor={options.headerStyle?.backgroundColor || "card"}
      startAdornment={
        <AnimatePresence mode="wait">
          <motion.div
            key={`${routeKey}-left`}
            variants={contentAnimation}
            transition={contentTransition}
            initial="initial"
            animate="animate"
            exit="exit"
          >
            <HeaderLeft options={options} navigation={navigation} />
          </motion.div>
        </AnimatePresence>
      }
      endAdornments={
        // @ts-ignore
        <HeaderRight options={options} navigation={navigation} /> ? (
          [
            <AnimatePresence mode="wait" key={`${routeKey}-right-presence`}>
              <motion.div
                key={`${routeKey}-right`}
                variants={contentAnimation}
                transition={contentTransition}
                initial="initial"
                animate="animate"
                exit="exit"
              >
                <HeaderRight options={options} navigation={navigation} />
              </motion.div>
            </AnimatePresence>,
          ]
        ) : undefined
      }
    >
      <AnimatePresence mode="wait">
        <motion.div
          key={`${routeKey}-title`}
          variants={contentAnimation}
          transition={contentTransition}
          initial="initial"
          animate="animate"
          exit="exit"
          className="truncate"
        >
          {typeof title === "function"
            ? title({ navigation, route }) // Pass route to headerTitle function
            : (title as React.ReactNode)}
        </motion.div>
      </AnimatePresence>
    </AppBar>
  );
};

// --- Main Navigator Logic ---
interface StackNavigatorProps<T extends Record<string, object | undefined>> {
  initialRouteName: keyof T;
  children:
    | React.ReactElement<StackScreenComponent<T, keyof T>["props"]>
    | React.ReactElement<StackScreenComponent<T, keyof T>["props"]>[];
}

const StackNavigator = <T extends Record<string, object | undefined>>({
  initialRouteName,
  children,
}: StackNavigatorProps<T>) => {
  const screens = useMemo(() => {
    const screenConfig: Record<
      string,
      StackScreenComponent<T, keyof T>["props"]
    > = {};
    React.Children.forEach(
      children,
      (
        child: React.ReactElement<StackScreenComponent<T, keyof T>["props"]>
      ) => {
        if (React.isValidElement(child)) {
          screenConfig[child.props.name as string] = child.props;
        }
      }
    );
    return screenConfig;
  }, [children]);

  const [state, setState] = useState<StackNavigationState<T>>(() => {
    if (typeof window !== "undefined" && window.history.state?.routes) {
      return window.history.state as StackNavigationState<T>;
    }
    return {
      index: 0,
      routes: [
        {
          key: `${String(initialRouteName)}-${Date.now()}`,
          name: initialRouteName,
          params: undefined,
        },
      ],
    };
  });

  const listeners = useRef<
    Record<NavigationEvent, Set<NavigationEventCallback>>
  >({
    transitionStart: new Set(),
    transitionEnd: new Set(),
  }).current;

  useLayoutEffect(() => {
    if (typeof window !== "undefined" && !window.history.state?.routes) {
      window.history.replaceState(state, "");
    }
  }, [state]);

  useEffect(() => {
    const handlePopState = (event: PopStateEvent) => {
      if (event.state && event.state.routes) {
        setState(event.state as StackNavigationState<T>);
      }
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  const scrollContainerRef = useRef<HTMLElement | null>(null);
  const currentRoute = state.routes[state.index];
  const screen = screens[currentRoute.name as string];

  // --- THIS IS THE KEY FIX ---
  // Resolve options ONCE here, and pass the resulting object down.
  const activeScreenOptions =
    typeof screen?.options === "function"
      ? screen.options({
          route: currentRoute as RouteProp<T, keyof T>,
        })
      : screen?.options || {};
  // --- END OF FIX ---

  const activeAnimationOption = activeScreenOptions.animation || "default";
  const activeAnimationConfig =
    typeof activeAnimationOption === "string"
      ? STACK_TRANSITIONS[activeAnimationOption] || STACK_TRANSITIONS.default
      : activeAnimationOption;

  const navigation = useMemo((): NavigationProp<T> => {
    const canGoBack = () => state.index > 0;

    return {
      navigate: (name, params) => {
        const newRoute: Route<T, keyof T> = {
          key: `${String(name)}-${Date.now()}`,
          name,
          params,
        };
        const newState: StackNavigationState<T> = {
          index: state.routes.length,
          routes: [...state.routes, newRoute],
        };
        window.history.pushState(newState, "");
        setState(newState);
      },
      push: (name, params) => {
        const newRoute: Route<T, keyof T> = {
          key: `${String(name)}-${Date.now()}`,
          name,
          params,
        };
        const newState: StackNavigationState<T> = {
          index: state.routes.length,
          routes: [...state.routes, newRoute],
        };
        window.history.pushState(newState, "");
        setState(newState);
      },
      replace: (name, params) => {
        const newRoute: Route<T, keyof T> = {
          key: `${String(name)}-${Date.now()}`,
          name,
          params,
        };
        const newRoutes = [...state.routes.slice(0, -1), newRoute];
        const newState: StackNavigationState<T> = {
          index: newRoutes.length - 1,
          routes: newRoutes,
        };
        window.history.replaceState(newState, "");
        setState(newState);
      },
      goBack: () => {
        if (canGoBack()) {
          window.history.back();
        }
      },
      pop: (count = 1) => {
        if (canGoBack()) {
          window.history.go(-count);
        }
      },
      popToTop: () => {
        if (canGoBack()) {
          window.history.go(-state.index);
        }
      },
      canGoBack,
      addListener: (event, callback) => {
        listeners[event].add(callback);
        return () => listeners[event].delete(callback);
      },
      removeListener: (event, callback) => {
        listeners[event].delete(callback);
      },
      scrollContainerRef,
    };
  }, [state.index, state.routes, listeners]);

  const handleAnimationStart = (isPop: boolean) => {
    listeners.transitionStart.forEach((cb) => cb({ data: { closing: isPop } }));
  };

  const handleAnimationComplete = (isPop: boolean) => {
    listeners.transitionEnd.forEach((cb) => cb({ data: { closing: isPop } }));
  };

  return (
    <div className="relative h-full w-full overflow-hidden bg-graphite-background">
      {/* Pass the RESOLVED options object to the header */}
      <Header
        options={activeScreenOptions}
        screenName={screen?.name}
        navigation={navigation}
        route={currentRoute as RouteProp<T, keyof T>}
        scrollContainerRef={scrollContainerRef}
        routeKey={currentRoute.key}
      />
      <div className="relative h-full w-full">
        <AnimatePresence
          initial={false}
          onExitComplete={() => handleAnimationComplete(true)}
        >
          {state.routes.map((route, index) => {
            const screenConfig = screens[route.name as string];

            if (!screenConfig) {
              console.error(
                `Stack Router Error: No screen component found for route name "${String(
                  route.name
                )}". Did you forget to add a <Stack.Screen name="${String(
                  route.name
                )}" /> component?`
              );
              return null;
            }
            const Component = screenConfig.component;

            const screenOptions =
              typeof screenConfig.options === "function"
                ? screenConfig.options({
                    route: route as RouteProp<T, keyof T>,
                  })
                : screenConfig.options || {};
            const pageClassName = screenOptions.pageClassName;

            const isActive = index === state.index;
            const variantName = isActive ? "center" : "behind";

            return (
              <motion.div
                key={route.key}
                variants={activeAnimationConfig.variants}
                transition={activeAnimationConfig.transition}
                initial="enter"
                animate={variantName}
                exit="exit"
                onAnimationStart={
                  isActive ? () => handleAnimationStart(false) : undefined
                }
                onAnimationComplete={
                  isActive ? () => handleAnimationComplete(false) : undefined
                }
                style={{
                  zIndex: index,
                  willChange: "transform, opacity",
                }}
                className={clsx(
                  "absolute inset-x-0 bottom-0 top-0 bg-graphite-background",
                  pageClassName
                )}
              >
                <NavigationContext.Provider value={navigation}>
                  {/* @ts-ignore */}
                  <RouteContext.Provider value={route}>
                    <Component
                      navigation={navigation}
                      route={route as RouteProp<T, keyof T>}
                    />
                  </RouteContext.Provider>
                </NavigationContext.Provider>
              </motion.div>
            );
          })}
        </AnimatePresence>
      </div>
    </div>
  );
};

// --- Factory Function ---
export function createStackNavigator<
  T extends Record<string, object | undefined>
>() {
  const Screen = <R extends keyof T>(
    _props: StackScreenComponent<T, R>["props"]
  ) => {
    return null;
  };

  return {
    Navigator: (props: StackNavigatorProps<T>) => <StackNavigator {...props} />,
    Screen,
  };
}
```

**Storybook Stories (`stack-router.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Mail, MoreVertical, Search } from "lucide-react";
import { Button } from "../button";
import DeviceFrame from "../device";
import { ElasticScrollArea } from "../elastic-scroll-area";
import { IconButton } from "../icon-button";
import { Input } from "../input";
import { Item, ItemContent, ItemTitle } from "../item";
import { Typography } from "../typography";
import { createStackNavigator, useNavigation, useRoute } from "./index";
import type { RouteProp } from "./types";

const meta: Meta = {
  title: "Components/Navigators/StackRouter",
  component: undefined, // Component is a factory, not a single element
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A stack navigator that mimics the React Navigation API for the web. It uses `AppBar` for headers and Framer Motion for smooth, native-like screen transitions. Create a navigator instance with `createStackNavigator()`.",
      },
    },
  },
  decorators: [
    (Story) => (
      <DeviceFrame>
        <Story />
      </DeviceFrame>
    ),
  ],
};
export default meta;

// --- 1. Basic Navigation Example ---
type BasicStackParamList = {
  Home: undefined;
  Profile: { userId: string; name: string };
};
const BasicStack = createStackNavigator<BasicStackParamList>();

const HomeScreen = () => {
  const navigation = useNavigation<BasicStackParamList>();
  return (
    <div className="p-6 pt-[70px]" ref={navigation.scrollContainerRef}>
      <Typography variant="h4">Home Screen</Typography>
      <Typography variant="p">
        This is the initial screen of the stack.
      </Typography>
      <Button
        className="mt-4"
        onClick={() =>
          navigation.push("Profile", { userId: "user-123", name: "Alice" })
        }
      >
        Go to Alice's Profile
      </Button>
    </div>
  );
};

const ProfileScreen = () => {
  const navigation = useNavigation<BasicStackParamList>();
  const route = useRoute<BasicStackParamList, "Profile">();
  const { userId, name } = route.params;

  return (
    <div className="p-6 pt-[70px]" ref={navigation.scrollContainerRef}>
      <Typography variant="h4">Profile Screen</Typography>
      <Typography variant="p">User: {name}</Typography>
      <Typography variant="muted">ID: {userId}</Typography>
      <Button
        className="mt-4"
        variant="secondary"
        size={"sm"}
        onClick={() => navigation.goBack()}
      >
        Go Back Manually
      </Button>
    </div>
  );
};

export const BasicNavigation: StoryObj = {
  name: "1. Basic Navigation",
  render: () => (
    <BasicStack.Navigator initialRouteName="Home">
      <BasicStack.Screen name="Home" component={HomeScreen} />
      <BasicStack.Screen name="Profile" component={ProfileScreen} />
    </BasicStack.Navigator>
  ),
};

// --- 2. Header Customization Example ---
type HeaderStackParamList = {
  Feed: undefined;
  Article: { articleId: string };
  Settings: undefined;
};
const HeaderStack = createStackNavigator<HeaderStackParamList>();

const FeedScreen = () => {
  const navigation = useNavigation<HeaderStackParamList>();

  return (
    <div className="p-6 pt-[70px]" ref={navigation.scrollContainerRef}>
      <Typography variant="h4">Feed</Typography>
      <div className="flex flex-col gap-4 mt-4">
        <Button onClick={() => navigation.push("Article", { articleId: "a1" })}>
          Go to Article (Custom Header)
        </Button>
        <Button variant="secondary" onClick={() => navigation.push("Settings")}>
          Go to Settings (No Header)
        </Button>
      </div>
    </div>
  );
};

const ArticleScreen = () => {
  const navigation = useNavigation<BasicStackParamList>();

  return (
    <div className="p-6 pt-[70px]" ref={navigation.scrollContainerRef}>
      <Typography variant="large">This is the article content.</Typography>
    </div>
  );
};
const SettingsScreen = () => {
  return (
    <div className="p-6 pt-6">
      <Typography variant="h4">Settings</Typography>
      <Typography variant="p">This screen has no header.</Typography>
    </div>
  );
};

export const HeaderCustomization: StoryObj = {
  name: "2. Header Customization",
  render: () => (
    <HeaderStack.Navigator initialRouteName="Feed">
      <HeaderStack.Screen name="Feed" component={FeedScreen} />
      <HeaderStack.Screen
        name="Article"
        component={ArticleScreen}
        options={{
          title: "Article Details",
          headerRight: () => (
            <IconButton variant="ghost">
              <MoreVertical />
            </IconButton>
          ),
        }}
      />
      <HeaderStack.Screen
        name="Settings"
        component={SettingsScreen}
        options={{ headerShown: false }}
      />
    </HeaderStack.Navigator>
  ),
};

// --- 3. Transition Presets Example ---
type AnimationStackParamList = {
  Main: undefined;
  None: undefined;
  Fade: undefined;
  ZoomFade: undefined;
  FadeRight: undefined;
  FadeLeft: undefined;
  FadeTop: undefined;
  FadeBottom: undefined;
  Flip: undefined;
  SlideRight: undefined;
  SlideBottom: undefined;
  SlideLeft: undefined;
  SlideTop: undefined;
};
const AnimationStack = createStackNavigator<AnimationStackParamList>();

const MainScreen = () => {
  const navigation = useNavigation<AnimationStackParamList>();

  return (
    <ElasticScrollArea
      scrollbarVisibility="hidden"
      className="pt-[70px]"
      ref={navigation.scrollContainerRef}
    >
      <div className="box-border p-4 flex flex-col gap-4 mt-4">
        <Typography variant="h4">Animation Presets</Typography>
        <Button className="w-fit" onClick={() => navigation.push("None")}>
          Push with 'None'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("Fade")}>
          Push with 'Fade'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("ZoomFade")}>
          Push with 'ZoomFade'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("FadeRight")}>
          Push with 'Fade From Right'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("FadeLeft")}>
          Push with 'Fade From Left'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("FadeTop")}>
          Push with 'Fade From Top'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("FadeBottom")}>
          Push with 'Fade From Bottom'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("Flip")}>
          Push with 'Flip'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("SlideRight")}>
          Push with 'Slide From Right' (defualt)
        </Button>
        <Button
          className="w-fit"
          onClick={() => navigation.push("SlideBottom")}
        >
          Push with 'Slide from Bottom'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("SlideLeft")}>
          Push with 'Slide from Left'
        </Button>
        <Button className="w-fit" onClick={() => navigation.push("SlideTop")}>
          Push with 'Slide from Top'
        </Button>
      </div>
    </ElasticScrollArea>
  );
};

const GenericScreen = ({ route }: { route: RouteProp<any, any> }) => {
  const navigation = useNavigation<AnimationStackParamList>();

  return (
    <div className="p-6 pt-[70px]" ref={navigation.scrollContainerRef}>
      <Typography variant="h4">{route.name} Screen</Typography>
      <Typography variant="p">
        This screen transitioned using its specified animation preset.
      </Typography>
      <Button
        className="mt-4"
        variant="secondary"
        size={"sm"}
        onClick={() => navigation.goBack()}
      >
        Go Back
      </Button>
    </div>
  );
};

export const TransitionPresets: StoryObj = {
  name: "3. Transition Presets",
  render: () => (
    <AnimationStack.Navigator initialRouteName="Main">
      <AnimationStack.Screen name="Main" component={MainScreen} />
      <AnimationStack.Screen
        name="None"
        component={GenericScreen}
        options={{ animation: "none" }}
      />
      <AnimationStack.Screen
        name="Fade"
        component={GenericScreen}
        options={{ animation: "fade" }}
      />
      <AnimationStack.Screen
        name="ZoomFade"
        component={GenericScreen}
        options={{ animation: "zoom-fade" }}
      />
      <AnimationStack.Screen
        name="FadeRight"
        component={GenericScreen}
        options={{ animation: "fade-from-right" }}
      />
      <AnimationStack.Screen
        name="FadeLeft"
        component={GenericScreen}
        options={{ animation: "fade-from-left" }}
      />
      <AnimationStack.Screen
        name="FadeTop"
        component={GenericScreen}
        options={{ animation: "fade-from-top" }}
      />
      <AnimationStack.Screen
        name="FadeBottom"
        component={GenericScreen}
        options={{ animation: "fade-from-bottom" }}
      />

      <AnimationStack.Screen
        name="Flip"
        component={GenericScreen}
        options={{ animation: "flip" }}
      />
      <AnimationStack.Screen
        name="SlideRight"
        component={GenericScreen}
        options={{
          animation: "default",
          pageClassName: "shadow-md",
        }}
      />
      <AnimationStack.Screen
        name="SlideBottom"
        component={GenericScreen}
        options={{ animation: "slide-from-bottom" }}
      />
      <AnimationStack.Screen
        name="SlideLeft"
        component={GenericScreen}
        options={{ animation: "slide-from-left" }}
      />
      <AnimationStack.Screen
        name="SlideTop"
        component={GenericScreen}
        options={{ animation: "slide-from-top" }}
      />
    </AnimationStack.Navigator>
  ),
};

// --- 4. Mail App Example ---
type MailStackParamList = {
  Inbox: undefined;
  Email: { emailId: number; subject: string };
};
const MailStack = createStackNavigator<MailStackParamList>();
const emails = Array.from({ length: 10 }, (_, i) => ({
  id: i + 1,
  from: ["Alice", "Bob", "Charlie", "Diana", "Ethan"][i % 5],
  subject: [
    "Project Update",
    "Lunch Plans",
    "Weekly Report",
    "Design Feedback",
    "Q4 Roadmap",
  ][i % 5],
}));
const InboxScreen = () => {
  const navigation = useNavigation<MailStackParamList>();
  const { scrollContainerRef } = useNavigation();
  return (
    <ElasticScrollArea scrollbarVisibility="hidden" ref={scrollContainerRef}>
      <div className="pt-[120px] p-4">
        {emails.map((email) => (
          <Item
            key={email.id}
            variant="ghost"
            onClick={() =>
              navigation.navigate("Email", {
                emailId: email.id,
                subject: email.subject,
              })
            }
            className="cursor-pointer "
          >
            <ItemContent>
              <ItemTitle>{email.from}</ItemTitle>
              <Typography variant="muted">{email.subject}</Typography>
            </ItemContent>
          </Item>
        ))}
      </div>
    </ElasticScrollArea>
  );
};
const EmailScreen = () => {
  const route = useRoute<MailStackParamList, "Email">();
  const email = emails.find((e) => e.id === route.params.emailId);
  return (
    <div className="p-6 pt-[70px]">
      <Typography variant="h4">{email?.subject}</Typography>
      <Typography variant="muted" className="!mt-2">
        From: {email?.from}
      </Typography>
      <Typography variant="p">
        This is the body of the email. Lorem ipsum dolor sit amet, consectetur
        adipiscing elit...
      </Typography>
    </div>
  );
};
export const FullAppExample: StoryObj = {
  name: "4. Full App Example (Mail Client)",
  render: () => (
    <MailStack.Navigator initialRouteName="Inbox">
      <MailStack.Screen
        name="Inbox"
        component={InboxScreen}
        options={{
          title: "Inbox",
          headerRight: () => (
            <IconButton
              variant="ghost"
              onClick={() => alert("Compose new email!")}
            >
              <Mail />
            </IconButton>
          ),
          appBarProps: {
            size: "lg",
            scrollBehavior: "conditionally-sticky",
            largeHeaderRowHeight: 50,
            largeHeaderContent: (
              <Input
                variant="secondary"
                shape="full"
                startAdornment={<Search className="h-5 w-5 text-gray-500" />}
                placeholder="Search mail..."
              />
            ),
          },
        }}
      />
      <MailStack.Screen
        name="Email"
        component={EmailScreen}
        options={({
          route,
        }: {
          route: RouteProp<MailStackParamList, "Email">;
        }) => ({
          title: route.params.subject,
          animation: "default",
        })}
      />
    </MailStack.Navigator>
  ),
};
```


### Component: `switch`

This section contains the source code for the `switch` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\switch\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import React from "react";

// CVA for the track (the background)
const switchTrackVariants = cva(
  "transition-colors peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-graphite-ring peer-focus:ring-offset-2 peer-disabled:opacity-50 peer-disabled:cursor-not-allowed bg-graphite-border peer-checked:bg-graphite-primary",
  {
    variants: {
      size: {
        sm: "w-10 h-6",
        md: "w-12 h-7",
        lg: "w-14 h-8",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      size: "md",
      shape: "full",
    },
  }
);

// CVA for the thumb (the moving circle)
const switchThumbVariants = cva(
  "absolute bg-white transition-transform duration-200 ease-in-out shadow-lg",
  {
    variants: {
      size: {
        sm: "h-5 w-5 top-[2px] left-[2px]",
        md: "h-6 w-6 top-[2px] left-[2px]",
        lg: "h-7 w-7 top-[2px] left-[2px]",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      size: "md",
      shape: "full",
    },
  }
);

// Helper map for the translation distance based on size
const translateMap: Record<"sm" | "md" | "lg", string> = {
  sm: "peer-checked:translate-x-4",
  md: "peer-checked:translate-x-5",
  lg: "peer-checked:translate-x-6",
};

export interface SwitchProps
  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "size"> {
  size?: "sm" | "md" | "lg";
  shape?: "full" | "minimal" | "sharp";
  label?: string;
}

export const Switch = React.forwardRef<HTMLInputElement, SwitchProps>(
  ({ className, id, label, size = "md", shape = "full", ...props }, ref) => {
    const uniqueId = React.useId();
    const switchId = id || uniqueId;

    return (
      <label
        htmlFor={switchId}
        className={clsx(
          "inline-flex items-center cursor-pointer",
          className // Pass down className to the top-level label
        )}
      >
        <div className="relative">
          <input
            type="checkbox"
            ref={ref}
            id={switchId}
            className="sr-only peer"
            {...props}
          />
          {/* The Track */}
          <div className={clsx(switchTrackVariants({ size, shape }))} />
          {/* The Thumb */}
          <div
            className={clsx(
              switchThumbVariants({ size, shape }),
              translateMap[size]
            )}
          />
        </div>
        {label && (
          <div className="ml-3 text-sm font-medium text-graphite-foreground select-none">
            {label}
          </div>
        )}
      </label>
    );
  }
);

Switch.displayName = "Switch";
```

**Storybook Stories (`Switch.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { Switch } from "./index";

const meta: Meta<typeof Switch> = {
  title: "Components/Forms & Inputs/Switch",
  component: Switch,
  tags: ["autodocs"],
  argTypes: {
    label: { control: "text" },
    checked: { control: "boolean" },
    disabled: { control: "boolean" },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    label: "Airplane Mode",
  },
};

export const Checked: Story = {
  name: "On by Default",
  args: {
    label: "Enable Notifications",
    defaultChecked: true,
  },
};

export const Disabled: Story = {
  name: "Disabled States",
  render: () => (
    <div className="flex flex-col gap-4">
      <Switch disabled label="Off and Disabled" />
      <Switch disabled defaultChecked label="On and Disabled" />
    </div>
  ),
};

export const Interactive: Story = {
  name: "Interactive (Controlled)",
  render: () => {
    const [isEnabled, setIsEnabled] = useState(true);
    return (
      <div className="flex flex-col gap-2">
        <Switch
          checked={isEnabled}
          onChange={(e) => setIsEnabled(e.target.checked)}
          label="Feature Toggle"
        />
        <p className="text-sm text-gray-500">
          The feature is currently: {isEnabled ? "Enabled" : "Disabled"}
        </p>
      </div>
    );
  },
};

export const WithoutLabel: Story = {
  name: "Without a Label",
  args: {
    "aria-label": "A switch without a visible label",
  },
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-col items-start gap-6">
      <Switch size="sm" label="Small" defaultChecked />
      <Switch size="md" label="Medium (Default)" defaultChecked />
      <Switch size="lg" label="Large" defaultChecked />
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-col items-start gap-6">
      <Switch shape="full" label="Full (Default)" defaultChecked />
      <Switch shape="minimal" label="Minimal" defaultChecked />
      <Switch shape="sharp" label="Sharp" defaultChecked />
    </div>
  ),
};
```


### Component: `table`

This section contains the source code for the `table` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\table\index.tsx`)**
```tsx
"use client";

import {
  type ColumnDef,
  flexRender,
  type Row,
  type Table as TanstackTable,
} from "@tanstack/react-table";
import { useMediaQuery } from "@uidotdev/usehooks";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import React, { createContext, useContext, useMemo } from "react";

// --- Type Augmentation (Unchanged) ---
declare module "@tanstack/react-table" {
  interface ColumnMeta<TData, TValue> {
    isAccordionHeader?: boolean;
  }
}

// --- 1. TYPES & CONTEXT (Refactored for new API) ---

export type { ColumnDef };

// The responsive layout options are now simplified.
type ResponsiveLayout = "scroll" | "custom";

interface TableContextProps {
  table: TanstackTable<any>;
  responsiveLayout: ResponsiveLayout;
  isMobile: boolean;
}

const TableContext = createContext<TableContextProps | null>(null);

const useTableContext = <TData,>() => {
  const context = useContext(
    TableContext as React.Context<TableContextProps | null>
  );
  if (!context) {
    throw new Error("Table components must be used within a <Table.Root>");
  }
  return context as {
    table: TanstackTable<TData>;
    responsiveLayout: ResponsiveLayout;
    isMobile: boolean;
  };
};

// --- 2. CVA VARIANTS (Updated for new API) ---
const tableVariants = cva("w-full text-sm", {
  variants: {
    layout: {
      desktop: "table-auto border-collapse",
      scroll: "table-auto border-collapse",
      // 'custom' variant will be a flex container for the custom rendered items
      custom: "flex flex-col gap-3",
    },
  },
});

const thVariants = cva(
  "p-4 font-semibold text-left border-b border-graphite-border",
  {
    variants: {
      isFirstSticky: {
        true: "sticky left-0 z-10",
      },
      stickyCellVariant: {
        card: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
      },
    },
  }
);

const tdVariants = cva("p-4 border-b border-graphite-border align-top", {
  variants: {
    isFirstSticky: {
      true: "sticky left-0 z-10",
    },
    stickyCellVariant: {
      card: "bg-graphite-card",
      secondary: "bg-graphite-secondary",
    },
  },
});

// --- 3. SUB-COMPONENTS (Simplified) ---

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement> & { colIndex: number }
>(({ className, colIndex, ...props }, ref) => {
  const { responsiveLayout } = useTableContext();
  const { stickyCellVariant } = useContext(TableRootContext);
  const isFirstSticky = responsiveLayout === "scroll" && colIndex === 0;

  return (
    <th
      ref={ref}
      className={thVariants({ isFirstSticky, stickyCellVariant, className })}
      {...props}
    />
  );
});
TableHead.displayName = "Table.Head";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement> & { colIndex: number }
>(({ className, colIndex, ...props }, ref) => {
  const { responsiveLayout } = useTableContext();
  const { stickyCellVariant } = useContext(TableRootContext);
  const isFirstSticky = responsiveLayout === "scroll" && colIndex === 0;

  return (
    <td
      ref={ref}
      className={tdVariants({ isFirstSticky, stickyCellVariant, className })}
      {...props}
    />
  );
});
TableCell.displayName = "Table.Cell";

const TableRow = <TData extends {}>({
  row,
  ...rest
}: {
  row: Row<TData>;
  [key: string]: any;
}) => {
  // This component now only ever renders a `<tr>`, as the custom logic is handled in the root.
  return (
    <tr
      className={clsx("hover:bg-graphite-secondary/50", rest.className)}
      {...rest}
    >
      {row.getVisibleCells().map((cell, cellIndex) => (
        <TableCell key={cell.id} colIndex={cellIndex}>
          {flexRender(cell.column.columnDef.cell, cell.getContext())}
        </TableCell>
      ))}
    </tr>
  );
};
TableRow.displayName = "Table.Row";

// --- 4. ROOT COMPONENT (Refactored with Custom Render Prop) ---

export interface TableRootProps<TData>
  extends React.HTMLAttributes<HTMLTableElement> {
  table: TanstackTable<TData>;
  responsiveLayout?: ResponsiveLayout;
  breakpoint?: "sm" | "md" | "lg";
  stickyCellVariant?: "card" | "secondary";
  /**
   * A function to render a custom component for each row on mobile viewports.
   * Required when `responsiveLayout` is set to `'custom'`.
   * @param row The TanStack Table `row` object.
   */
  renderMobileRow?: (row: Row<TData>) => React.ReactNode;
}

const TableRootContext = createContext<
  Pick<TableRootProps<unknown>, "stickyCellVariant">
>({
  stickyCellVariant: "card",
});

const TableRoot = <TData extends {}>({
  className,
  table,
  responsiveLayout = "scroll",
  breakpoint = "md",
  stickyCellVariant = "card",
  renderMobileRow,
  ...props
}: TableRootProps<TData>) => {
  const breakpointMap = { sm: 640, md: 768, lg: 1024 };
  const isMobile = useMediaQuery(`(max-width: ${breakpointMap[breakpoint]}px)`);

  const contextValue = useMemo(
    () => ({ table, responsiveLayout, isMobile }),
    [table, responsiveLayout, isMobile]
  );

  const rootContextValue = useMemo(
    () => ({ stickyCellVariant }),
    [stickyCellVariant]
  );

  const layout = isMobile ? responsiveLayout : "desktop";

  // --- LOGIC FOR CUSTOM MOBILE RENDERER ---
  if (layout === "custom") {
    if (!renderMobileRow) {
      throw new Error(
        "The `renderMobileRow` prop is required when `responsiveLayout` is 'custom'."
      );
    }
    return (
      <TableContext.Provider value={contextValue}>
        <div className={tableVariants({ layout, className })} {...props}>
          {table.getRowModel().rows.map((row) => (
            // The key is now on the root element rendered by the user's function
            <React.Fragment key={row.id}>{renderMobileRow(row)}</React.Fragment>
          ))}
        </div>
      </TableContext.Provider>
    );
  }

  // --- LOGIC FOR DESKTOP & SCROLL LAYOUTS ---
  return (
    <TableRootContext.Provider value={rootContextValue}>
      <TableContext.Provider value={contextValue}>
        <div
          className={clsx(
            isMobile &&
              responsiveLayout === "scroll" &&
              "w-full overflow-x-auto"
          )}
        >
          <table className={tableVariants({ layout, className })} {...props}>
            <thead>
              {table.getHeaderGroups().map((headerGroup) => (
                <tr key={headerGroup.id}>
                  {headerGroup.headers.map((header, headerIndex) => (
                    <TableHead key={header.id} colIndex={headerIndex}>
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                    </TableHead>
                  ))}
                </tr>
              ))}
            </thead>
            <tbody>
              {table.getRowModel().rows.map((row) => (
                <TableRow key={row.id} row={row} />
              ))}
            </tbody>
          </table>
        </div>
      </TableContext.Provider>
    </TableRootContext.Provider>
  );
};
TableRoot.displayName = "Table";

export const Table = Object.assign(TableRoot, {
  Row: TableRow,
  Head: TableHead,
  Cell: TableCell,
});
```

**Storybook Stories (`Table.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  flexRender,
  getCoreRowModel,
  useReactTable,
  type ColumnDef,
  type Row,
} from "@tanstack/react-table";
import { Badge } from "../badge";
import { Card } from "../card";
import { Typography } from "../typography";
import { Table, type TableRootProps } from "./index";

const meta: Meta<TableRootProps<Payment>> = {
  title: "Components/Data/Table",
  component: Table,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A versatile and responsive data table powered by TanStack Table. It displays data in a standard table on desktop and can transform into a horizontally scrollable table or a fully custom layout on mobile.",
      },
    },
  },
  argTypes: {
    responsiveLayout: {
      control: "select",
      options: ["scroll", "custom"],
      description: "Determines the table's layout on mobile viewports.",
    },
    breakpoint: {
      control: "select",
      options: ["sm", "md", "lg"],
      description: "The viewport width at which the layout becomes responsive.",
    },
    stickyCellVariant: {
      control: "select",
      options: ["card", "secondary"],
      description: "Background color for the sticky column in 'scroll' mode.",
    },
    table: { control: false },
    renderMobileRow: { control: false },
  },
};

export default meta;
type Story = StoryObj<TableRootProps<Payment>>;

// --- Sample Data and Columns ---
interface Payment {
  id: string;
  account: string;
  amount: number;
  dueDate: string;
  period: string;
  status: "Paid" | "Pending" | "Overdue";
}

const sampleData: Payment[] = [
  {
    id: "1",
    account: "Visa - 3412",
    amount: 1190,
    dueDate: "04/01/2016",
    period: "03/01/2016 - 03/31/2016",
    status: "Paid",
  },
  {
    id: "2",
    account: "Visa - 6067",
    amount: 2443,
    dueDate: "03/01/2016",
    period: "02/01/2016 - 02/29/2016",
    status: "Paid",
  },
  {
    id: "3",
    account: "Corporate AMEX",
    amount: 1181,
    dueDate: "03/01/2016",
    period: "02/01/2016 - 02/29/2016",
    status: "Overdue",
  },
  {
    id: "4",
    account: "Visa - 3412",
    amount: 842,
    dueDate: "02/01/2016",
    period: "01/01/2016 - 01/31/2016",
    status: "Pending",
  },
];

const basicColumns: ColumnDef<Payment>[] = [
  {
    accessorKey: "account",
    header: "Account",
  },
  {
    accessorKey: "amount",
    header: "Amount",
    cell: (info) => `$${info.getValue<number>().toLocaleString()}`,
  },
  {
    accessorKey: "dueDate",
    header: "Due Date",
  },
  {
    accessorKey: "period",
    header: "Period",
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: (info) => {
      const status = info.getValue<Payment["status"]>();
      const variant = {
        Paid: "primary",
        Pending: "secondary",
        Overdue: "destructive",
      }[status] as "primary" | "secondary" | "destructive";
      return (
        <Badge variant={variant} shape="full">
          {status}
        </Badge>
      );
    },
  },
];

// --- STORIES ---

export const DesktopView: Story = {
  name: "1. Desktop View",
  args: {},
  parameters: {
    viewport: { defaultViewport: "responsive" },
  },
  render: (args) => {
    const table = useReactTable({
      data: sampleData,
      columns: basicColumns,
      getCoreRowModel: getCoreRowModel(),
    });

    return (
      <Card className="w-full max-w-4xl overflow-hidden">
        <Table<Payment> {...args} table={table} />
      </Card>
    );
  },
};

export const ScrollLayout: Story = {
  name: "2. Responsive: Scroll Layout",
  args: {
    responsiveLayout: "scroll",
  },
  parameters: {
    viewport: { defaultViewport: "mobile1" },
  },
  render: (args) => {
    const table = useReactTable({
      data: sampleData,
      columns: basicColumns,
      getCoreRowModel: getCoreRowModel(),
    });

    return (
      <Card className="w-full">
        <Table<Payment> {...args} table={table} />
      </Card>
    );
  },
};

export const CustomMobileLayout: Story = {
  name: "3. Responsive: Custom Layout",
  args: {
    responsiveLayout: "custom",
    renderMobileRow: (row: Row<Payment>) => (
      <Card
        shape="minimal"
        variant={"primary"}
        isSelected={row.original.status === "Overdue"}
        padding="lg"
        onClick={() => alert(`Clicked on account: ${row.original.account}`)}
        className="cursor-pointer"
      >
        <div className="flex flex-col gap-8">
          {/* Main Info */}
          <div className="flex justify-between items-start gap-4">
            <div>
              <Typography variant="muted" className="!mt-0 !text-xs">
                Account
              </Typography>
              <Typography variant="p" className="!mt-0 font-semibold truncate">
                {row.original.account}
              </Typography>
            </div>
            <div>
              <Typography variant="muted" className="!mt-0 !text-xs text-right">
                Amount
              </Typography>
              <Typography variant="p" className="!mt-0 font-semibold truncate">
                ${row.original.amount.toLocaleString()}
              </Typography>
            </div>
          </div>
          {/* Secondary Info */}
          <div className="flex justify-between items-center gap-8">
            {row.getVisibleCells().map((cell) => {
              // We've already rendered 'account' and 'amount', so we skip them.
              if (["account", "amount"].includes(cell.column.id)) return null;
              return (
                <div key={cell.id}>
                  <Typography variant="muted" className="!mt-0 !text-xs">
                    {cell.column.columnDef.header as React.ReactNode}
                  </Typography>
                  <Typography variant="small" className="!mt-0 font-semibold">
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </Typography>
                </div>
              );
            })}
          </div>
        </div>
      </Card>
    ),
  },
  parameters: {
    viewport: { defaultViewport: "mobile1" },
    docs: {
      description: {
        story:
          "Set `responsiveLayout='custom'` and provide a `renderMobileRow` function. This function receives the `row` object, giving you complete control to render it as a card, an accordion, or any other custom component.",
      },
    },
  },
  render: (args) => {
    const table = useReactTable({
      data: sampleData,
      columns: basicColumns,
      getCoreRowModel: getCoreRowModel(),
    });

    return (
      <div className="w-full">
        <Table<Payment> {...args} table={table} />
      </div>
    );
  },
};
```


### Component: `tabs`

This section contains the source code for the `tabs` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\tabs\index.tsx`)**
```tsx
"use client";

import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import {
  animate,
  AnimatePresence,
  motion,
  type PanInfo,
  useMotionValue,
} from "framer-motion";
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useId,
  useImperativeHandle,
  useRef,
  useState,
} from "react";
import useRipple from "use-ripple-hook";
import { ShallowRouter, useRouter, useRouterOptions } from "../shallow-router";

// --- TYPE DEFINITIONS & CONTEXT ---
type TabVariant = "primary" | "secondary";
type PageTransition = "slide" | "fade";

interface TabsContextProps {
  activeTab: string;
  setActiveTab: (value: string) => void;
  variant: TabVariant;
  pageTransition: PageTransition;
  indicatorId: string;
}

const TabsContext = createContext<TabsContextProps | null>(null);

export const useTabs = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error("useTabs must be used within a <Tabs> provider.");
  }
  return context;
};

// --- ROOT & PROVIDER ---
interface TabsProps {
  children: React.ReactNode;
  defaultValue: string;
  variant?: TabVariant;
  pageTransition?: PageTransition;
  routingMode?: "search" | "pathname";
  routingParamName?: string;
  /**
   * For 'pathname' mode, specifies which tab to redirect to on initial load
   * if the current path is the base path.
   */
  initialTab?: string;
}

const TabsRoot: React.FC<TabsProps> = ({
  children,
  defaultValue,
  variant = "primary",
  pageTransition = "fade",
  routingMode = "search",
  routingParamName = "tab",
  initialTab,
}) => {
  const uniqueId = useId();
  return (
    <ShallowRouter mode={routingMode} paramName={routingParamName}>
      <TabsProvider
        defaultValue={defaultValue}
        variant={variant}
        pageTransition={pageTransition}
        indicatorId={uniqueId}
        initialTab={initialTab}
      >
        {children}
      </TabsProvider>
    </ShallowRouter>
  );
};

interface TabsProviderProps
  extends Omit<TabsProps, "routingMode" | "routingParamName"> {
  indicatorId: string;
}

const TabsProvider: React.FC<TabsProviderProps> = ({
  children,
  defaultValue,
  variant = "primary",
  pageTransition = "fade",
  indicatorId,
  initialTab,
}) => {
  const { path, push, replace } = useRouter();
  const { mode } = useRouterOptions();

  // biome-ignore lint/correctness/useExhaustiveDependencies: strict
  useEffect(() => {
    if (initialTab) {
      replace(initialTab);
    }
  }, [initialTab]);

  const activeTab = path === "/" ? defaultValue : path;

  const setActiveTab = (value: string) => {
    if (value === activeTab) return;
    push(value);
  };

  return (
    <TabsContext.Provider
      value={{ activeTab, setActiveTab, variant, pageTransition, indicatorId }}
    >
      {children}
    </TabsContext.Provider>
  );
};

// --- TAB LIST ---
interface TabsListProps extends React.HTMLAttributes<HTMLDivElement> {}

const TabsList = React.forwardRef<HTMLDivElement, TabsListProps>(
  ({ children, className, ...props }, ref) => {
    const listRef = useRef<HTMLDivElement>(null);
    const [isOverflowing, setIsOverflowing] = useState(false);
    const [scrollPosition, setScrollPosition] = useState<
      "start" | "middle" | "end"
    >("start");

    // Combine forwarded ref with local ref for external access
    useImperativeHandle(ref, () => listRef.current!);

    // Memoized function to check overflow and scroll position
    const checkScrollState = useCallback(() => {
      const el = listRef.current;
      if (!el) return;

      const hasOverflow = el.scrollWidth > el.clientWidth;
      setIsOverflowing(hasOverflow);

      if (!hasOverflow) {
        setScrollPosition("start");
        return;
      }

      // Using a small tolerance for floating point inaccuracies
      const isAtStart = el.scrollLeft <= 1;
      const isAtEnd = el.scrollLeft >= el.scrollWidth - el.clientWidth - 1;

      if (isAtStart) {
        setScrollPosition("start");
      } else if (isAtEnd) {
        setScrollPosition("end");
      } else {
        setScrollPosition("middle");
      }
    }, []);

    // Effect to check scroll state on mount, resize, and content changes
    useEffect(() => {
      const el = listRef.current;
      if (!el) return;

      checkScrollState();

      const resizeObserver = new ResizeObserver(checkScrollState);
      resizeObserver.observe(el);

      const mutationObserver = new MutationObserver(checkScrollState);
      mutationObserver.observe(el, { childList: true, subtree: true });

      return () => {
        resizeObserver.disconnect();
        mutationObserver.disconnect();
      };
    }, [checkScrollState]);

    const handleScroll = () => {
      checkScrollState();
    };

    // CSS mask styles for creating the fade effect on the edges
    const maskStyles: Record<string, React.CSSProperties> = {
      start: {
        // Fade on the right side
        maskImage:
          "linear-gradient(to right, black calc(100% - 48px), transparent 100%)",
      },
      middle: {
        // Fade on both sides
        maskImage:
          "linear-gradient(to right, transparent 0%, black 48px, black calc(100% - 48px), transparent 100%)",
      },
      end: {
        // Fade on the left side
        maskImage: "linear-gradient(to right, transparent 0%, black 48px)",
      },
    };

    return (
      <div
        ref={listRef}
        role="tablist"
        onScroll={handleScroll}
        className={clsx(
          "relative flex border-b border-graphite-border",
          // Apply scrolling and scrollbar hiding only when needed
          isOverflowing && "overflow-x-auto no-scrollbar",
          className
        )}
        style={isOverflowing ? maskStyles[scrollPosition] : {}}
        {...props}
      >
        {children}
      </div>
    );
  }
);
TabsList.displayName = "Tabs.List";

// --- TAB TRIGGER (MODIFIED) ---
const triggerVariants = cva(
  "relative flex px-6 flex-col items-center justify-center gap-1.5 flex-1 min-h-14 max-auto pb-2 pt-2 font-semibold text-sm transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2",
  {
    variants: {
      variant: { primary: "pt-1", secondary: "" },
      isActive: {
        true: "text-graphite-primary",
        false: "text-graphite-foreground/60 hover:text-graphite-foreground/80",
      },
    },
    defaultVariants: { variant: "primary", isActive: false },
  }
);

interface TabsTriggerProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  value: string;
  icon?: React.ReactNode;
}

const TabsTrigger = React.forwardRef<HTMLButtonElement, TabsTriggerProps>(
  ({ value, children, icon, className, ...props }, ref) => {
    const { activeTab, setActiveTab, variant, indicatorId } = useTabs();
    const isActive = activeTab === value;
    const localRef = React.useRef<HTMLButtonElement>(null);
    const [, event] = useRipple({
      ref: localRef,
      color: "rgba(0, 0, 0, 0.1)",
      duration: 450,
    });
    React.useImperativeHandle(ref, () => localRef.current!);

    // --- NEW LOGIC TO SCROLL ACTIVE TAB INTO VIEW ---
    useEffect(() => {
      if (isActive && localRef.current) {
        localRef.current.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "center",
        });
      }
    }, [isActive]);
    // --- END OF NEW LOGIC ---

    return (
      <button
        ref={localRef}
        role="tab"
        aria-selected={isActive}
        data-state={isActive ? "active" : "inactive"}
        onClick={() => setActiveTab(value)}
        onPointerDown={event}
        className={clsx(triggerVariants({ variant, isActive }), className)}
        {...props}
      >
        {variant === "primary" && icon}
        <span className="relative z-10">{children}</span>
        {isActive && (
          <motion.div
            layoutId={indicatorId}
            className={clsx(
              "absolute bottom-0 rounded-full bg-graphite-primary",
              variant === "primary" ? "w-8" : "w-full"
            )}
            style={{
              height: "2px",
            }}
            transition={{ type: "spring", stiffness: 400, damping: 35 }}
          />
        )}
      </button>
    );
  }
);
TabsTrigger.displayName = "Tabs.Trigger";

// --- TABS CONTENT ---
interface TabsContentProps extends React.HTMLAttributes<HTMLDivElement> {}

const TabsContent = React.forwardRef<HTMLDivElement, TabsContentProps>(
  ({ children, className, ...props }, ref) => {
    const { activeTab, setActiveTab, pageTransition } = useTabs();
    const containerRef = useRef<HTMLDivElement>(null);
    const [containerWidth, setContainerWidth] = useState(0);
    const x = useMotionValue(0);

    if (pageTransition === "fade") {
      // Find the child that corresponds to the active tab.
      const activeChild = React.Children.toArray(children).find(
        (child) =>
          // @ts-ignore
          React.isValidElement(child) && child.props?.value === activeTab
      );

      return (
        <div ref={ref} className={clsx("relative", className)} {...props}>
          <AnimatePresence mode="wait">
            {/* If an active child is found, clone it and give it a unique key.
                This key is essential for AnimatePresence to detect when the
                component changes and apply enter/exit animations correctly. */}
            {activeChild && React.isValidElement(activeChild)
              ? React.cloneElement(activeChild, {
                  key: activeTab, // Assign the key here
                })
              : null}
          </AnimatePresence>
        </div>
      );
    }

    const panels = React.Children.toArray(children).filter(
      React.isValidElement
    ) as React.ReactElement<TabsPanelProps>[];
    const tabValues = panels.map((panel) => panel.props.value);
    const activeIndex = tabValues.indexOf(activeTab);

    // biome-ignore lint/correctness/useHookAtTopLevel: strict
    useEffect(() => {
      const measureWidth = () => {
        if (containerRef.current) {
          setContainerWidth(containerRef.current.offsetWidth);
        }
      };
      measureWidth();
      window.addEventListener("resize", measureWidth);
      return () => window.removeEventListener("resize", measureWidth);
    }, []);

    // biome-ignore lint/correctness/useHookAtTopLevel: strict
    useEffect(() => {
      if (containerWidth > 0) {
        const targetX = -activeIndex * containerWidth;
        animate(x, targetX, {
          type: "spring",
          stiffness: 400,
          damping: 40,
        });
      }
    }, [activeIndex, containerWidth, x]);

    // --- MODIFICATION START: Replaced handleDragEnd logic ---
    const handleDragEnd = (event: MouseEvent | TouchEvent, info: PanInfo) => {
      const { offset, velocity } = info;

      // A fast swipe (fling) is prioritized. We use a velocity threshold.
      const velocityThreshold = 300;
      // If not a fling, the user must drag at least a portion of the page width.
      const distanceThreshold = containerWidth * 0.3; // 30% of the width

      if (velocity.x < -velocityThreshold || offset.x < -distanceThreshold) {
        // Decisive swipe to the left (next page)
        const nextIndex = Math.min(activeIndex + 1, panels.length - 1);
        setActiveTab(tabValues[nextIndex]);
      } else if (
        velocity.x > velocityThreshold ||
        offset.x > distanceThreshold
      ) {
        // Decisive swipe to the right (previous page)
        const prevIndex = Math.max(activeIndex - 1, 0);
        setActiveTab(tabValues[prevIndex]);
      } else {
        // Indecisive swipe, snap back to the current active page.
        // This is crucial for preventing the "stuck" state.
        animate(x, -activeIndex * containerWidth, {
          type: "spring",
          stiffness: 400,
          damping: 40,
        });
      }
    };
    // --- END MODIFICATION ---

    return (
      <div
        ref={containerRef}
        className={clsx("overflow-hidden", className)}
        {...props}
      >
        <motion.div
          role="tabpanel"
          ref={ref}
          className="flex cursor-grab active:cursor-grabbing"
          style={{ x }}
          drag="x"
          dragConstraints={{
            left: -containerWidth * (panels.length - 1),
            right: 0,
          }}
          onDragEnd={handleDragEnd}
        >
          {panels}
        </motion.div>
      </div>
    );
  }
);
TabsContent.displayName = "Tabs.Content";

// --- TABS PANEL ---
interface TabsPanelProps extends React.HTMLAttributes<HTMLDivElement> {
  value: string;
}

const TabsPanel = React.forwardRef<HTMLDivElement, TabsPanelProps>(
  ({ value, children, className, ...props }, ref) => {
    const { activeTab, pageTransition } = useTabs();

    if (pageTransition === "fade") {
      // The parent (TabsContent) now handles filtering and keying.
      // This component just needs to render the animatable motion.div.
      // The key={value} here is now redundant but harmless.
      return (
        // @ts-ignore
        <motion.div
          ref={ref}
          role="tabpanel"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0, transition: { duration: 0.1 } }}
          transition={{ duration: 0.2 }}
          className={clsx("p-4", className)}
          {...props}
        >
          {children}
        </motion.div>
      );
    }

    return (
      <div
        ref={ref}
        role="tabpanel"
        className={clsx("w-full flex-shrink-0 p-4 min-h-[100px]", className)}
        aria-hidden={activeTab !== value}
        {...props}
      >
        {children}
      </div>
    );
  }
);
TabsPanel.displayName = "Tabs.Panel";

// --- EXPORT COMPOUND COMPONENT ---
export const Tabs = Object.assign(TabsRoot, {
  List: TabsList,
  Trigger: TabsTrigger,
  Content: TabsContent,
  Panel: TabsPanel,
});
```

**Storybook Stories (`Tabs.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Car,
  Compass,
  Hotel,
  LocateIcon,
  Menu,
  Package,
  Plane,
  Search,
} from "lucide-react";
import { useRef } from "react";
import { AppBar } from "../appbar";
import { Card } from "../card";
import { IconButton } from "../icon-button";
import { Typography } from "../typography";
import { Tabs } from "./index";
import { ElasticScrollArea } from "../elastic-scroll-area/index";
const meta: Meta<typeof Tabs> = {
  title: "Components/Navigators/Tabs",
  component: Tabs,
  subcomponents: {
    "Tabs.List": Tabs.List,
    "Tabs.Trigger": Tabs.Trigger,
    "Tabs.Content": Tabs.Content,
    "Tabs.Panel": Tabs.Panel,
  },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A fully-featured tabs component with animated indicators and page transitions. It integrates with the `ShallowRouter` to support browser history and deep linking.",
      },
    },
  },
  argTypes: {
    defaultValue: {
      control: "text",
      description: "The value of the tab to be active on initial render.",
    },
    initialTab: {
      control: "text",
      description: "Sets the initial route for 'pathname' mode on first load.",
      if: { arg: "routingMode", eq: "pathname" },
    },
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    pageTransition: {
      control: "select",
      options: ["slide", "fade"],
    },
    routingMode: {
      control: "select",
      options: ["search", "pathname"],
    },
    routingParamName: {
      control: "text",
    },
  },
};

export default meta;
type Story = StoryObj<typeof Tabs>;

export const Primary: Story = {
  name: "1. Primary Variant (with Icons)",
  args: {
    defaultValue: "flights",
    variant: "primary",
    pageTransition: "fade",
    routingParamName: "view",
  },
  render: (args) => (
    <Card className="w-96" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="flights" icon={<Plane size={20} />}>
            Flights
          </Tabs.Trigger>
          <Tabs.Trigger value="trips" icon={<LocateIcon size={20} />}>
            Trips
          </Tabs.Trigger>
          <Tabs.Trigger value="explore" icon={<Compass size={20} />}>
            Explore
          </Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="flights">
            <Typography variant="h4">Find Your Next Flight</Typography>
            <Typography variant="p">
              Search for one-way, round-trip, or multi-city flights.
            </Typography>
          </Tabs.Panel>
          <Tabs.Panel value="trips">
            <Typography variant="h4">Manage Your Trips</Typography>
            <Typography variant="p">
              View upcoming and past trip details here.
            </Typography>
          </Tabs.Panel>
          <Tabs.Panel value="explore">
            <Typography variant="h4">Explore Destinations</Typography>
            <Typography variant="p">
              Get inspired for your next adventure.
            </Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const Secondary: Story = {
  name: "2. Secondary Variant (Text Only)",
  args: {
    defaultValue: "overview",
    variant: "secondary",
    pageTransition: "fade",
  },
  render: (args) => (
    <Card className="w-96" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="overview">Overview</Tabs.Trigger>
          <Tabs.Trigger value="specs">Specifications</Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="overview">
            <Typography variant="h4">Product Overview</Typography>
            <Typography variant="p">
              This is the general description of the product.
            </Typography>
          </Tabs.Panel>
          <Tabs.Panel value="specs">
            <Typography variant="h4">Technical Specifications</Typography>
            <Typography variant="p">
              Detailed technical specifications are listed here.
            </Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const SwipeableCarousel: Story = {
  name: "3. Swipeable Carousel (Slide Transition)",
  args: {
    ...Primary.args,
    pageTransition: "slide",
  },
  parameters: {
    docs: {
      description: {
        story:
          'Set `pageTransition="slide"` to create a carousel effect. You can now drag with a mouse or swipe on a touch screen to navigate between panels.',
      },
    },
  },
  render: (args) => <Primary.render {...args} />,
};

export const PathnameRouting: Story = {
  name: "4. Pathname Routing Mode",
  args: {
    ...Secondary.args,
    routingMode: "pathname",
    initialTab: "overview", // This is now the recommended way
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `routingMode='pathname'`, the `initialTab` prop is used to set the URL correctly on the first render, ensuring the UI and the URL are in sync.",
      },
    },
  },
  render: (args) => <Secondary.render {...args} />,
};

export const Scrollable: Story = {
  name: "5. Scrollable Tabs",
  args: {
    ...Primary.args,
    defaultValue: "flights",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When there are too many tabs to fit in the container, the list becomes horizontally scrollable with faded edges to indicate more content is available.",
      },
    },
  },
  render: (args) => (
    <Card className="w-80" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="flights" icon={<Plane size={20} />}>
            Flights
          </Tabs.Trigger>
          <Tabs.Trigger value="trips" icon={<LocateIcon size={20} />}>
            Trips
          </Tabs.Trigger>
          <Tabs.Trigger value="explore" icon={<Compass size={20} />}>
            Explore
          </Tabs.Trigger>
          <Tabs.Trigger value="hotels" icon={<Hotel size={20} />}>
            Hotels
          </Tabs.Trigger>
          <Tabs.Trigger value="cars" icon={<Car size={20} />}>
            Car Rentals
          </Tabs.Trigger>
          <Tabs.Trigger value="packages" icon={<Package size={20} />}>
            Packages
          </Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="flights">
            <Typography variant="h4">Find Your Next Flight</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="trips">
            <Typography variant="h4">Manage Your Trips</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="explore">
            <Typography variant="h4">Explore Destinations</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="hotels">
            <Typography variant="h4">Book a Hotel</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="cars">
            <Typography variant="h4">Rent a Car</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="packages">
            <Typography variant="h4">Vacation Packages</Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const ScrollableWithSwipe: Story = {
  name: "6. Scrollable Tabs With Swipe",
  args: {
    ...Primary.args,
    defaultValue: "flights",
    pageTransition: "slide",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When there are too many tabs to fit in the container, the list becomes horizontally scrollable with faded edges to indicate more content is available.",
      },
    },
  },
  render: (args) => (
    <Card className="w-[450px]" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="flights" icon={<Plane size={20} />}>
            Flights
          </Tabs.Trigger>
          <Tabs.Trigger value="trips" icon={<LocateIcon size={20} />}>
            Trips
          </Tabs.Trigger>
          <Tabs.Trigger value="explore" icon={<Compass size={20} />}>
            Explore
          </Tabs.Trigger>
          <Tabs.Trigger value="hotels" icon={<Hotel size={20} />}>
            Hotels
          </Tabs.Trigger>
          <Tabs.Trigger value="cars" icon={<Car size={20} />}>
            Car Rentals
          </Tabs.Trigger>
          <Tabs.Trigger value="packages" icon={<Package size={20} />}>
            Packages
          </Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="flights">
            <Typography variant="h4">Find Your Next Flight</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="trips">
            <Typography variant="h4">Manage Your Trips</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="explore">
            <Typography variant="h4">Explore Destinations</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="hotels">
            <Typography variant="h4">Book a Hotel</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="cars">
            <Typography variant="h4">Rent a Car</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="packages">
            <Typography variant="h4">Vacation Packages</Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const WithAppBar: Story = {
  name: "7. With AppBar",
  args: {
    defaultValue: "flights",
    variant: "secondary", // Secondary variant looks better inside an AppBar
    pageTransition: "fade",
  },
  parameters: {
    layout: "fullscreen", // Override layout for this story
    docs: {
      description: {
        story:
          "This example demonstrates how to integrate the `Tabs` component with the `AppBar`. The `Tabs.List` is placed inside the `largeHeaderContent` slot of a large `AppBar`. A `ref` is created for the main scrollable container and passed to the `AppBar` via `scrollContainerRef`, allowing the AppBar to collapse and hide correctly as the user scrolls through the tab panels.",
      },
    },
  },
  render: (args) => {
    const scrollRef = useRef<HTMLDivElement>(null);

    const DummyScrollContent = ({ title }: { title: string }) => (
      <main className="p-6">
        <Typography variant="h3">{title}</Typography>
        <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 30 }).map((_, i) => (
            <div key={i} className="h-48 rounded-2xl bg-black/5" />
          ))}
        </div>
      </main>
    );

    return (
      <div className="h-screen bg-graphite-background overflow-hidden">
        <Tabs {...args}>
          <AppBar
            size="lg"
            scrollBehavior="conditionally-sticky"
            stickyHideTarget="main-row"
            appBarColor="card"
            scrollContainerRef={scrollRef}
            startAdornment={
              <IconButton variant="ghost" size={"sm"} aria-label="Menu">
                <Menu />
              </IconButton>
            }
            endAdornments={[
              <IconButton
                key="search"
                size={"sm"}
                variant="ghost"
                aria-label="Search"
              >
                <Search />
              </IconButton>,
            ]}
            children={
              <Typography variant="h4" className="truncate font-bold">
                My App
              </Typography>
            }
            largeHeaderRowHeight={50}
            largeHeaderContent={
              // Negative margins stretch the list to the edges and counteract parent padding
              <div className="-mx-4 -mb-4">
                <Tabs.List className="!border-b-0">
                  <Tabs.Trigger value="flights">Flights</Tabs.Trigger>
                  <Tabs.Trigger value="hotels">Hotels</Tabs.Trigger>
                  <Tabs.Trigger value="cars">Cars</Tabs.Trigger>
                  <Tabs.Trigger value="packages">Packages</Tabs.Trigger>
                </Tabs.List>
              </div>
            }
          />
          <ElasticScrollArea
            ref={scrollRef}
            className="h-full overflow-y-auto pt-[100px] bg-graphite-background"
          >
            <Tabs.Content className="overflow-hidden">
              <Tabs.Panel value="flights">
                <DummyScrollContent title="Search for Flights" />
              </Tabs.Panel>
              <Tabs.Panel value="hotels">
                <DummyScrollContent title="Find Hotel Deals" />
              </Tabs.Panel>
              <Tabs.Panel value="cars">
                <DummyScrollContent title="Rent a Car" />
              </Tabs.Panel>
              <Tabs.Panel value="packages">
                <DummyScrollContent title="Vacation Packages" />
              </Tabs.Panel>
            </Tabs.Content>
          </ElasticScrollArea>
        </Tabs>
      </div>
    );
  },
};
```


### Component: `taskbar`

This section contains the source code for the `taskbar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\taskbar\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { Copy, Minus, Square, X } from "lucide-react";
import React, { useRef } from "react";
import useRipple from "use-ripple-hook";

// --- CVA Variants ---
const taskbarVariants = cva(
  "flex items-center text-graphite-foreground select-none",
  {
    variants: {
      variant: {
        transparent: "bg-transparent",
        card: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
      },
      bordered: {
        true: "border-b border-graphite-border",
        false: "border-b border-transparent",
      },
      size: {
        sm: "h-8",
        md: "h-10",
        lg: "h-12",
      },
    },
    defaultVariants: {
      variant: "transparent",
      bordered: false,
      size: "md",
    },
  }
);

const windowControlVariants = cva(
  "flex items-center justify-center transition-colors duration-200 ease-in-out focus:outline-none focus-visible:ring-2 focus-visible:ring-graphite-ring relative overflow-hidden group ",
  {
    variants: {
      variant: {
        minimize: "hover:bg-black/10",
        maximize: "hover:bg-black/10",
        close: "hover:bg-red-500 hover:text-white",
      },
      size: {
        sm: "h-8 w-10",
        md: "h-10 w-12",
        lg: "h-12 w-14",
      },
    },
    defaultVariants: {
      size: "md",
    },
  }
);

// --- Internal Window Control Button ---
interface WindowButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant: "minimize" | "maximize" | "close";
  size: "sm" | "md" | "lg";
}

const WindowButton = React.forwardRef<HTMLButtonElement, WindowButtonProps>(
  ({ children, variant, size, onClick, ...props }, ref) => {
    const localRef = useRef<HTMLButtonElement>(null);
    const rippleColor =
      variant === "close" ? "rgba(255, 255, 255, 0.3)" : "rgba(0, 0, 0, 0.1)";
    const [, event] = useRipple({
      ref: localRef,
      color: rippleColor,
      duration: 300,
    });

    const stopPropagation = (e: React.MouseEvent) => e.stopPropagation();

    return (
      <button
        ref={localRef}
        data-tauri-drag-region={false}
        onMouseDown={(e) => {
          stopPropagation(e);
          event(e);
        }}
        onClick={(e) => {
          stopPropagation(e);
          onClick?.(e);
        }}
        className={windowControlVariants({ variant, size })}
        {...props}
      >
        {children}
      </button>
    );
  }
);
WindowButton.displayName = "WindowButton";

// --- Component Props ---
export interface TaskbarProps extends React.HTMLAttributes<HTMLElement> {
  variant?: "transparent" | "card" | "secondary";
  bordered?: boolean;
  size?: "sm" | "md" | "lg";
  /** Content to render at the start of the taskbar (e.g., app icon, title). */
  startAdornment?: React.ReactNode;
  /** Content to render in the center (e.g., navigation menu). */
  centerAdornment?: React.ReactNode;
  /** Determines if the maximize icon should show the 'restore' state. */
  isMaximized?: boolean;
  /** Callback fired when the minimize button is clicked. */
  onMinimize?: () => void;
  /** Callback fired when the maximize/restore button is clicked. */
  onMaximize?: () => void;
  /** Callback fired when the close button is clicked. */
  onClose?: () => void;
}
// --- Main Component ---
export const Taskbar = React.forwardRef<HTMLElement, TaskbarProps>(
  (
    {
      className,
      variant,
      bordered,
      size = "md",
      startAdornment,
      centerAdornment,
      isMaximized = false,
      onMinimize,
      onMaximize,
      onClose,
      ...props
    },
    ref
  ) => {
    const iconSizeMap = {
      sm: 14,
      md: 16,
      lg: 18,
    };
    const currentIconSize = iconSizeMap[size];

    return (
      <header
        ref={ref}
        data-tauri-drag-region
        className={clsx(
          taskbarVariants({ variant, bordered, size, className })
        )}
        {...props}
      >
        {/* Start Slot */}
        <div className="flex-shrink-0 px-2">{startAdornment}</div>

        {/* Center Slot (Draggable) */}
        <div
          data-tauri-drag-region
          className="flex-1 flex items-center justify-center h-full min-w-0"
        >
          {centerAdornment}
        </div>

        {/* End Slot (Window Controls) */}
        <div className="flex items-center justify-end flex-shrink-0">
          <WindowButton
            variant="minimize"
            size={size}
            onClick={onMinimize}
            aria-label="Minimize"
          >
            <Minus size={currentIconSize} />
          </WindowButton>
          <WindowButton
            variant="maximize"
            size={size}
            onClick={onMaximize}
            aria-label={isMaximized ? "Restore" : "Maximize"}
          >
            {isMaximized ? (
              <Copy size={currentIconSize} />
            ) : (
              <Square size={currentIconSize} />
            )}
          </WindowButton>
          <WindowButton
            variant="close"
            size={size}
            onClick={onClose}
            aria-label="Close"
          >
            <X size={currentIconSize} />
          </WindowButton>
        </div>
      </header>
    );
  }
);

Taskbar.displayName = "Taskbar";
```

**Storybook Stories (`Taskbar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Mountain } from "lucide-react";
import React, { useState } from "react";
import { NavigationMenu } from "../navigation-menu";
import { Typography } from "../typography";
import { Taskbar } from "./index";

const meta: Meta<typeof Taskbar> = {
  title: "Components/Navigators/Taskbar",
  component: Taskbar,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A draggable taskbar component designed for desktop applications (Electron, Tauri). It provides window controls and slots for custom content like menus and titles.",
      },
    },
  },
  argTypes: {
    variant: {
      control: "select",
      options: ["transparent", "card", "secondary"],
      description: "The background color variant of the taskbar.",
    },
    bordered: {
      control: "boolean",
      description: "Adds a bottom border to the taskbar.",
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
      description: "Controls the height of the taskbar and its controls.",
    },
    isMaximized: { control: "boolean" },
    onMinimize: { action: "minimized" },
    onMaximize: { action: "maximized" },
    onClose: { action: "closed" },
    startAdornment: { control: false },
    centerAdornment: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof Taskbar>;

// Helper component to simulate a desktop window
const FakeWindow = ({
  children,
  title = "My App",
}: {
  children: React.ReactNode;
  title?: string;
}) => (
  <div>
    <Typography variant="small" className="text-center mb-2 font-semibold">
      {title}
    </Typography>
    <div className="w-[720px] h-[480px] flex flex-col shadow-2xl overflow-hidden bg-graphite-background ring-1 ring-black/5 rounded-xl">
      {children}
    </div>
  </div>
);

// Helper for the menu bar example
const MenuBar = () => (
  <NavigationMenu>
    <NavigationMenu.List>
      <NavigationMenu.Item>
        <NavigationMenu.Trigger>File</NavigationMenu.Trigger>
        <NavigationMenu.Content>
          <ul className="grid w-[200px] gap-2 p-3">
            <li>New</li>
            <li>Open</li>
            <li>Save</li>
          </ul>
        </NavigationMenu.Content>
      </NavigationMenu.Item>
      <NavigationMenu.Item>
        <NavigationMenu.Trigger>Edit</NavigationMenu.Trigger>
        <NavigationMenu.Content>
          <ul className="grid w-[200px] gap-2 p-3">
            <li>Undo</li>
            <li>Redo</li>
            <li>Cut</li>
          </ul>
        </NavigationMenu.Content>
      </NavigationMenu.Item>
      <NavigationMenu.Item>
        <NavigationMenu.Trigger>View</NavigationMenu.Trigger>
        <NavigationMenu.Content>
          <ul className="grid w-[200px] gap-2 p-3">
            <li>Zoom In</li>
            <li>Zoom Out</li>
          </ul>
        </NavigationMenu.Content>
      </NavigationMenu.Item>
    </NavigationMenu.List>
  </NavigationMenu>
);

export const Default: Story = {
  name: "1. Default",
  args: {
    variant: "transparent",
    bordered: false,
    size: "md",
  },
  render: (args) => {
    const [isMaximized, setIsMaximized] = useState(args.isMaximized || false);
    return (
      <FakeWindow title="Default Taskbar">
        <Taskbar
          {...args}
          isMaximized={isMaximized}
          onMaximize={() => setIsMaximized(!isMaximized)}
          startAdornment={
            <div className="flex items-center gap-2 pl-2">
              <Mountain size={16} />
              <Typography variant="small" className="font-semibold">
                App Title
              </Typography>
            </div>
          }
        />
        <div className="flex-1 p-6">
          <Typography variant="p">
            This is the default taskbar with a transparent background and no
            border.
          </Typography>
        </div>
      </FakeWindow>
    );
  },
};

export const AllSizes: Story = {
  name: "2. Sizing",
  parameters: {
    docs: {
      description: {
        story:
          "The `size` prop controls the overall height of the taskbar, as well as the dimensions of the window control buttons.",
      },
    },
  },
  render: (args) => {
    const [isMaximized, setIsMaximized] = useState(false);
    return (
      <div className="flex flex-col gap-8">
        <FakeWindow title="Small (sm)">
          <Taskbar
            {...args}
            size="sm"
            isMaximized={isMaximized}
            onMaximize={() => setIsMaximized(!isMaximized)}
            startAdornment={
              <div className="flex items-center gap-2 pl-2">
                <Mountain size={14} />
                <Typography variant="small" className="font-semibold">
                  App
                </Typography>
              </div>
            }
          />
          <div className="flex-1 p-6" />
        </FakeWindow>
        <FakeWindow title="Medium (md - default)">
          <Taskbar
            {...args}
            size="md"
            isMaximized={isMaximized}
            onMaximize={() => setIsMaximized(!isMaximized)}
            startAdornment={
              <div className="flex items-center gap-2 pl-2">
                <Mountain size={16} />
                <Typography variant="small" className="font-semibold">
                  App
                </Typography>
              </div>
            }
          />
          <div className="flex-1 p-6" />
        </FakeWindow>
        <FakeWindow title="Large (lg)">
          <Taskbar
            {...args}
            size="lg"
            isMaximized={isMaximized}
            onMaximize={() => setIsMaximized(!isMaximized)}
            startAdornment={
              <div className="flex items-center gap-2 pl-2">
                <Mountain size={18} />
                <Typography variant="small" className="font-semibold">
                  App
                </Typography>
              </div>
            }
          />
          <div className="flex-1 p-6" />
        </FakeWindow>
      </div>
    );
  },
};

export const ColorVariants: Story = {
  name: "3. Color Variants",
  parameters: {
    docs: {
      description: {
        story:
          "The `variant` prop changes the background color to match different parts of the UI theme.",
      },
    },
  },
  render: (args) => {
    const [isMaximized, setIsMaximized] = useState(false);
    return (
      <div className="flex flex-col gap-8">
        <FakeWindow title="Variant: Card">
          <Taskbar
            {...args}
            variant="card"
            isMaximized={isMaximized}
            onMaximize={() => setIsMaximized(!isMaximized)}
          />
          <div className="flex-1 p-6" />
        </FakeWindow>
        <FakeWindow title="Variant: Secondary">
          <Taskbar
            {...args}
            variant="secondary"
            isMaximized={isMaximized}
            onMaximize={() => setIsMaximized(!isMaximized)}
          />
          <div className="flex-1 p-6" />
        </FakeWindow>
      </div>
    );
  },
};

export const Bordered: Story = {
  name: "4. Bordered vs. Borderless",
  parameters: {
    docs: {
      description: {
        story:
          "The `bordered` prop adds a subtle bottom border, useful for separating the taskbar from the content below.",
      },
    },
  },
  render: (args) => {
    const [isMaximized, setIsMaximized] = useState(false);
    return (
      <div className="flex flex-col gap-8">
        <FakeWindow title="Bordered (variant: card)">
          <Taskbar
            {...args}
            variant="card"
            bordered={true}
            isMaximized={isMaximized}
            onMaximize={() => setIsMaximized(!isMaximized)}
          />
          <div className="flex-1 p-6" />
        </FakeWindow>
        <FakeWindow title="Borderless (variant: card)">
          <Taskbar
            {...args}
            variant="card"
            bordered={false}
            isMaximized={isMaximized}
            onMaximize={() => setIsMaximized(!isMaximized)}
          />
          <div className="flex-1 p-6" />
        </FakeWindow>
      </div>
    );
  },
};
```


### Component: `textarea`

This section contains the source code for the `textarea` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\textarea\index.tsx`)**
```tsx
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import React, { useEffect, useImperativeHandle, useRef } from "react";

const textAreaWrapperVariants = cva(
  // FIX: Removed `px-4` and `border-2` from the base class.
  "flex items-start transition-all duration-200 w-full",
  {
    variants: {
      variant: {
        // FIX: Added `border-2` and `px-4` to the variants that need them.
        primary: "bg-graphite-card border-2 px-4",
        secondary: "bg-graphite-secondary border-2 px-4",
        minimal: "bg-transparent p-0",
      },
      shape: {
        full: "rounded-4xl",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
      size: {
        sm: "py-2 text-sm",
        md: "py-3 text-base",
        lg: "py-4 text-lg",
      },
      isErrored: { true: "" },
      isFocused: { true: "" },
      disabled: {
        true: "bg-graphite-secondary opacity-50 cursor-not-allowed",
      },
    },
    compoundVariants: [
      {
        variant: "primary",
        isErrored: false,
        isFocused: false,
        className: "border-graphite-border",
      },
      {
        variant: "secondary",
        isErrored: false,
        isFocused: false,
        className: "border-transparent",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "primary",
        isFocused: false,
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "secondary",
        isFocused: false,
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
      {
        variant: "minimal",
        className: "rounded-none border-0",
      },
    ],
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
      size: "md",
    },
  }
);

export interface TextAreaProps
  extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, "size"> {
  variant?: "primary" | "secondary" | "minimal";
  shape?: "full" | "minimal" | "sharp";
  size?: "sm" | "md" | "lg";
  label?: string;
  error?: string;
  wrapperClassName?: string;
}
export const TextArea = React.forwardRef<HTMLTextAreaElement, TextAreaProps>(
  (
    {
      className,
      id,
      label,
      error,
      disabled,
      shape,
      size,
      wrapperClassName,
      variant,
      onFocus,
      onBlur,
      onChange,
      rows = 3, // Default to 3 rows
      value,
      ...props
    },
    ref
  ) => {
    const uniqueId = React.useId();
    const textAreaId = id || uniqueId;
    const hasError = !!error;
    const [isFocused, setIsFocused] = React.useState(false);

    // Create a local ref to manage the textarea DOM element
    const localRef = useRef<HTMLTextAreaElement>(null);
    // Bridge the forwarded ref with our local ref
    useImperativeHandle(ref, () => localRef.current!);

    // Function to resize the textarea
    const resizeTextArea = () => {
      const textArea = localRef.current;
      if (textArea) {
        // Temporarily reset height to allow scrollHeight to be calculated correctly
        textArea.style.height = "auto";
        // Set the height to match the content's scroll height
        textArea.style.height = `${textArea.scrollHeight}px`;
      }
    };

    // Resize on initial mount and when the value prop changes programmatically
    useEffect(() => {
      resizeTextArea();
    }, [value]);

    const handleFocus = (e: React.FocusEvent<HTMLTextAreaElement>) => {
      setIsFocused(true);
      onFocus?.(e);
    };

    const handleBlur = (e: React.FocusEvent<HTMLTextAreaElement>) => {
      setIsFocused(false);
      onBlur?.(e);
    };

    // Wrap the onChange handler to trigger resize on every input
    const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      resizeTextArea();
      // Forward the event to the original onChange handler if it exists
      onChange?.(e);
    };

    return (
      <div className="w-full flex flex-col gap-2">
        {label && (
          <label
            htmlFor={textAreaId}
            className="block text-sm font-medium text-graphite-primary"
          >
            {label}
          </label>
        )}
        <div
          className={textAreaWrapperVariants({
            variant,
            shape,
            size,
            isErrored: hasError,
            isFocused,
            disabled,
            className: wrapperClassName,
          })}
        >
          <textarea
            id={textAreaId}
            ref={localRef}
            disabled={disabled}
            rows={rows} // Set the initial row height
            onFocus={handleFocus}
            onBlur={handleBlur}
            onChange={handleChange}
            value={value}
            className={clsx(
              // `resize-none` is important for auto-sizing to work smoothly
              // `overflow-hidden` prevents the scrollbar from flashing during resize
              "w-full flex-1 bg-transparent focus:outline-none resize-none overflow-hidden",
              "disabled:cursor-not-allowed",
              variant === "secondary" && "placeholder:text-gray-500",
              className
            )}
            {...props}
          />
        </div>
        {hasError && <p className="mt-2 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);

TextArea.displayName = "TextArea";
```

**Storybook Stories (`Textarea.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  ArrowUp,
  CornerDownLeft,
  FileCode,
  Maximize,
  Plus,
  RefreshCw,
} from "lucide-react";
import { Button } from "../button";
import { ButtonGroup } from "../button-group";
import { Card } from "../card";
import { IconButton } from "../icon-button";
import { Item, ItemActions, ItemContent, ItemMedia, ItemTitle } from "../item";
import { Typography } from "../typography";
import { TextArea } from "./index";

const meta: Meta<typeof TextArea> = {
  title: "Components/Forms & Inputs/TextArea",
  component: TextArea,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "minimal"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    label: { control: "text" },
    placeholder: { control: "text" },
    disabled: { control: "boolean" },
    error: { control: "text" },
    rows: { control: "number" },
  },
};

export default meta;
type Story = StoryObj<typeof TextArea>;

export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
    size: "md",
    label: "Your Message",
    placeholder: "Enter your comments here...",
    rows: 4,
  },
};

export const AdvancedComposition: Story = {
  name: "Advanced Composition Examples",
  parameters: {
    docs: {
      description: {
        story:
          "The `minimal` variant is completely unstyled, making it perfect for composing custom input components. Here are two examples inspired by modern UI patterns.",
      },
    },
  },
  render: () => (
    <div className="flex flex-col items-center gap-12">
      {/* --- Chat Input Example --- */}
      <div className="w-full max-w-lg">
        <Card variant="primary" shape="minimal" padding="none">
          <TextArea
            variant="minimal"
            placeholder="Ask, Search or Chat..."
            rows={1}
            wrapperClassName="p-4"
          />
          <div className="flex items-center justify-between gap-4 px-4 pb-3">
            <Button
              variant="secondary"
              size="sm"
              shape="minimal"
              startIcon={<Plus size={16} />}
            >
              Auto
            </Button>
            <Typography variant="muted" className="!mt-0">
              52% used
            </Typography>
            <IconButton
              variant="secondary"
              size="sm"
              shape="full"
              aria-label="Send"
            >
              <ArrowUp size={16} />
            </IconButton>
          </div>
        </Card>
      </div>

      {/* --- Code Editor Example --- */}
      <div className="w-full max-w-lg">
        <Card variant="primary" shape="minimal" padding="none">
          {/* Header */}
          <Item padding="sm" className="border-b border-graphite-border">
            <ItemMedia variant="icon" className="!bg-transparent !border-0">
              <FileCode size={18} />
            </ItemMedia>
            <ItemContent>
              <ItemTitle className="!text-sm">script.js</ItemTitle>
            </ItemContent>
            <ItemActions>
              <ButtonGroup shape="minimal">
                <IconButton
                  variant="ghost"
                  size="xs"
                  aria-label="Refresh script"
                >
                  <RefreshCw size={14} />
                </IconButton>
                <IconButton
                  variant="ghost"
                  size="xs"
                  aria-label="Expand script"
                >
                  <Maximize size={14} />
                </IconButton>
              </ButtonGroup>
            </ItemActions>
          </Item>

          {/* Body */}
          <TextArea
            variant="minimal"
            defaultValue="console.log('Hello, world!');"
            rows={8}
            className="font-mono text-sm"
            wrapperClassName="p-4"
          />

          {/* Footer */}
          <Item padding="sm" className="border-t border-graphite-border">
            <ItemContent>
              <Typography variant="muted" className="!mt-0 !text-xs">
                Line 1, Column 1
              </Typography>
            </ItemContent>
            <ItemActions>
              <Button
                variant="secondary"
                size="sm"
                shape="minimal"
                endIcon={<CornerDownLeft size={14} />}
              >
                Run
              </Button>
            </ItemActions>
          </Item>
        </Card>
      </div>
    </div>
  ),
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-col gap-6 max-w-sm">
      <TextArea
        size="sm"
        label="Small"
        placeholder="Small textarea (sm)"
        rows={3}
      />
      <TextArea
        size="md"
        label="Medium (Default)"
        placeholder="Medium textarea (md)"
        rows={3}
      />
      <TextArea
        size="lg"
        label="Large"
        placeholder="Large textarea (lg)"
        rows={3}
      />
    </div>
  ),
  parameters: {
    docs: {
      description: {
        story: "The `size` prop controls the vertical padding and font size.",
      },
    },
  },
};

export const AllVariantsAndShapes: Story = {
  name: "All Variants & Shapes",
  render: () => (
    <div className="flex flex-col gap-8 max-w-sm">
      <div>
        <h3 className="font-bold mb-4">Primary Variant</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="primary"
            shape="full"
            placeholder="Full Shape"
            rows={2}
          />
          <TextArea
            variant="primary"
            shape="minimal"
            placeholder="Minimal Shape"
            rows={2}
          />
          <TextArea
            variant="primary"
            shape="sharp"
            placeholder="Sharp Shape"
            rows={2}
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary Variant</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="secondary"
            shape="full"
            placeholder="Full Shape"
            rows={2}
          />
          <TextArea
            variant="secondary"
            shape="minimal"
            placeholder="Minimal Shape"
            rows={2}
          />
          <TextArea
            variant="secondary"
            shape="sharp"
            placeholder="Sharp Shape"
            rows={2}
          />
        </div>
      </div>
    </div>
  ),
};

export const AllStates: Story = {
  name: "All States",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl">
      <div>
        <h3 className="font-bold mb-4">Primary States</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="primary"
            label="Default"
            placeholder="Enter a description..."
          />
          <TextArea
            variant="primary"
            label="With Value"
            defaultValue="This is some pre-filled text in the textarea."
          />
          <TextArea
            variant="primary"
            label="Error State"
            defaultValue="This message is too short."
            error="Message must be at least 50 characters."
          />
          <TextArea
            variant="primary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary States</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="secondary"
            label="Default"
            placeholder="Enter a description..."
          />
          <TextArea
            variant="secondary"
            label="With Value"
            defaultValue="This is some pre-filled text in the textarea."
          />
          <TextArea
            variant="secondary"
            label="Error State"
            defaultValue="This message is too short."
            error="Message must be at least 50 characters."
          />
          <TextArea
            variant="secondary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
    </div>
  ),
};

export const WithCustomRows: Story = {
  name: "With Custom Rows",
  args: {
    label: "A Tall Text Area",
    placeholder: "This area starts with 8 rows",
    rows: 8,
  },
};
```


### Component: `time-picker`

This section contains the source code for the `time-picker` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\time-picker\index.tsx`)**
```tsx
// src/components/time-picker.tsx

"use client";

import * as PopoverPrimitive from "@radix-ui/react-popover";
import { useMediaQuery } from "@uidotdev/usehooks";
import { clsx } from "clsx";
import { format } from "date-fns";
import { animate } from "framer-motion";
import { Clock } from "lucide-react";
import React, {
  useCallback,
  useEffect,
  useImperativeHandle,
  useLayoutEffect,
  useRef,
  useState,
} from "react";
import { useTimePicker } from "../../hooks/use-time-picker";
import { Button } from "../button";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "../dialog";
import { ElasticScrollArea } from "../elastic-scroll-area";
// --- MAKE SURE THIS IMPORT PATH IS CORRECT ---
import { inputWrapperVariants } from "../input";

// --- 1. Internal TimeRoller Component (MODIFIED: Smoother Snapping) ---
interface TimeRollerProps {
  items: (string | number)[];
  value: string | number;
  onValueChange: (newValue: string | number) => void;
}

const ITEM_HEIGHT = 36; // in pixels
const VISIBLE_ITEMS = 5;

const TimeRoller = React.forwardRef<HTMLDivElement, TimeRollerProps>(
  ({ items, value, onValueChange }, ref) => {
    const scrollerRef = useRef<HTMLDivElement>(null);
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);

    useImperativeHandle(ref, () => scrollerRef.current!);

    const paddingCount = Math.floor(VISIBLE_ITEMS / 2);

    const getTargetIndex = useCallback(
      (val: string | number) => {
        const index = items.findIndex((item) => String(item) === String(val));
        return Math.max(0, index);
      },
      [items]
    );

    useLayoutEffect(() => {
      const scroller = scrollerRef.current;
      if (scroller) {
        const targetIndex = getTargetIndex(value);
        scroller.scrollTop = targetIndex * ITEM_HEIGHT;
      }
    }, [value, getTargetIndex]);

    const handleScroll = useCallback(() => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        const scroller = scrollerRef.current;
        if (!scroller) return;

        const currentScrollTop = scroller.scrollTop;
        const snappedIndex = Math.round(currentScrollTop / ITEM_HEIGHT);
        const clampedIndex = Math.max(
          0,
          Math.min(snappedIndex, items.length - 1)
        );
        const targetScrollTop = clampedIndex * ITEM_HEIGHT;

        animate(currentScrollTop, targetScrollTop, {
          type: "spring",
          stiffness: 400,
          damping: 40,
          mass: 0.8,
          onUpdate: (latest) => {
            if (scroller) {
              scroller.scrollTop = latest;
            }
          },
          onComplete: () => {
            const newValue = items[clampedIndex];
            if (String(newValue) !== String(value)) {
              onValueChange(newValue);
            }
          },
        });
      }, 150);
    }, [items, value, onValueChange]);

    useEffect(() => {
      const scroller = scrollerRef.current;
      if (!scroller) return;

      scroller.addEventListener("scroll", handleScroll);
      return () => {
        scroller.removeEventListener("scroll", handleScroll);
      };
    }, [handleScroll]);

    return (
      <div
        className="h-[180px] w-20"
        style={{ height: `${VISIBLE_ITEMS * ITEM_HEIGHT}px` }}
      >
        <ElasticScrollArea
          ref={scrollerRef}
          className="h-full w-full"
          elasticity={true}
          dampingFactor={0.6}
          scrollbarVisibility="scroll"
        >
          <div style={{ height: `${paddingCount * ITEM_HEIGHT}px` }} />
          {/* @ts-ignore */}
          {items.map((item, index) => (
            <div
              key={`${item}-${index}`}
              className="flex h-[36px] items-center justify-center text-xl text-graphite-foreground"
              style={{ height: `${ITEM_HEIGHT}px` }}
            >
              {typeof item === "number" ? String(item).padStart(2, "0") : item}
            </div>
          ))}

          <div style={{ height: `${paddingCount * ITEM_HEIGHT}px` }} />
        </ElasticScrollArea>
      </div>
    );
  }
);
TimeRoller.displayName = "TimeRoller";

// --- 2. Internal TimePickerPanel Component (Unchanged) ---
interface TimePickerPanelProps {
  value: Date;
  onValueChange: (newDate: Date) => void;
}

const TimePickerPanel: React.FC<TimePickerPanelProps> = ({
  value,
  onValueChange,
}) => {
  const { time, displayHour, minutes, period, setHour, setMinute, setPeriod } =
    useTimePicker(value);

  useEffect(() => {
    onValueChange(time);
  }, [time, onValueChange]);

  const hours = Array.from({ length: 12 }, (_, i) => i + 1);
  const minutesArray = Array.from({ length: 60 }, (_, i) => i);

  return (
    <div className="relative flex items-center justify-center p-4">
      <div
        className="pointer-events-none absolute inset-x-0 top-1/2 z-0 h-[36px] -translate-y-1/2 rounded-lg bg-graphite-secondary"
        style={{ height: `${ITEM_HEIGHT}px` }}
      />
      <div className="z-10 flex items-center">
        <TimeRoller
          items={hours}
          value={displayHour}
          onValueChange={(newHour) => setHour(newHour as number)}
        />
        <div className="pb-1 text-xl font-bold">:</div>
        <TimeRoller
          items={minutesArray}
          value={minutes}
          onValueChange={(newMinute) => setMinute(newMinute as number)}
        />
        <TimeRoller
          items={["AM", "PM"]}
          value={period}
          onValueChange={(newPeriod) => setPeriod(newPeriod as "AM" | "PM")}
        />
      </div>
    </div>
  );
};

// --- 3. Main Exported TimePicker Component (Unchanged) ---
// @ts-ignore
export interface TimePickerProps
  extends Omit<
    React.ButtonHTMLAttributes<HTMLButtonElement>,
    "value" | "onChange" | "size"
  > {
  shape?: "full" | "minimal" | "sharp";
  size?: "sm" | "md" | "lg";
  label?: string;
  error?: string;
  placeholder?: string;
  value?: Date;
  onChange?: (date: Date) => void;
  variant?: "docked" | "modal";
}

export const TimePicker = React.forwardRef<HTMLButtonElement, TimePickerProps>(
  (
    {
      label,
      error,
      placeholder = "Select time",
      value: controlledValue,
      onChange,
      variant: variantProp,
      shape = "minimal", // <-- This now correctly applies the new minimal style
      size = "md",
      disabled,
      className,
      ...props
    },
    ref
  ) => {
    const isMobile = useMediaQuery("(max-width: 768px)");
    const variant = variantProp || (isMobile ? "modal" : "docked");

    const [uncontrolledValue, setUncontrolledValue] = useState(new Date());
    const isControlled = controlledValue !== undefined;
    const value = isControlled ? controlledValue : uncontrolledValue;
    const setValue = onChange || setUncontrolledValue;

    const [isOpen, setIsOpen] = useState(false);
    const [tempValue, setTempValue] = useState(value);

    const formattedValue = value ? format(value, "hh:mm a") : "";

    if (variant === "modal") {
      const handleOpenChange = (open: boolean) => {
        if (open) {
          setTempValue(value || new Date());
        }
        setIsOpen(open);
      };

      const handleConfirm = () => {
        setValue(tempValue);
        setIsOpen(false);
      };

      return (
        <div className="flex w-full flex-col gap-2">
          {label && (
            <label className="block text-sm font-medium text-graphite-primary">
              {label}
            </label>
          )}
          <Dialog
            open={isOpen}
            onOpenChange={handleOpenChange}
            variant={variant === "modal" ? "basic" : "fullscreen"}
          >
            <DialogTrigger asChild>
              <button
                ref={ref}
                type="button"
                disabled={disabled}
                className={clsx(
                  inputWrapperVariants({
                    shape,
                    size,
                    disabled,
                    isErrored: !!error,
                  }),
                  className
                )}
                {...props}
              >
                <Clock className="mr-2 h-4 w-4 opacity-50" />
                <span className="flex-1 text-left">
                  {formattedValue || placeholder}
                </span>
              </button>
            </DialogTrigger>
            <DialogContent shape={shape} className="max-w-[320px]!">
              <DialogHeader>
                <DialogTitle>{label || placeholder}</DialogTitle>
              </DialogHeader>
              <TimePickerPanel value={tempValue} onValueChange={setTempValue} />
              <DialogFooter className="flex justify-end gap-4">
                <Button variant="secondary" onClick={() => setIsOpen(false)}>
                  Cancel
                </Button>
                <Button onClick={handleConfirm}>Done</Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
          {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
        </div>
      );
    }

    return (
      <div className="flex w-full flex-col gap-2">
        {label && (
          <label className="block text-sm font-medium text-graphite-primary">
            {label}
          </label>
        )}
        <PopoverPrimitive.Root open={isOpen} onOpenChange={setIsOpen}>
          <PopoverPrimitive.Trigger asChild>
            <button
              ref={ref}
              type="button"
              disabled={disabled}
              className={clsx(
                inputWrapperVariants({
                  shape,
                  size,
                  disabled,
                  isErrored: !!error,
                  isFocused: isOpen,
                }),
                className
              )}
              {...props}
            >
              <Clock className="mr-2 h-4 w-4 opacity-50" />
              <span className="flex-1 text-left">
                {formattedValue || placeholder}
              </span>
            </button>
          </PopoverPrimitive.Trigger>
          <PopoverPrimitive.Portal>
            <PopoverPrimitive.Content
              sideOffset={8}
              align="start"
              className={clsx(
                "z-50 w-auto rounded-xl border border-graphite-border bg-graphite-card shadow-md",
                "data-[state=open]:animate-menu-enter",
                "data-[state=closed]:animate-menu-exit"
              )}
            >
              <TimePickerPanel
                value={value || new Date()}
                onValueChange={setValue}
              />
            </PopoverPrimitive.Content>
          </PopoverPrimitive.Portal>
        </PopoverPrimitive.Root>
        {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);
TimePicker.displayName = "TimePicker";
```

**Storybook Stories (`Timer-picker.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { TimePicker } from "./index";

const meta: Meta<typeof TimePicker> = {
  title: "Components/Date & Time/TimePicker",
  component: TimePicker,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A custom, iOS-style time picker with a roller interface. It supports single time selection and features responsive variants: `docked` (desktop), `modal`, and `fullscreen` (mobile).",
      },
    },
  },
  argTypes: {
    variant: {
      control: "select",
      options: ["docked", "modal", "fullscreen"],
      description:
        "Overrides the default responsive behavior to force a specific variant.",
    },
    size: { control: "select", options: ["sm", "md", "lg"] },
    shape: { control: "select", options: ["full", "minimal", "sharp"] },
    label: { control: "text" },
    disabled: { control: "boolean" },
    value: { control: false },
    onChange: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof TimePicker>;

export const Docked: Story = {
  name: "1. Docked (Desktop Default)",
  args: {
    variant: "docked",
    label: "Event Time",
  },
  render: function Render(args) {
    const [time, setTime] = useState<Date | undefined>(new Date());
    return (
      <div className="w-80">
        <TimePicker {...args} value={time} onChange={(val) => setTime(val)} />
      </div>
    );
  },
};

export const Modal: Story = {
  name: "2. Modal",
  args: {
    variant: "modal",
    label: "Appointment Time",
  },
  render: function Render(args) {
    const [time, setTime] = useState<Date | undefined>(new Date());
    return (
      <div className="w-80">
        <TimePicker {...args} value={time} onChange={(val) => setTime(val)} />
      </div>
    );
  },
};

export const Fullscreen: Story = {
  name: "3. Fullscreen (Mobile Default)",
  args: {
    variant: "fullscreen",
    label: "Alarm Time",
  },
  parameters: {
    viewport: { defaultViewport: "mobile1" },
  },
  render: function Render(args) {
    const [time, setTime] = useState<Date | undefined>(new Date());
    return (
      <div className="flex h-screen w-full items-center justify-center bg-graphite-background p-4">
        <TimePicker {...args} value={time} onChange={(val) => setTime(val)} />
      </div>
    );
  },
};

export const AllSizesAndShapes: Story = {
  name: "4. Trigger Sizes & Shapes",
  render: () => (
    <div className="flex max-w-sm flex-col gap-8">
      <div>
        <h3 className="mb-4 font-bold">Small Size</h3>
        <div className="flex items-start gap-4">
          <TimePicker size="sm" shape="full" placeholder="Full" />
          <TimePicker size="sm" shape="minimal" placeholder="Minimal" />
          <TimePicker size="sm" shape="sharp" placeholder="Sharp" />
        </div>
      </div>
      <div>
        <h3 className="mb-4 font-bold">Medium Size</h3>
        <div className="flex items-start gap-4">
          <TimePicker size="md" shape="full" placeholder="Full" />
          <TimePicker size="md" shape="minimal" placeholder="Minimal" />
          <TimePicker size="md" shape="sharp" placeholder="Sharp" />
        </div>
      </div>
      <div>
        <h3 className="mb-4 font-bold">Large Size</h3>
        <div className="flex items-start gap-4">
          <TimePicker size="lg" shape="full" placeholder="Full" />
          <TimePicker size="lg" shape="minimal" placeholder="Minimal" />
          <TimePicker size="lg" shape="sharp" placeholder="Sharp" />
        </div>
      </div>
    </div>
  ),
};

export const Disabled: Story = {
  name: "5. Disabled State",
  args: {
    label: "Start Time",
    disabled: true,
  },
  render: function Render(args) {
    return (
      <div className="w-80">
        <TimePicker {...args} />
      </div>
    );
  },
};
```


### Component: `toast`

This section contains the source code for the `toast` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\toast\index.tsx`)**
```tsx
"use client";

import { Toaster as Sonner } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

/**
 * A toaster component that displays notifications. It is a styled wrapper
 * around the `sonner` library, configured to match the chesai-ui theme.
 */
const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      // The chesai-ui theme is light, so we set the sonner theme accordingly.
      theme="light"
      className="toaster group"
      toastOptions={{
        classNames: {
          // --- General Toast Styling ---
          toast:
            "group toast group-[.toaster]:bg-graphite-card group-[.toaster]:text-graphite-foreground group-[.toaster]:border-graphite-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-gray-500",

          // --- Button Styling ---
          actionButton:
            "group-[.toast]:bg-graphite-primary group-[.toast]:text-graphite-primaryForeground",
          cancelButton:
            "group-[.toast]:bg-graphite-secondary group-[.toast]:text-graphite-secondaryForeground",

          // --- Icon Styling for Different States ---
          success:
            "group-[.toast]:!text-green-500 group-[.toast]:[&_[data-icon]]:!text-green-500",
          error:
            "group-[.toast]:!text-red-500 group-[.toast]:[&_[data-icon]]:!text-red-500",
          warning:
            "group-[.toast]:!text-yellow-500 group-[.toast]:[&_[data-icon]]:!text-yellow-500",
          info: "group-[.toast]:!text-blue-500 group-[.toast]:[&_[data-icon]]:!text-blue-500",
        },
      }}
      {...props}
    />
  );
};

// Re-export the toast function from sonner for easy access
export { toast } from "sonner";
export { Toaster };
```

**Storybook Stories (`Toast.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Button } from "../button";
import { Typography } from "../typography";
import { toast, Toaster } from "./index";

const meta: Meta<typeof Toaster> = {
  title: "Components/Feedback/Toaster",
  component: Toaster,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A styled wrapper around the `sonner` toast library. To use, place the `<Toaster />` component at the root of your app, then call the `toast()` function from anywhere to trigger a notification.",
      },
    },
  },
  argTypes: {
    position: {
      control: "select",
      options: [
        "top-left",
        "top-center",
        "top-right",
        "bottom-left",
        "bottom-center",
        "bottom-right",
      ],
    },
    expand: { control: "boolean" },
    richColors: { control: "boolean" },
    duration: { control: "number" },
  },
};

export default meta;
type Story = StoryObj<typeof Toaster>;

export const Default: Story = {
  name: "1. Basic Usage",
  args: {
    position: "bottom-right",
  },
  render: (args) => (
    <div className="h-[75vh]">
      <Toaster {...args} />
      <div className="flex flex-col items-start gap-4">
        <Typography variant="large">Trigger Toasts</Typography>
        <div className="flex flex-wrap gap-2">
          <Button
            variant="secondary"
            onClick={() => toast("A new event has been created.")}
          >
            Default
          </Button>
          <Button
            variant="secondary"
            onClick={() =>
              toast.message("Event Created", {
                description: "Sunday, October 5, 2025 at 2:43 PM",
              })
            }
          >
            With Description
          </Button>
          <Button
            variant="secondary"
            onClick={() => toast.success("Profile updated successfully!")}
          >
            Success
          </Button>
          <Button
            variant="secondary"
            onClick={() => toast.error("Failed to connect to the server.")}
          >
            Error
          </Button>
        </div>
      </div>
    </div>
  ),
};

export const WithActions: Story = {
  name: "2. With Actions",
  args: {
    ...Default.args,
  },
  render: (args) => (
    <div className="h-[75vh]">
      <Toaster {...args} />
      <Button
        onClick={() =>
          toast("An item was added to your cart.", {
            action: {
              label: "Undo",
              onClick: () => console.log("Undo action triggered"),
            },
            cancel: {
              label: "Dismiss",
              onClick: () => console.log("Cancel action triggered"),
            },
          })
        }
      >
        Trigger Action Toast
      </Button>
    </div>
  ),
};

// Helper function to simulate a promise
const simulatePromise = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => {
      // Randomly resolve or reject
      if (Math.random() > 0.3) {
        resolve({ name: "Chesai UI" });
      } else {
        reject({ name: "API Error" });
      }
    }, 2000);
  });

export const AsyncPromise: Story = {
  name: "3. Async (Promise)",
  args: {
    ...Default.args,
  },
  render: (args) => (
    <div className="h-[75vh]">
      <Toaster {...args} />
      <Button
        onClick={() =>
          toast.promise(simulatePromise, {
            loading: "Saving your preferences...",
            success: (data: any) => `${data.name} preferences have been saved!`,
            error: "Could not save preferences.",
          })
        }
      >
        Trigger Promise Toast
      </Button>
    </div>
  ),
};

export const Positioning: Story = {
  name: "4. Positioning",
  render: () => (
    <div className="h-[75vh] grid grid-cols-3 gap-4">
      <Toaster position="top-left" />
      <Toaster position="top-center" />
      <Toaster position="top-right" />
      <Toaster position="bottom-left" />
      <Toaster position="bottom-center" />
      <Toaster position="bottom-right" />

      <Button
        variant="secondary"
        onClick={() => toast("Top Left", { id: "tl" })}
      >
        Top Left
      </Button>
      <Button
        variant="secondary"
        onClick={() => toast("Top Center", { id: "tc" })}
      >
        Top Center
      </Button>
      <Button
        variant="secondary"
        onClick={() => toast("Top Right", { id: "tr" })}
      >
        Top Right
      </Button>
      <Button
        variant="secondary"
        onClick={() => toast("Bottom Left", { id: "bl" })}
      >
        Bottom Left
      </Button>
      <Button
        variant="secondary"
        onClick={() => toast("Bottom Center", { id: "bc" })}
      >
        Bottom Center
      </Button>
      <Button
        variant="secondary"
        onClick={() => toast("Bottom Right", { id: "br" })}
      >
        Bottom Right
      </Button>
    </div>
  ),
};
```


### Component: `tooltip`

This section contains the source code for the `tooltip` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\tooltip\index.tsx`)**
```tsx
// 1. Install this dependency first:
// npm install @uidotdev/usehooks

import {
  arrow,
  autoUpdate,
  flip,
  FloatingPortal,
  offset,
  shift,
  useDismiss,
  useFloating,
  useFocus,
  useHover,
  useInteractions,
  useRole,
} from "@floating-ui/react";
// 2. Import the new hooks from the library
import { useLongPress, useMediaQuery } from "@uidotdev/usehooks";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import React, {
  cloneElement,
  createContext,
  isValidElement,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

// CVA definition remains unchanged
const tooltipVariants = cva("font-semibold relative z-50", {
  variants: {
    variant: {
      primary: "bg-graphite-primary text-graphite-primaryForeground",
      secondary: "bg-graphite-secondary text-graphite-secondaryForeground",
    },
    size: {
      sm: "px-2 py-1 text-xs",
      md: "px-3 py-1.5 text-sm",
      lg: "px-4 py-2 text-base",
    },
    shape: {
      full: "rounded-full",
      minimal: "rounded-lg",
      sharp: "rounded-none",
    },
  },
  defaultVariants: {
    variant: "primary",
    size: "md",
    shape: "minimal",
  },
});

export interface TooltipProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: "primary" | "secondary";
  size?: "sm" | "md" | "lg";
  shape?: "full" | "minimal" | "sharp";
}
// Context type remains unchanged
interface TooltipContextType {
  isOpen: boolean;
  setIsOpen: React.Dispatch<React.SetStateAction<boolean>>;
  getReferenceProps: (
    userProps?: React.HTMLProps<HTMLElement> | undefined
  ) => Record<string, unknown>;
  getFloatingProps: (
    userProps?: React.HTMLProps<HTMLElement> | undefined
  ) => Record<string, unknown>;
  floatingStyles: React.CSSProperties;
  refs: {
    setReference: (node: HTMLElement | null) => void;
    setFloating: (node: HTMLElement | null) => void;
  };
  middlewareData: ReturnType<typeof useFloating>["middlewareData"];
  placement: ReturnType<typeof useFloating>["placement"];
  arrowRef: React.RefObject<HTMLDivElement>;
}

const TooltipContext = createContext<TooltipContextType | null>(null);

export const useTooltip = (): TooltipContextType => {
  const context = useContext(TooltipContext);
  if (context == null) {
    throw new Error(
      "Tooltip components must be wrapped in <TooltipProvider />"
    );
  }
  return context;
};

// ==================== TooltipProvider (Refactored) ====================

export const TooltipProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const arrowRef = useRef<HTMLDivElement>(null);

  // 3. Use useMediaQuery to detect touch devices reliably
  const isTouchDevice = useMediaQuery("(pointer: coarse)");

  const data = useFloating({
    open: isOpen,
    onOpenChange: setIsOpen,
    middleware: [
      offset(10),
      flip(),
      shift({ padding: 8 }),
      arrow({ element: arrowRef }),
    ],
    whileElementsMounted: autoUpdate,
    strategy: "fixed",
    placement: "top",
  });

  const context = data.context;

  // Interactions from @floating-ui/react
  const hover = useHover(context, { enabled: !isTouchDevice, move: false });
  const focus = useFocus(context, { enabled: !isTouchDevice });
  const dismiss = useDismiss(context, { referencePress: !isTouchDevice });
  const role = useRole(context, { role: "tooltip" });

  // 4. Use useLongPress from the library
  // The callback is only passed if it's a touch device, otherwise it's null.
  const longPressEvents = useLongPress(
    isTouchDevice ? () => setIsOpen(true) : null,
    { threshold: 500 } // Long press duration
  );

  // useInteractions only manages the Floating UI native hooks
  const interactions = useInteractions([hover, focus, dismiss, role]);

  const value = useMemo(
    () => ({
      isOpen,
      setIsOpen,
      // 5. Manually merge the props from useInteractions and useLongPress
      getReferenceProps: (userProps) => ({
        ...interactions.getReferenceProps(userProps),
        ...(isTouchDevice ? longPressEvents : {}),
      }),
      getFloatingProps: interactions.getFloatingProps,
      floatingStyles: data.floatingStyles,
      refs: data.refs,
      middlewareData: data.middlewareData,
      placement: data.placement,
      arrowRef,
    }),
    [
      isOpen,
      interactions,
      isTouchDevice,
      longPressEvents,
      data.floatingStyles,
      data.refs,
      data.middlewareData,
      data.placement,
    ]
  );

  return (
    <TooltipContext.Provider value={value}>{children}</TooltipContext.Provider>
  );
};

// =====================================================================

// TooltipTrigger and mergeRefs remain unchanged
function mergeRefs<T>(
  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T> | null | undefined>
): React.RefCallback<T> {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        (ref as React.MutableRefObject<T | null>).current = value;
      }
    });
  };
}
export const TooltipTrigger = React.forwardRef<
  HTMLElement,
  React.HTMLProps<HTMLElement> & { asChild?: boolean }
>(function TooltipTrigger({ children, asChild = true, ...props }, propRef) {
  const context = useTooltip();
  const childrenRef = (children as any)?.ref;
  const ref = useMemo(
    () => mergeRefs([propRef, childrenRef, context.refs.setReference]),
    [propRef, childrenRef, context.refs.setReference]
  );
  if (!isValidElement(children)) {
    console.warn("TooltipTrigger expects a single React element as a child");
    return (
      <span
        ref={ref as any}
        {...context.getReferenceProps(props)}
        data-state={context.isOpen ? "open" : "closed"}
      >
        {children}
      </span>
    );
  }
  const childProps = children.props as Record<string, any>;
  return cloneElement(
    children,
    context.getReferenceProps({
      ref,
      ...props,
      ...childProps,
    })
  );
});

// Tooltip component remains unchanged
export const Tooltip = React.forwardRef<HTMLDivElement, TooltipProps>(
  ({ className, variant, size, shape, style, children, ...props }, ref) => {
    const context = useTooltip();
    const [isMounted, setIsMounted] = useState(false);
    const mergedRef = useMemo(
      () => mergeRefs([ref, context.refs.setFloating]),
      [ref, context.refs.setFloating]
    );
    useEffect(() => {
      if (context.isOpen) {
        const timer = setTimeout(() => setIsMounted(true), 10);
        return () => clearTimeout(timer);
      } else {
        setIsMounted(false);
      }
    }, [context.isOpen]);
    if (!context.isOpen) return null;

    const staticSide = {
      top: "bottom",
      right: "left",
      bottom: "top",
      left: "right",
    }[context.placement.split("-")[0]] as string;
    const arrowColorClass = {
      primary: "bg-graphite-primary",
      secondary: "bg-graphite-secondary",
    }[variant || "primary"];

    return (
      <FloatingPortal>
        <div
          ref={mergedRef}
          className={tooltipVariants({ variant, size, shape, className })}
          style={{
            ...context.floatingStyles,
            ...style,
            visibility: context.floatingStyles.transform ? "visible" : "hidden",
            opacity: isMounted ? 1 : 0,
            transition: "opacity 200ms ease-in-out",
          }}
          {...context.getFloatingProps(props)}
        >
          {children}
          <div
            ref={context.arrowRef}
            className={clsx("absolute h-2 w-2 rotate-45", arrowColorClass)}
            style={{
              left: context.middlewareData.arrow?.x ?? "",
              top: context.middlewareData.arrow?.y ?? "",
              [staticSide]: "-4px",
            }}
          />
        </div>
      </FloatingPortal>
    );
  }
);
Tooltip.displayName = "Tooltip";
```

**Storybook Stories (`Tooltip.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Bold, HelpCircle, Italic } from "lucide-react";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { Tooltip, TooltipProvider, TooltipTrigger } from "./index";

const meta: Meta<typeof Tooltip> = {
  title: "Components/Tooltip",
  // We point to the Tooltip content component as the primary component for controls
  component: Tooltip,
  // Subcomponents tell Storybook how the parts are related
  subcomponents: { TooltipProvider, TooltipTrigger },
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
  parameters: {
    docs: {
      description: {
        component:
          "A powerful, accessible tooltip built with Floating UI. It must be wrapped in a `TooltipProvider`.",
      },
    },
  },
  // The `render` function is used for all stories to provide the necessary context
  render: (args) => (
    <div className="flex justify-center items-center h-48">
      <TooltipProvider>
        <TooltipTrigger>
          <Button variant="secondary">Hover or Focus Me</Button>
        </TooltipTrigger>
        {/* Pass the story's args to the Tooltip content */}
        <Tooltip {...args}>This is a tooltip</Tooltip>
      </TooltipProvider>
    </div>
  ),
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    // You can control the tooltip's appearance here
    variant: "primary",
    size: "md",
    shape: "minimal",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex items-center gap-6 pt-8">
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton aria-label="Primary Tooltip">
            <Bold />
          </IconButton>
        </TooltipTrigger>
        <Tooltip variant="primary">Primary Tooltip</Tooltip>
      </TooltipProvider>
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton aria-label="Secondary Tooltip">
            <Italic />
          </IconButton>
        </TooltipTrigger>
        <Tooltip variant="secondary">Secondary Tooltip</Tooltip>
      </TooltipProvider>
    </div>
  ),
};

export const AllSizesAndShapes: Story = {
  name: "All Sizes & Shapes",
  render: () => (
    <div className="flex items-center gap-6 pt-8">
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton size="sm" aria-label="Small Minimal">
            <HelpCircle className="h-4 w-4" />
          </IconButton>
        </TooltipTrigger>
        <Tooltip size="sm" shape="minimal">
          Small Minimal
        </Tooltip>
      </TooltipProvider>
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton size="md" aria-label="Medium Full">
            <HelpCircle className="h-5 w-5" />
          </IconButton>
        </TooltipTrigger>
        <Tooltip size="md" shape="full">
          Medium Full
        </Tooltip>
      </TooltipProvider>
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton size="lg" aria-label="Large Sharp">
            <HelpCircle className="h-6 w-6" />
          </IconButton>
        </TooltipTrigger>
        <Tooltip size="lg" shape="sharp">
          Large Sharp
        </Tooltip>
      </TooltipProvider>
    </div>
  ),
};

export const DynamicPositioning: Story = {
  name: "Dynamic Positioning",
  parameters: {
    docs: {
      description: {
        story:
          "Place tooltips near the edge of the canvas to see them flip automatically.",
      },
    },
  },
  render: () => (
    <div className="w-full h-96 relative border border-dashed flex items-center justify-center">
      <div className="absolute top-2 left-2">
        <TooltipProvider>
          <TooltipTrigger>
            <IconButton aria-label="Top-left corner">
              <Bold />
            </IconButton>
          </TooltipTrigger>
          <Tooltip>Flipped to the bottom!</Tooltip>
        </TooltipProvider>
      </div>
      <div className="absolute bottom-2 right-2">
        <TooltipProvider>
          <TooltipTrigger>
            <IconButton aria-label="Bottom-right corner">
              <Italic />
            </IconButton>
          </TooltipTrigger>
          <Tooltip>This should stay on top.</Tooltip>
        </TooltipProvider>
      </div>
    </div>
  ),
};
```


### Component: `typography`

This section contains the source code for the `typography` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\typography\index.tsx`)**
```tsx
import React from "react";

const variants = {
  h1: "scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl",
  h2: "scroll-m-20  text-3xl font-semibold tracking-tight first:mt-0",
  h3: "scroll-m-20 text-2xl font-semibold tracking-tight",
  h4: "scroll-m-20 text-xl font-semibold tracking-tight",
  p: "leading-7 [&:not(:first-child)]:mt-6",
  blockquote:
    "mt-6 border-l-2 border-graphite-primary pl-6 italic text-gray-600",
  highlight:
    "relative rounded bg-graphite-secondary px-[0.3rem] py-[0.2rem] text-sm font-semibold text-graphite-secondaryForeground",
  lead: "text-xl text-gray-500",
  large: "text-lg font-semibold",
  small: "text-sm font-medium leading-none",
  muted: "text-sm text-gray-500",
};

const variantToTagMap: Record<keyof typeof variants, React.ElementType> = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  p: "p",
  blockquote: "blockquote",
  highlight: "span",
  lead: "p",
  large: "div",
  small: "small",
  muted: "p",
};

// 1. Define the component's specific props
type TypographyOwnProps = {
  variant?: keyof typeof variants;
  className?: string;
};

// 2. Create a refined generic props type for the polymorphic component
// This type merges the component's own props (P) with the native props
// of the element (C), while ensuring no keys are accidentally omitted.
type PolymorphicComponentProps<
  C extends React.ElementType,
  P extends object
> = P & Omit<React.ComponentPropsWithoutRef<C>, keyof P>;

// 3. Create the final props type for our Typography component
// We add 'as' to the TypographyOwnProps to make it an explicit part of our own props.
type TypographyProps<C extends React.ElementType> = PolymorphicComponentProps<
  C,
  TypographyOwnProps & { as?: C }
>;

// 4. Create a generic Ref type
type PolymorphicRef<C extends React.ElementType> =
  React.ComponentPropsWithRef<C>["ref"];

// 5. Define the component's function signature with the correct types and a displayName property
type TypographyComponent = (<C extends React.ElementType = "p">(
  props: TypographyProps<C> & { ref?: PolymorphicRef<C> }
) => React.ReactElement | null) & {
  displayName?: string;
};

// 6. Implement the component using forwardRef and the correct types.
// We cast the result to TypographyComponent to ensure all type declarations are met.
export const Typography = React.forwardRef(
  <C extends React.HTMLElementType = "p">(
    { as, variant, className, children, ...restProps }: TypographyProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const Component = as || variantToTagMap[variant] || "p";
    const combinedClassName = `${variants[variant]} ${className || ""}`.trim();

    return (
      <Component ref={ref} className={combinedClassName} {...restProps}>
        {children}
      </Component>
    );
  }
) as TypographyComponent;

Typography.displayName = "Typography";
```

**Storybook Stories (`Typography.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Typography } from "./index";

const meta: Meta<typeof Typography> = {
  title: "Components/Typography",
  component: Typography,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: [
        "h1",
        "h2",
        "h3",
        "h4",
        "p",
        "blockquote",
        "code",
        "lead",
        "large",
        "small",
        "muted",
      ],
    },
    as: {
      control: "text",
      description:
        'Render the component as a different HTML tag (e.g., "span").',
    },
    children: {
      control: "text",
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "p",
    children:
      "This is a default paragraph. The quick brown fox jumps over the lazy dog.",
  },
};

export const Heading1: Story = {
  args: {
    variant: "h1",
    children: "This is an H1 Heading",
  },
};

export const AllVariants: Story = {
  render: () => (
    <div className="space-y-4">
      <Typography variant="h1">H1: The quick brown fox</Typography>
      <Typography variant="h2">H2: The quick brown fox</Typography>
      <Typography variant="h3">H3: The quick brown fox</Typography>
      <Typography variant="h4">H4: The quick brown fox</Typography>
      <Typography variant="p">
        p: The quick brown fox jumps over the lazy dog. This is a standard
        paragraph used for long-form content.
      </Typography>
      <Typography variant="lead">
        lead: The quick brown fox jumps over the lazy dog. This is a leading
        paragraph that stands out.
      </Typography>
      <Typography variant="large">
        large: The quick brown fox jumps over the lazy dog. For slightly larger,
        emphasized text.
      </Typography>
      <Typography variant="small">
        small: The quick brown fox jumps over the lazy dog. For fine print or
        less important details.
      </Typography>
      <Typography variant="muted">
        muted: The quick brown fox jumps over the lazy dog. For subtle, muted
        text.
      </Typography>
      <Typography variant="blockquote">
        blockquote: "The quick brown fox jumps over the lazy dog."
      </Typography>
      <Typography variant="p">
        Use <code>code</code> variant for inline code like{" "}
        <Typography variant="highlight">npm install your-library</Typography>
      </Typography>
    </div>
  ),
};

export const Polymorphic: Story = {
  args: {
    variant: "h1",
    as: "div", // Render an H1 style but with a <div> tag
    children: "This looks like an H1, but it is a div tag.",
  },
};
```


---

## React Context


### Source: `src\lib\context\index.ts`

```ts
export * from './ThemeProvider'
```


### Source: `src\lib\context\List.context.ts`

```ts
import { createContext } from 'react'

export interface ListContextProps {
  // Selection Mode
  isSelectionMode: boolean
  setIsSelectionMode: (value: boolean) => void
  selectedItems: Set<string | number>
  toggleSelection: (id: string | number) => void
  isSelectable: boolean

  // Reorder Mode
  isReorderable: boolean

  // --- NEW STYLING PROPS ---
  variant: 'primary' | 'secondary'
  shape: 'full' | 'minimal' | 'sharp'
  size: 'sm' | 'md' | 'lg'
}

export const ListContext = createContext<ListContextProps | null>(null)
```


### Source: `src\lib\context\ThemeProvider.tsx`

```tsx
"use client";

import type React from "react";
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

interface ThemeProviderState {
  theme: Theme;
  setTheme: (theme: Theme) => void;
}

const initialState: ThemeProviderState = {
  theme: "system",
  setTheme: () => null,
};

const ThemeProviderContext = createContext<ThemeProviderState>(initialState);

interface ThemeProviderProps {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
}

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "chesai-ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  );

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove("theme-light", "theme-dark");

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light";

      root.classList.add(`theme-${systemTheme}`);
      return;
    }

    root.classList.add(`theme-${theme}`);
  }, [theme]);

  const value = {
    theme,
    setTheme: (newTheme: Theme) => {
      localStorage.setItem(storageKey, newTheme);
      setTheme(newTheme);
    },
  };

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};
```


---

## Custom Hooks


### Source: `src\lib\hooks\index.ts`

```ts
export * from './use-calender'
export * from './use-time-picker'
export * from './useAppBar'
export * from './useShallowRouter'
```


### Source: `src\lib\hooks\use-calender.ts`

```ts
import {
  add,
  eachDayOfInterval,
  endOfMonth,
  endOfWeek,
  format,
  isAfter, // FIX: Import isAfter
  isBefore, // FIX: Import isBefore
  isSameDay,
  isSameMonth,
  isToday,
  startOfMonth,
  startOfWeek,
} from 'date-fns'
import { useMemo } from 'react'
// FIX: Use 'import type' for type-only imports
import type { DateRange } from 'react-day-picker'

export const useCalendar = (cursorDate: Date, value?: Date | DateRange, mode: 'single' | 'range' = 'single') => {
  const firstDayOfMonth = startOfMonth(cursorDate)
  const lastDayOfMonth = endOfMonth(cursorDate)
  const firstDayOfFirstWeek = startOfWeek(firstDayOfMonth)
  const lastDayOfLastWeek = endOfWeek(lastDayOfMonth)

  const daysInMonth = useMemo(
    () =>
      eachDayOfInterval({
        start: firstDayOfFirstWeek,
        end: lastDayOfLastWeek,
      }),
    [firstDayOfFirstWeek, lastDayOfLastWeek],
  )

  const getDayProps = (day: Date) => {
    // FIX: Use type guards to safely check for properties on 'value'
    const isValueDateRange = mode === 'range' && value && 'from' in value

    const isSelected =
      (mode === 'single' && value instanceof Date && isSameDay(day, value)) ||
      (isValueDateRange && ((value.from && isSameDay(day, value.from)) || (value.to && isSameDay(day, value.to))))

    const isRangeStart = isValueDateRange && value.from && isSameDay(day, value.from)

    const isRangeEnd = isValueDateRange && value.to && isSameDay(day, value.to)

    const isInRange = isValueDateRange && value.from && value.to && isAfter(day, value.from) && isBefore(day, value.to)

    return {
      isCurrentMonth: isSameMonth(day, cursorDate),
      isToday: isToday(day),
      isSelected,
      isRangeStart,
      isRangeEnd,
      isInRange,
    }
  }

  return {
    daysInMonth,
    weekdays: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    getDayProps,
  }
}
```


### Source: `src\lib\hooks\use-time-picker.ts`

```ts
import { getHours, getMinutes, setHours, setMinutes } from 'date-fns'
import { useMemo, useState } from 'react'

export const useTimePicker = (initialDate: Date) => {
  const [time, setTime] = useState(initialDate)

  const hours = getHours(time)
  const minutes = getMinutes(time)

  const period = useMemo(() => (hours >= 12 ? 'PM' : 'AM'), [hours])
  const displayHour = useMemo(() => {
    const h = hours % 12
    return h === 0 ? 12 : h
  }, [hours])

  const setHour = (hour: number) => {
    // Converts 12-hour format to 24-hour format
    let newHour = hour
    if (period === 'PM' && newHour < 12) {
      newHour += 12
    } else if (period === 'AM' && newHour === 12) {
      newHour = 0 // Midnight case
    }
    setTime(prev => setHours(prev, newHour))
  }

  const setMinute = (minute: number) => {
    setTime(prev => setMinutes(prev, minute))
  }

  const setPeriod = (newPeriod: 'AM' | 'PM') => {
    if (newPeriod !== period) {
      const currentHours = getHours(time)
      if (newPeriod === 'PM' && currentHours < 12) {
        setTime(prev => setHours(prev, currentHours + 12))
      } else if (newPeriod === 'AM' && currentHours >= 12) {
        setTime(prev => setHours(prev, currentHours - 12))
      }
    }
  }

  const formattedTime = useMemo(
    () => ({
      hour: String(displayHour).padStart(2, '0'),
      minute: String(minutes).padStart(2, '0'),
      period: period,
    }),
    [displayHour, minutes, period],
  )

  return {
    time,
    setTime,
    displayHour,
    minutes,
    period,
    setHour,
    setMinute,
    setPeriod,
    formattedTime,
  }
}
```


### Source: `src\lib\hooks\useAppBar.ts`

```ts
import {
  type MotionStyle,
  useMotionValue,
  useMotionValueEvent,
  useScroll,
  useSpring,
  useTransform,
} from 'framer-motion'
import { useEffect, useLayoutEffect, useRef, useState } from 'react' // Import useEffect
import type { AppBarSharedProps } from '../components/appbar'

// --- HOOK DEFINITION ---
export type UseAppBarOptions = AppBarSharedProps

export const useAppBar = (
  options: UseAppBarOptions & {
    appBarColor?: 'background' | 'card' | 'primary' | 'secondary'
  },
) => {
  const {
    scrollBehavior = 'sticky',
    animatedBehavior = [],
    animatedColor = 'secondary',
    appBarColor = 'card',
    size = 'md',
    largeHeaderContent,
    smallHeaderContent,
    stickyHideTarget,
    scrollContainerRef,
    normalHeaderRowHeight = 64,
    largeHeaderRowHeight = 96,
    foldAnimationDistance = 50,
    foldBorderRadius = 24,
    // --- MODIFICATION: Destructure the new routeKey prop ---
    routeKey,
  } = options

  // --- REFS & STATE ---
  const mainRowRef = useRef<HTMLDivElement>(null)
  const largeHeaderRef = useRef<HTMLDivElement>(null)

  const [isScrolled, setIsScrolled] = useState(false)
  const { scrollY } = useScroll({ container: scrollContainerRef })
  const headerY = useMotionValue(0)

  const [measuredHeights, setMeasuredHeights] = useState({
    mainRow: size === 'lg' ? largeHeaderRowHeight : normalHeaderRowHeight,
    largeContent: 0,
  })

  // --- BEHAVIOR LOGIC ---
  const isCollapsible = size === 'lg' && !!largeHeaderContent && !!smallHeaderContent
  const shouldRenderLargeContent = size === 'lg' && !!largeHeaderContent

  // --- MEASUREMENT EFFECTS ---
  useLayoutEffect(() => {
    const measuredMainRow = mainRowRef.current?.offsetHeight
    const measuredLargeContent = largeHeaderRef.current?.offsetHeight
    if (
      (measuredMainRow && measuredMainRow !== measuredHeights.mainRow) ||
      (measuredLargeContent !== undefined && measuredLargeContent !== measuredHeights.largeContent)
    ) {
      setMeasuredHeights({
        mainRow: measuredMainRow || measuredHeights.mainRow,
        largeContent: measuredLargeContent || 0,
      })
    }
  })

  // --- MODIFICATION: Add useEffect to reset AppBar position on route change ---
  useEffect(() => {
    // Reset the header's vertical position whenever the route changes.
    // This ensures the new screen's AppBar is always visible on mount.
    headerY.set(0)
  }, [routeKey, headerY])
  // --- END MODIFICATION ---

  // --- ANIMATION LOGIC ---
  useMotionValueEvent(scrollY, 'change', latest => {
    setIsScrolled(latest > 10)

    if (scrollBehavior === 'conditionally-sticky') {
      const { mainRow, largeContent } = measuredHeights
      const collapseDistance = isCollapsible ? largeContent : 0

      let heightToHide: number
      if (stickyHideTarget === 'full-appbar' && size === 'lg') {
        heightToHide = mainRow + largeContent
      } else if (stickyHideTarget === 'main-row') {
        heightToHide = isCollapsible ? normalHeaderRowHeight : mainRow
      } else {
        heightToHide = isCollapsible ? normalHeaderRowHeight : mainRow + largeContent
      }

      const scrollPastCollapse = latest - collapseDistance
      if (scrollPastCollapse <= 0) {
        headerY.set(0)
        return
      }

      const previous = scrollY.getPrevious() ?? 0
      const previousScrollPastCollapse = Math.max(0, previous - collapseDistance)
      const delta = scrollPastCollapse - previousScrollPastCollapse
      const newHeaderY = headerY.get() - delta

      const clampedHeaderY = Math.max(-heightToHide, Math.min(newHeaderY, 0))
      headerY.set(clampedHeaderY)
    } else {
      headerY.set(0)
    }
  })

  // --- DERIVED ANIMATION VALUES ---
  const shouldAnimateColor = animatedBehavior.includes('appbar-color')
  const shouldFold = animatedBehavior.includes('fold')
  const shouldAnimateShadow = animatedBehavior.includes('shadow')

  const finalColor = shouldAnimateColor && isScrolled ? animatedColor : appBarColor
  const finalShadow: 'md' | 'none' = shouldAnimateShadow && isScrolled ? 'md' : 'none'

  const animatedBorderRadius = useTransform(scrollY, [0, foldAnimationDistance], [0, foldBorderRadius], { clamp: true })

  const collapseAnimDistance = measuredHeights.largeContent
  const measuredLargeRowHeight = measuredHeights.mainRow
  const totalExpandedHeight = measuredLargeRowHeight + collapseAnimDistance

  const animatedTotalHeight = useTransform(
    scrollY,
    [0, collapseAnimDistance],
    [totalExpandedHeight, normalHeaderRowHeight],
    { clamp: true },
  )
  const smoothAnimatedTotalHeight = useSpring(animatedTotalHeight, {
    stiffness: 300,
    damping: 30,
    mass: 0.5,
  })

  const animatedMainRowHeight = useTransform(
    scrollY,
    [0, collapseAnimDistance],
    [measuredLargeRowHeight, normalHeaderRowHeight],
    { clamp: true },
  )
  const headerRowHeight = isCollapsible ? animatedMainRowHeight : measuredHeights.mainRow

  const largeHeaderOpacity = useTransform(scrollY, [0, collapseAnimDistance * 0.75], [1, 0], { clamp: true })
  const largeHeaderY = useTransform(scrollY, [0, collapseAnimDistance], [0, -40], { clamp: true })

  const titleCrossFadeStart = collapseAnimDistance * 0.4
  const titleCrossFadeEnd = collapseAnimDistance * 0.9

  const childrenOpacity = useTransform(scrollY, [titleCrossFadeStart, titleCrossFadeEnd], [1, 0], { clamp: true })
  const smallHeaderOpacity = useTransform(scrollY, [titleCrossFadeStart, titleCrossFadeEnd], [0, 1], { clamp: true })

  const contentPaddingTop = shouldRenderLargeContent ? totalExpandedHeight + 10 : measuredHeights.mainRow + 20

  return {
    isScrolled,
    contentPaddingTop,
    headerProps: {
      style: {
        y: headerY,
        height: isCollapsible ? smoothAnimatedTotalHeight : undefined,
        borderBottomLeftRadius: shouldFold ? animatedBorderRadius : undefined,
        borderBottomRightRadius: shouldFold ? animatedBorderRadius : undefined,
      } as MotionStyle,
    },
    mainRowProps: {
      ref: mainRowRef,
      style: { height: headerRowHeight },
    },
    largeContentProps: {
      ref: largeHeaderRef,
      style: {
        opacity: isCollapsible ? largeHeaderOpacity : 1,
        y: isCollapsible ? largeHeaderY : 0,
        pointerEvents: isScrolled && isCollapsible ? 'none' : 'auto',
      } as MotionStyle,
    },
    childrenContainerProps: {
      style: { opacity: isCollapsible ? childrenOpacity : 1 },
    },
    smallHeaderProps: {
      style: { opacity: smallHeaderOpacity },
    },
    finalColor,
    finalShadow,
    isCollapsible,
    shouldRenderLargeContent,
  }
}
```


### Source: `src\lib\hooks\useShallowRouter.ts`

```ts
import { useCallback, useEffect, useMemo, useState } from "react";

// --- TYPE DEFINITIONS (Fix for TypeScript errors) ---
type HistoryMode = "search" | "pathname";

interface UseHistoryOptions {
  mode?: HistoryMode;
  paramName?: string;
  basePath?: string;
}

type Params = Record<string, string | number | boolean | null | undefined>;

// --- HOOK IMPLEMENTATION ---

// Custom useHistory Hook with configurable routing modes
const useShallowRouter = (options: UseHistoryOptions = {}) => {
  const { mode = "search", paramName = "path", basePath = "/" } = options;

  const [searchParams, setSearchParams] = useState(
    () => new URLSearchParams(window.location.search)
  );
  const [pathname, setPathname] = useState(() => window.location.pathname);

  // Get current path based on mode
  const currentPath = useMemo(() => {
    if (mode === "pathname") {
      // Extract path relative to basePath
      // FIX: Used template literal instead of concatenation
      if (pathname === basePath || pathname === `${basePath}/`) {
        return "/";
      }
      if (pathname.startsWith(basePath)) {
        return pathname.slice(basePath.length) || "/";
      }
      return "/";
    }
    // Search param mode
    return searchParams.get(paramName) || "/";
  }, [mode, pathname, searchParams, paramName, basePath]);

  // Get all other params except the routing param
  const otherParams = useMemo(() => {
    const params = new URLSearchParams(searchParams);
    params.delete(paramName);
    return params;
  }, [searchParams, paramName]);

  // Update state when browser navigation occurs (e.g., back/forward buttons)
  useEffect(() => {
    const handlePopState = () => {
      setSearchParams(new URLSearchParams(window.location.search));
      setPathname(window.location.pathname);
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  // Push new path to history
  const push = useCallback(
    (path: string, additionalParams: Params = {}, state: any = null) => {
      if (mode === "pathname") {
        // --- FEATURE: Handle pathname mode navigation ---
        const newPathname =
          path === "/" || !path ? basePath : `${basePath}${path}`;
        const newParams = new URLSearchParams();
        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string
            newParams.set(key, String(value));
          }
        });
        const newSearch = newParams.toString();
        const newUrl = `${newPathname}${newSearch ? `?${newSearch}` : ""}`;

        window.history.pushState(state, "", newUrl);
        setPathname(newPathname);
        setSearchParams(newParams);
      } else {
        // --- Original search mode logic ---
        const newParams = new URLSearchParams(window.location.search);
        if (path) {
          newParams.set(paramName, path);
        } else {
          newParams.delete(paramName);
        }

        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string to prevent ts(2345)
            newParams.set(key, String(value));
          } else {
            newParams.delete(key);
          }
        });

        const newUrl = `${window.location.pathname}?${newParams.toString()}`;
        window.history.pushState(state, "", newUrl);
        setSearchParams(newParams);
      }
    },
    [mode, basePath, paramName] // Updated dependencies
  );

  // Replace current path in history
  const replace = useCallback(
    (path: string, additionalParams: Params = {}, state: any = null) => {
      if (mode === "pathname") {
        // --- FEATURE: Handle pathname mode navigation ---
        const newPathname =
          path === "/" || !path ? basePath : `${basePath}${path}`;
        const newParams = new URLSearchParams();
        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            newParams.set(key, String(value));
          }
        });
        const newSearch = newParams.toString();
        const newUrl = `${newPathname}${newSearch ? `?${newSearch}` : ""}`;

        window.history.replaceState(state, "", newUrl);
        setPathname(newPathname);
        setSearchParams(newParams);
      } else {
        // --- Original search mode logic ---
        const newParams = new URLSearchParams(window.location.search);
        if (path) {
          newParams.set(paramName, path);
        } else {
          newParams.delete(paramName);
        }

        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string to prevent ts(2345)
            newParams.set(key, String(value));
          } else {
            newParams.delete(key);
          }
        });

        const newUrl = `${window.location.pathname}?${newParams.toString()}`;
        window.history.replaceState(state, "", newUrl);
        setSearchParams(newParams);
      }
    },
    [mode, basePath, paramName] // Updated dependencies
  );

  // Update only specific params without changing the path
  const updateParams = useCallback(
    (params: Params, replaceHistory = false) => {
      const newParams = new URLSearchParams(window.location.search);

      Object.entries(params).forEach(([key, value]) => {
        if (key !== paramName) {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string to prevent ts(2345)
            newParams.set(key, String(value));
          } else {
            newParams.delete(key);
          }
        }
      });

      const newUrl = `${window.location.pathname}?${newParams.toString()}`;

      if (replaceHistory) {
        window.history.replaceState(null, "", newUrl);
      } else {
        window.history.pushState(null, "", newUrl);
      }
      setSearchParams(newParams);
    },
    [paramName]
  );

  // Clear all params except the path
  const clearParams = useCallback(
    (keepPath = true) => {
      const newParams = new URLSearchParams();
      let newUrl = window.location.pathname;

      if (mode === "search" && keepPath && currentPath && currentPath !== "/") {
        newParams.set(paramName, currentPath);
      }

      const newSearchString = newParams.toString();
      if (newSearchString) {
        newUrl = `${newUrl}?${newSearchString}`;
      }

      window.history.pushState(null, "", newUrl);
      setSearchParams(newParams);
    },
    [currentPath, paramName, mode] // Updated dependencies
  );

  // Get a specific param value
  const getParam = useCallback(
    (key: string) => searchParams.get(key),
    [searchParams]
  );

  // Check if a param exists
  const hasParam = useCallback(
    (key: string) => searchParams.has(key),
    [searchParams]
  );

  // Navigation helpers
  const goBack = useCallback(() => window.history.back(), []);
  const goForward = useCallback(() => window.history.forward(), []);
  const go = useCallback((n: number) => window.history.go(n), []);

  return {
    path: currentPath,
    searchParams,
    otherParams,
    push,
    replace,
    goBack,
    goForward,
    go,
    updateParams,
    clearParams,
    getParam,
    hasParam,
    // Note: These values are snapshots and won't update on their own.
    // They are provided for convenience but could become stale.
    length: window.history.length,
    href: window.location.href,
    basename: window.location.pathname,
  };
};

export default useShallowRouter;
```


---

## Tailwind & Styling


### Source: `src\lib\tailwind\theme.css`

```css
/* src\lib\tailwind\theme.css */

@import url("https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap");
@import "tailwindcss";
@theme {
  /*
  |--------------------------------------------------------------------------
  | Project-Specific Theme Values
  |--------------------------------------------------------------------------
  */

  --font-manrope: manrope, sans-serif;

  /* Graphite Color Theme Definitions */
  --color-graphite-primary: hsl(0 0% 9%);            /* #171717 */
  --color-graphite-primaryForeground: hsl(0 0% 98%);  /* #FAFAFA */
  --color-graphite-secondary: hsl(0 0% 96.1%);       /* #F5F5F5 */
  --color-graphite-secondaryForeground: hsl(0 0% 9%); /* #171717 */
  --color-graphite-background: hsl(33 33% 98%);      /* #FDFBFA */
  --color-graphite-foreground: hsl(0 0% 9%);         /* #171717 */
  --color-graphite-card: hsl(0 0% 100%);             /* #FFFFFF */
  --color-graphite-cardForeground: hsl(0 0% 9%);
  --color-graphite-border: hsl(0 0% 93%);            /* #EDEDED */
  --color-graphite-ring: hsl(0 0% 9%);

  /*
  |--------------------------------------------------------------------------
  | Animations
  |--------------------------------------------------------------------------
  */

  /* 1. Define the animation keyframes */
  @keyframes menu-enter {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(-0.5rem);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  @keyframes menu-exit {
    from {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
    to {
      opacity: 0;
      transform: scale(0.9) translateY(-0.5rem);
    }
  }

  /* --- SELECT ANIMATIONS (Center-Out Clip-Path) --- */
  @keyframes select-enter-clip {
    from {
      opacity: 0;
      clip-path: inset(50% 0 50% 0);
    }
    to {
      opacity: 1;
      clip-path: inset(0 0 0 0);
    }
  }

  @keyframes select-exit-clip {
    from {
      opacity: 1;
      clip-path: inset(0 0 0 0);
    }
    to {
      opacity: 0;
      clip-path: inset(50% 0 50% 0);
    }
  }
  /* --- END SELECT ANIMATIONS --- */

  @keyframes submenu-enter-right {
    from { opacity: 0; transform: scale(0.95) translateX(-0.5rem); }
    to { opacity: 1; transform: scale(1) translateX(0); }
  }

  @keyframes submenu-enter-left {
    from { opacity: 0; transform: scale(0.95) translateX(0.5rem); }
    to { opacity: 1; transform: scale(1) translateX(0); }
  }

  @keyframes submenu-exit-right {
    from { opacity: 1; transform: scale(1) translateX(0); }
    to { opacity: 0; transform: scale(0.95) translateX(-0.5rem); }
  }

  @keyframes submenu-exit-left {
    from { opacity: 1; transform: scale(1) translateX(0); }
    to { opacity: 0; transform: scale(0.95) translateX(0.5rem); }
  }

  @keyframes check-in {
    from {
      opacity: 0;
      transform: scale(0.5) rotate(-90deg);
    }
    to {
      opacity: 1;
      transform: scale(1) rotate(0deg);
    }
  }

  /* --- NEW: Radix Navigation Menu Animations --- */
@keyframes enter-from-right {
  from {
    opacity: 0;
    transform: translateX(12.5rem);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes enter-from-left {
  from {
    opacity: 0;
    transform: translateX(-12.5rem);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
/* Add to your theme.css or equivalent */
@keyframes caret-blink {
  0%, 70%, 100% { opacity: 1; }
  20%, 50% { opacity: 0; }
}

@keyframes exit-to-right {
  from {
    opacity: 1;
    transform: translateX(0);
  }
  to {
    opacity: 0;
    transform: translateX(12.5rem);
  }
}

@keyframes exit-to-left {
  from {
    opacity: 1;
    transform: translateX(0);
  }
  to {
    opacity: 0;
    transform: translateX(-12.5rem);
  }
}

@keyframes scale-in-content {
  from {
    opacity: 0;
    transform: rotateX(-15deg) scale(0.9);
  }
  to {
    opacity: 1;
    transform: rotateX(0deg) scale(1);
  }
}

@keyframes scale-out-content {
  from {
    opacity: 1;
    transform: rotateX(0deg) scale(1);
  }
  to {
    opacity: 0;
    transform: rotateX(-10deg) scale(0.95);
  }
}

@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes fade-out {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

/* --- END: Radix Navigation Menu Animations --- */

@keyframes accordion-down {
  from {
    height: 0;
    opacity: 0;
  }
  to {
    height: var(--radix-accordion-content-height);
    opacity: 1;
  }
}

@keyframes accordion-up {
  from {
    height: var(--radix-accordion-content-height);
    opacity: 1;
  }
  to {
    height: 0;
    opacity: 0;
  }
}

/* Add these new utilities to your --animate-* list */
--animate-accordion-down: accordion-down 200ms cubic-bezier(0.87, 0, 0.13, 1) forwards;
--animate-accordion-up: accordion-up 200ms cubic-bezier(0.87, 0, 0.13, 1) forwards;



  /* 2. Create the `animate-*` utility classes from the keyframes */
  --animate-menu-enter: menu-enter 300ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-menu-exit: menu-exit 150ms cubic-bezier(0.4, 0, 1, 1) forwards;
  
  /* --- SELECT UTILITIES --- */
  --animate-select-enter: select-enter-clip 200ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-select-exit: select-exit-clip 1500ms cubic-bezier(0.4, 0, 1, 1) forwards;
  /* --- END SELECT UTILITIES --- */
  --animate-submenu-enter-right: submenu-enter-right 250ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-submenu-enter-left: submenu-enter-left 250ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-submenu-exit-right: submenu-exit-right 150ms cubic-bezier(0.4, 0, 1, 1) forwards;
  --animate-submenu-exit-left: submenu-exit-left 150ms cubic-bezier(0.4, 0, 1, 1) forwards;
  
  --animate-check-in: check-in 200ms cubic-bezier(0.2, 0, 0, 1) forwards;
  

  --animate-nav-enter-from-right: enter-from-right 250ms ease;
--animate-nav-enter-from-left: enter-from-left 250ms ease;
--animate-nav-exit-to-right: exit-to-right 250ms ease;
--animate-nav-exit-to-left: exit-to-left 250ms ease;
--animate-nav-scale-in: scale-in-content 200ms ease;
--animate-nav-scale-out: scale-out-content 200ms ease;
--animate-nav-fade-in: fade-in 200ms ease;
--animate-nav-fade-out: fade-out 200ms ease;

  --animate-caret-blink: caret-blink 1.25s ease-out infinite;


}

@layer base {
  body {
    @apply font-manrope  text-gray-900;
  }
}


input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
input[type="number"] {
  -moz-appearance: none;
}
@media only screen and (hover: none) and (pointer: coarse) {
  * {
    cursor: default !important;
    user-select: none;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    overscroll-behavior: contain;
  }
  ::-webkit-scrollbar {
  display: none; /* Hides the scrollbar visually */
  width: 0; /* Removes any allocated space for the scrollbar */
  background: transparent; /* Makes the scrollbar track transparent */
}

}
  [data-vaul-drawer][data-vaul-drawer-direction="bottom"]::after {
    opacity: var(--vaul-after-display, block);
  }

    [data-vaul-drawer][data-vaul-drawer-direction="left"]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction="right"]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction="top"]::after {
    opacity: var(--vaul-after-display, block);
  }

  
/*  */
  [data-vaul-drawer][data-vaul-drawer-direction=bottom]::after {
    opacity: var(--vaul-after-display, block);
  }

    [data-vaul-drawer][data-vaul-drawer-direction=left]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction=right]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction=top]::after {
    opacity: var(--vaul-after-display, block);
  }

  textarea {
  resize: none;
}
```
