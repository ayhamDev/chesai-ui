
# AI Prompt Context for chesai-ui Component Library

You are an expert React developer tasked with assisting in the development of the "chesai-ui" library. The following document contains the complete source code for all UI components, hooks, contexts, and styling configurations.

**Your Task:**
- Use this file as the single source of truth for the entire library.
- When asked to create, modify, or extend any part of the library, refer to its source code provided here.
- Maintain the existing coding style, architecture, and conventions (e.g., using CVA, Radix UI, Framer Motion).
- Provide complete, copy-pasteable code blocks for your solutions.

---

## UI Components


### Component: `appbar`

This section contains the source code for the `appbar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\appbar\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import {
  motion,
  useMotionValue,
  useMotionValueEvent,
  useScroll,
  useSpring,
  useTransform,
  type MotionValue,
} from "framer-motion";
import React, {
  createContext,
  useContext,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from "react";

// --- CONSTANTS ---
const FALLBACK_NORMAL_HEADER_ROW_HEIGHT = 64;
const FALLBACK_LARGE_HEADER_ROW_HEIGHT = 96;
const FOLD_ANIMATION_DISTANCE = 50; // How many pixels to scroll to complete the fold
const FOLD_BORDER_RADIUS = 24; // Equivalent to rounded-3xl

// --- TYPE DEFINITIONS ---
type AppBarColor = "background" | "card" | "primary" | "secondary";
type AppBarScrollBehavior = "sticky" | "conditionally-sticky";
// Added 'shadow' to the possible behaviors
type AppBarAnimatedBehavior = "none" | "appbar-color" | "fold" | "shadow";
type AppBarSize = "md" | "lg";
type StickyHideTarget = "main-row" | "full-appbar";

// --- CONTEXT (No changes) ---
interface AppBarContextProps {
  isScrolled: boolean;
  scrollY: MotionValue<number>;
  headerY: MotionValue<number>;
  setCollapseDistance: (distance: number) => void;
  setHeightToHideForSticky: (height: number) => void;
  setScrollBehavior: (behavior: AppBarScrollBehavior) => void;
}
const AppBarContext = createContext<AppBarContextProps | null>(null);
const useAppBarContext = () => {
  const context = useContext(AppBarContext);
  if (!context) {
    throw new Error(
      "AppBar components must be used within an <AppBar.Provider>"
    );
  }
  return context;
};

// --- PROVIDER (No changes) ---
interface AppBarProviderProps {
  children: React.ReactNode;
  mainContentColor?: AppBarColor;
}

const AppBarProvider: React.FC<AppBarProviderProps> = ({
  children,
  mainContentColor = "card",
}) => {
  const [isScrolled, setIsScrolled] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);
  const { scrollY } = useScroll({ container: scrollRef });

  const headerY = useMotionValue(0);
  const [collapseDistance, setCollapseDistance] = useState(0);
  const [heightToHideForSticky, setHeightToHideForSticky] = useState(
    FALLBACK_NORMAL_HEADER_ROW_HEIGHT
  );
  const [scrollBehavior, setScrollBehavior] =
    useState<AppBarScrollBehavior>("sticky");

  useMotionValueEvent(scrollY, "change", (latest) => {
    setIsScrolled(latest > 10);

    if (scrollBehavior === "conditionally-sticky") {
      const scrollPastCollapse = latest - collapseDistance;

      if (scrollPastCollapse <= 0) {
        headerY.set(0);
        return;
      }

      const previous = scrollY.getPrevious() ?? 0;
      const previousScrollPastCollapse = Math.max(
        0,
        previous - collapseDistance
      );
      const delta = scrollPastCollapse - previousScrollPastCollapse;
      const newHeaderY = headerY.get() - delta;

      const clampedHeaderY = Math.max(
        -heightToHideForSticky,
        Math.min(newHeaderY, 0)
      );
      headerY.set(clampedHeaderY);
    } else {
      headerY.set(0);
    }
  });

  const backgroundClasses: Record<AppBarColor, string> = {
    background: "bg-graphite-background",
    card: "bg-graphite-card",
    primary: "bg-graphite-primary",
    secondary: "bg-graphite-secondary",
  };

  return (
    <AppBarContext.Provider
      value={{
        isScrolled,
        scrollY,
        headerY,
        setCollapseDistance,
        setHeightToHideForSticky,
        setScrollBehavior,
      }}
    >
      <div
        ref={scrollRef}
        className={clsx(
          "h-screen overflow-y-auto",
          backgroundClasses[mainContentColor]
        )}
      >
        {children}
      </div>
    </AppBarContext.Provider>
  );
};

// --- APP BAR ---
const appBarVariants = cva(
  "fixed top-0 z-40 w-full transition-[colors,box-shadow] duration-300 ease-in-out",
  {
    variants: {
      appBarColor: {
        background: "bg-graphite-background text-graphite-foreground",
        card: "bg-graphite-card text-graphite-foreground",
        primary: "bg-graphite-primary text-graphite-primaryForeground",
        secondary: "bg-graphite-secondary text-graphite-secondaryForeground",
      },
      // Add shadow variant
      shadow: {
        none: "shadow-none",
        md: "shadow-sm",
      },
    },
    defaultVariants: {
      appBarColor: "card",
      shadow: "none", // Default to no shadow
    },
  }
);

export interface AppBarProps
  extends Omit<React.ComponentProps<typeof motion.header>, "color">,
    VariantProps<typeof appBarVariants> {
  children?: React.ReactNode;
  startAdornment?: React.ReactNode;
  centerAdornment?: React.ReactNode;
  endAdornments?: React.ReactNode[];
  scrollBehavior?: AppBarScrollBehavior;
  animatedBehavior?: AppBarAnimatedBehavior[];
  animatedColor?: AppBarColor;
  size?: AppBarSize;
  largeHeaderContent?: React.ReactNode;
  smallHeaderContent?: React.ReactNode;
  stickyHideTarget?: StickyHideTarget;
}

const AppBarRoot = React.forwardRef<HTMLElement, AppBarProps>(
  (
    {
      className,
      children,
      appBarColor = "card",
      startAdornment,
      centerAdornment,
      endAdornments = [],
      scrollBehavior = "sticky",
      animatedBehavior = [],
      animatedColor = "secondary",
      size = "md",
      largeHeaderContent,
      smallHeaderContent,
      stickyHideTarget,
      ...props
    },
    ref
  ) => {
    const {
      isScrolled,
      scrollY,
      headerY,
      setCollapseDistance,
      setHeightToHideForSticky,
      setScrollBehavior,
    } = useAppBarContext();

    const mainRowRef = useRef<HTMLDivElement>(null);
    const largeHeaderRef = useRef<HTMLDivElement>(null);

    const [measuredHeights, setMeasuredHeights] = useState({
      mainRow:
        size === "lg"
          ? FALLBACK_LARGE_HEADER_ROW_HEIGHT
          : FALLBACK_NORMAL_HEADER_ROW_HEIGHT,
      largeContent: 0,
    });

    const isCollapsible =
      size === "lg" && !!largeHeaderContent && !!smallHeaderContent;
    const shouldRenderLargeContent = size === "lg" && !!largeHeaderContent;

    useEffect(() => {
      setScrollBehavior(scrollBehavior);
    }, [scrollBehavior, setScrollBehavior]);

    useLayoutEffect(() => {
      const measuredMainRow = mainRowRef.current?.offsetHeight;
      const measuredLargeContent = largeHeaderRef.current?.offsetHeight;
      if (
        (measuredMainRow && measuredMainRow !== measuredHeights.mainRow) ||
        (measuredLargeContent !== undefined &&
          measuredLargeContent !== measuredHeights.largeContent)
      ) {
        setMeasuredHeights({
          mainRow: measuredMainRow || measuredHeights.mainRow,
          largeContent: measuredLargeContent || 0,
        });
      }
    });

    useEffect(() => {
      const { mainRow, largeContent } = measuredHeights;
      const currentCollapseDistance = isCollapsible ? largeContent : 0;
      setCollapseDistance(currentCollapseDistance);
      let heightToHide: number;
      if (isCollapsible) {
        heightToHide = FALLBACK_NORMAL_HEADER_ROW_HEIGHT;
      } else {
        heightToHide = mainRow + largeContent;
      }
      if (stickyHideTarget === "full-appbar" && size === "lg") {
        heightToHide = mainRow + largeContent;
      } else if (stickyHideTarget === "main-row") {
        heightToHide = isCollapsible
          ? FALLBACK_NORMAL_HEADER_ROW_HEIGHT
          : mainRow;
      }
      setHeightToHideForSticky(heightToHide);
    }, [
      measuredHeights,
      isCollapsible,
      size,
      stickyHideTarget,
      setCollapseDistance,
      setHeightToHideForSticky,
    ]);

    // --- REFACTORED ANIMATION LOGIC ---
    const shouldAnimateColor = animatedBehavior.includes("appbar-color");
    const shouldFold = animatedBehavior.includes("fold");
    const shouldAnimateShadow = animatedBehavior.includes("shadow");

    const finalColor =
      shouldAnimateColor && isScrolled ? animatedColor : appBarColor;

    // Determine the shadow state based on scroll and the new behavior prop
    const finalShadow = shouldAnimateShadow && isScrolled ? "md" : "none";

    // New animation for the folding effect
    const animatedBorderRadius = useTransform(
      scrollY,
      [0, FOLD_ANIMATION_DISTANCE],
      [0, FOLD_BORDER_RADIUS],
      { clamp: true }
    );

    // --- (Rest of the animation logic is unchanged) ---
    const collapseAnimDistance = measuredHeights.largeContent;
    const largeRowHeight = measuredHeights.mainRow;
    const totalExpandedHeight = largeRowHeight + collapseAnimDistance;
    const animatedTotalHeight = useTransform(
      scrollY,
      [0, collapseAnimDistance],
      [totalExpandedHeight, FALLBACK_NORMAL_HEADER_ROW_HEIGHT],
      { clamp: true }
    );
    const smoothAnimatedTotalHeight = useSpring(animatedTotalHeight, {
      stiffness: 300,
      damping: 30,
      mass: 0.5,
    });
    const animatedMainRowHeight = useTransform(
      scrollY,
      [0, collapseAnimDistance],
      [largeRowHeight, FALLBACK_NORMAL_HEADER_ROW_HEIGHT],
      { clamp: true }
    );
    const headerRowHeight = isCollapsible
      ? animatedMainRowHeight
      : measuredHeights.mainRow;
    const largeHeaderOpacity = useTransform(
      scrollY,
      [0, collapseAnimDistance * 0.75],
      [1, 0],
      { clamp: true }
    );
    const largeHeaderY = useTransform(
      scrollY,
      [0, collapseAnimDistance],
      [0, -40],
      { clamp: true }
    );
    const titleCrossFadeStart = collapseAnimDistance * 0.4;
    const titleCrossFadeEnd = collapseAnimDistance * 0.9;
    const childrenOpacity = useTransform(
      scrollY,
      [titleCrossFadeStart, titleCrossFadeEnd],
      [1, 0],
      { clamp: true }
    );
    const smallHeaderOpacity = useTransform(
      scrollY,
      [titleCrossFadeStart, titleCrossFadeEnd],
      [0, 1],
      { clamp: true }
    );

    return (
      <motion.header
        ref={ref}
        className={clsx(
          appBarVariants({
            appBarColor: finalColor,
            shadow: finalShadow,
            className,
          }),
          // Add overflow-hidden when folding or collapsing to clip content
          (isCollapsible || shouldFold) && "overflow-hidden"
        )}
        style={{
          y: headerY,
          height: isCollapsible ? smoothAnimatedTotalHeight : undefined,
          borderBottomLeftRadius: shouldFold ? animatedBorderRadius : undefined,
          borderBottomRightRadius: shouldFold
            ? animatedBorderRadius
            : undefined,
        }}
        {...props}
      >
        <motion.div
          ref={mainRowRef}
          className="flex w-full items-center "
          style={{ height: headerRowHeight }}
        >
          {/* ... (inner content is unchanged) ... */}
          <div className="flex flex-1 items-center gap-2 px-4 min-w-0">
            {startAdornment && (
              <div className="flex justify-center items-center min-w-max">
                {startAdornment}
              </div>
            )}
            <div className="min-w-0 relative flex-1">
              <motion.div
                style={{ opacity: isCollapsible ? childrenOpacity : 1 }}
              >
                {children}
              </motion.div>
              {isCollapsible && (
                <motion.div
                  style={{ opacity: smallHeaderOpacity }}
                  className="absolute inset-0 flex items-center"
                >
                  {smallHeaderContent}
                </motion.div>
              )}
            </div>
          </div>
          {centerAdornment && (
            <div className="flex justify-center items-center min-w-max flex-1 ">
              {centerAdornment}
            </div>
          )}
          <div className="flex items-center justify-end gap-1 px-4">
            {endAdornments.map((adornment, index) => (
              <React.Fragment key={index}>{adornment}</React.Fragment>
            ))}
          </div>
        </motion.div>

        {shouldRenderLargeContent && (
          <motion.div
            ref={largeHeaderRef}
            style={{
              opacity: isCollapsible ? largeHeaderOpacity : 1,
              y: isCollapsible ? largeHeaderY : 0,
              pointerEvents: isScrolled && isCollapsible ? "none" : "auto",
            }}
            className="px-4 pb-4"
          >
            {largeHeaderContent}
          </motion.div>
        )}
      </motion.header>
    );
  }
);
AppBarRoot.displayName = "AppBar";

export const AppBar = Object.assign(AppBarRoot, {
  Provider: AppBarProvider,
});
```

**Storybook Stories (`Appbar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  ArrowLeft,
  Menu,
  MoreVertical,
  Paperclip,
  Search,
  User,
} from "lucide-react";
import { IconButton } from "../icon-button"; // Assuming these are in your project
import { Typography } from "../typography"; // Assuming these are in your project
import { AppBar } from "./index";

const meta: Meta<typeof AppBar> = {
  title: "Components/AppBar",
  component: AppBar,
  tags: ["autodocs"],
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "A versatile AppBar that can be sticky, hide on scroll, and expand to a large, collapsible header. It dynamically measures its own height from the DOM to ensure animations are always accurate.",
      },
    },
  },
  argTypes: {
    size: {
      control: "select",
      options: ["md", "lg"],
      description: "Controls the size and collapsing behavior of the AppBar.",
    },
    appBarColor: {
      control: "select",
      options: ["background", "card", "primary", "secondary"],
    },
    scrollBehavior: {
      control: "select",
      options: ["sticky", "conditionally-sticky"],
    },
    animatedBehavior: {
      control: "check",
      options: ["appbar-color", "fold", "shadow"],
    },
    animatedColor: {
      control: "select",
      options: ["background", "card", "primary", "secondary"],
    },
    stickyHideTarget: {
      control: "select",
      options: [undefined, "main-row", "full-appbar"],
      description:
        "Overrides the default behavior for `conditionally-sticky`. Forces the hiding behavior to target either the main row or the full app bar height.",
    },
    children: { control: false },
    largeHeaderContent: { control: false },
    smallHeaderContent: { control: false },
    startAdornment: { control: false },
    centerAdornment: { control: false },
    endAdornments: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof AppBar>;

// Helper component to generate scrollable content
const DummyContent = () => (
  <main className="p-6 pt-4">
    <Typography variant="h3">Scroll Down to See The Effect</Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
      {Array.from({ length: 30 }).map((_, i) => (
        <div key={i} className="h-48 rounded-2xl bg-black/5" />
      ))}
    </div>
  </main>
);

// A smart render function to wrap stories and handle padding
const render = (args: any) => {
  let paddingTop = "pt-[64px]"; // Default for 'md'
  if (args.size === "lg" && args.largeHeaderContent) {
    paddingTop = "pt-[160px]";
  }
  if (args.className?.includes("h-20")) {
    paddingTop = "pt-20";
  }

  return (
    <AppBar.Provider mainContentColor="background">
      <AppBar {...args} />
      <div className={paddingTop}>
        <DummyContent />
      </div>
    </AppBar.Provider>
  );
};

// --- STORIES ---

export const Default: Story = {
  name: "Default (Medium, Sticky)",
  args: {
    size: "md",
    scrollBehavior: "sticky",
    appBarColor: "card",
    children: <Typography variant="h4">Sticky Header</Typography>,
    startAdornment: (
      <IconButton variant="ghost" aria-label="Menu">
        <Menu />
      </IconButton>
    ),
    endAdornments: [
      <IconButton key="user-profile" variant="ghost" aria-label="User Profile">
        <User />
      </IconButton>,
    ],
  },
  render,
};

export const ConditionallySticky: Story = {
  name: "Medium, Hiding on Scroll",
  args: {
    ...Default.args,
    scrollBehavior: "conditionally-sticky",
    children: <Typography variant="h4">Hiding Header</Typography>,
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "With `scrollBehavior` set to `conditionally-sticky`, the AppBar scrolls out of view when scrolling down and reappears when scrolling up.",
      },
    },
  },
};

export const AnimatedColor: Story = {
  name: "Medium, Animated Color",
  args: {
    ...Default.args,
    animatedBehavior: ["appbar-color"],
    appBarColor: "background",
    animatedColor: "card",
    children: <Typography variant="h4">Animated Header</Typography>,
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "With `animatedBehavior` including `appbar-color`, the AppBar transitions to the `animatedColor` when the user scrolls.",
      },
    },
  },
};

export const FoldingOnScroll: Story = {
  name: "Medium, Folding on Scroll",
  args: {
    ...Default.args,
    animatedBehavior: ["fold"],
    children: <Typography variant="h4">Folding Header</Typography>,
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "With `animatedBehavior` including `fold`, the AppBar's bottom corners become rounded as you scroll down, creating a neat 'folding' effect.",
      },
    },
  },
};

export const ShadowOnScroll: Story = {
  name: "Medium, Shadow on Scroll",
  args: {
    ...Default.args,
    animatedBehavior: ["shadow"], // Enable shadow effect
    appBarColor: "background",
    children: <Typography variant="h4">Shadow Header</Typography>,
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "With `animatedBehavior` including `shadow`, the AppBar gains a subtle shadow when the user scrolls, helping it stand out from the content.",
      },
    },
  },
};

export const LargeCollapsing: Story = {
  name: "Large, Fully Collapsible",
  args: {
    size: "lg",
    scrollBehavior: "conditionally-sticky",
    appBarColor: "card",
    startAdornment: (
      <IconButton variant="ghost" aria-label="Back">
        <ArrowLeft />
      </IconButton>
    ),
    endAdornments: [
      <IconButton key="attach" variant="ghost" aria-label="Attach">
        <Paperclip />
      </IconButton>,
      <IconButton key="more" variant="ghost" aria-label="More">
        <MoreVertical />
      </IconButton>,
    ],
    children: (
      <Typography variant="h2" className="truncate font-bold">
        Large Collapsing Title
      </Typography>
    ),
    smallHeaderContent: (
      <Typography variant="h4" className="font-semibold">
        Collapsed Title
      </Typography>
    ),
    largeHeaderContent: (
      <div className="flex items-center gap-2 rounded-full bg-black/5 px-4 py-2">
        <Search className="h-5 w-5 text-gray-500" />
        <input
          type="text"
          placeholder="Search..."
          className="w-full bg-transparent outline-none"
        />
      </div>
    ),
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "**This is the primary `lg` use case.** When `size` is `lg` and *both* `largeHeaderContent` and `smallHeaderContent` are provided, the AppBar becomes fully collapsible. On scroll, it smoothly animates its height, fades out the large content, and cross-fades the titles. The `conditionally-sticky` behavior engages *after* the header has fully collapsed, hiding the remaining small header.",
      },
    },
  },
};

export const LargeStatic: Story = {
  name: "Large, Static (No Collapse)",
  args: {
    ...LargeCollapsing.args,
    smallHeaderContent: undefined,
    children: (
      <Typography variant="h2" className="truncate font-bold">
        Large Static Title
      </Typography>
    ),
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "**This demonstrates the smart default behavior.** When `size` is `lg` but `smallHeaderContent` is omitted, the AppBar **does not collapse**. It remains in its large, expanded state. The `conditionally-sticky` behavior adapts and now hides the *entire visible AppBar* on scroll, since there is no smaller state to transition to.",
      },
    },
  },
};

export const LargeStaticWithOverride: Story = {
  name: "Large, Static with Hide Override",
  args: {
    ...LargeStatic.args,
    stickyHideTarget: "main-row",
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "This builds on the 'Large, Static' story. Even though the AppBar is not collapsible, we can use the `stickyHideTarget='main-row'` prop to force the `conditionally-sticky` behavior to hide *only the main title row*, leaving the `largeHeaderContent` (the search bar) visible at the top.",
      },
    },
  },
};

export const CombinedEffects: Story = {
  name: "Kitchen Sink (All Effects)",
  args: {
    ...LargeCollapsing.args,
    animatedBehavior: ["appbar-color", "fold", "shadow"],
    animatedColor: "secondary",
  },
  render,
  parameters: {
    docs: {
      description: {
        story:
          "A demonstration of all features working in harmony. This `lg` AppBar collapses, hides on scroll, animates its color, folds its corners, and gains a shadow simultaneously.",
      },
    },
  },
};
```


### Component: `avatar`

This section contains the source code for the `avatar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\avatar\AvatarGroup.tsx`)**
```tsx
"use client";

import { clsx } from "clsx";
import React from "react";
import { Avatar, type AvatarProps } from "./index";

export interface AvatarGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  /** The maximum number of avatars to display before showing an overflow count. */
  max?: number;
}

export const AvatarGroup: React.FC<AvatarGroupProps> = ({
  children,
  className,
  max,
  ...props
}) => {
  const childArray = React.Children.toArray(children).filter(
    React.isValidElement
  ) as React.ReactElement<AvatarProps>[];

  const totalAvatars = childArray.length;
  const hasOverflow = max !== undefined && totalAvatars > max;

  const avatarsToShow = hasOverflow ? childArray.slice(0, max) : childArray;
  const overflowCount = totalAvatars - (max || 0);

  const avatarSize = avatarsToShow[0]?.props.size || "md";

  // --- THIS IS THE KEY CHANGE ---
  // We now map avatar sizes to a specific pixel value for the negative margin.
  // This will be used in an inline style object.
  const overlapMargin = {
    xs: "-6px",
    sm: "-10px",
    md: "-14px",
    lg: "-26px",
    xl: "-38px",
  }[avatarSize];
  // --- END OF CHANGE ---

  const hoverEffectClasses =
    "transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:z-50";

  return (
    <div className={clsx("flex items-center", className)} {...props}>
      {avatarsToShow.map((child, index) => {
        // Prepare the style object for each avatar
        const newStyle: React.CSSProperties = {
          ...child.props.style,
          zIndex: index,
        };

        // Apply the negative margin to every avatar EXCEPT the first one
        if (index > 0) {
          newStyle.marginLeft = overlapMargin;
        }

        return React.cloneElement(child, {
          className: clsx(
            child.props.className,
            "ring-2 ring-white dark:ring-graphite-card",
            hoverEffectClasses
          ),
          style: newStyle,
        });
      })}
      {hasOverflow && (
        <Avatar
          variant="count"
          size={avatarSize}
          fallback={`+${overflowCount}`}
          className={clsx(
            "ring-2 ring-white dark:ring-graphite-card",
            hoverEffectClasses
          )}
          // The overflow avatar also gets the negative margin via an inline style
          style={{
            zIndex: max,
            marginLeft: overlapMargin,
          }}
        />
      )}
    </div>
  );
};

AvatarGroup.displayName = "Avatar.Group";
```

**Storybook Stories (`Avatar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Avatar } from "./index";
import { AvatarGroup } from "./AvatarGroup"; // Import AvatarGroup

const meta: Meta<typeof Avatar> = {
  title: "Components/Avatar", // Changed title to be more general
  component: Avatar,
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: "select",
      options: ["xs", "sm", "md", "lg", "xl"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    src: { control: "text" },
    fallback: { control: "text" },
  },
};

export default meta;
type Story = StoryObj<typeof Avatar>;

export const Default: Story = {
  name: "1. Image",
  args: {
    src: "https://i.pravatar.cc/150",
    fallback: "User",
  },
};

export const LoadingSkeleton: Story = {
  name: "2. Loading Skeleton",
  args: {
    // This URL will delay the image load by 2 seconds
    src: "https://www.deelay.me/2000/https://i.pravatar.cc/150?img=1",
    fallback: "User",
    shape: "full",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The Avatar displays a skeleton loader while the image is loading. This is a 2-second delayed image.",
      },
    },
  },
};

export const InitialsFallback: Story = {
  name: "3. Fallback to Initials",
  args: {
    src: "https://broken-url.com/avatar.png",
    fallback: "Alisa Hester",
  },
};

export const GenericFallback: Story = {
  name: "4. Fallback to Icon",
  args: {},
};

export const AllSizes: Story = {
  name: "5. All Sizes",
  render: () => (
    <div className="flex items-center gap-4">
      <Avatar size="xs" fallback="A" />
      <Avatar size="sm" fallback="B" />
      <Avatar size="md" fallback="C" />
      <Avatar size="lg" fallback="D" />
      <Avatar size="xl" fallback="E" />
    </div>
  ),
};

export const AllShapes: Story = {
  name: "6. All Shapes",
  render: () => (
    <div className="flex items-center gap-4">
      <Avatar shape="full" src="https://i.pravatar.cc/150?img=3" />
      <Avatar shape="minimal" src="https://i.pravatar.cc/150?img=4" />
      <Avatar shape="sharp" src="https://i.pravatar.cc/150?img=5" />
    </div>
  ),
};

// --- NEW AVATAR GROUP STORY ---
export const Group: Story = {
  name: "7. Avatar Group",
  render: () => (
    <div className="flex flex-col items-start gap-8">
      <div>
        <h3 className="mb-2 font-semibold">Default Group (md)</h3>
        <AvatarGroup>
          <Avatar src="https://i.pravatar.cc/150?img=1" fallback="A" />
          <Avatar src="https://i.pravatar.cc/150?img=2" fallback="B" />
          <Avatar src="https://i.pravatar.cc/150?img=3" fallback="C" />
          <Avatar src="https://i.pravatar.cc/150?img=4" fallback="D" />
        </AvatarGroup>
      </div>
      <div>
        <h3 className="mb-2 font-semibold">With Max Count (lg)</h3>
        <AvatarGroup max={3}>
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=5"
            fallback="A"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=6"
            fallback="B"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=7"
            fallback="C"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=8"
            fallback="D"
          />
          <Avatar
            size="lg"
            src="https://i.pravatar.cc/150?img=9"
            fallback="E"
          />
        </AvatarGroup>
      </div>
    </div>
  ),
};
```


### Component: `badge`

This section contains the source code for the `badge` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\badge\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import React from "react";

const badgeVariants = cva(
  // Base classes: Increased padding with px-3
  "inline-flex items-center border px-2 py-1 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-graphite-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        primary:
          "border-transparent bg-graphite-primary text-graphite-primaryForeground hover:bg-graphite-primary/80",
        secondary:
          "border-transparent bg-graphite-secondary text-graphite-secondaryForeground hover:bg-graphite-secondary/80",
        // Destructive variant is now a solid, bold red
        destructive:
          "border-transparent bg-red-500 text-graphite-primaryForeground hover:bg-red-600/80",
        outline: "text-graphite-foreground border-graphite-border",
      },
      shape: {
        // Added shape variants
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      variant: "primary",
      shape: "full", // Default to a pill shape
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

export const Badge = React.forwardRef<HTMLDivElement, BadgeProps>(
  ({ className, variant, shape, ...props }, ref) => {
    return (
      <div
        className={badgeVariants({ variant, shape, className })}
        ref={ref}
        {...props}
      />
    );
  }
);

Badge.displayName = "Badge";
```

**Storybook Stories (`Badge.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Badge } from "./index";
import { Button } from "../button";

const meta: Meta<typeof Badge> = {
  title: "Components/Badge",
  component: Badge,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "destructive", "outline"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    children: {
      control: "text",
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    children: "Badge",
    shape: "full",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Badge variant="primary">Primary</Badge>
      <Badge variant="secondary">Secondary</Badge>
      <Badge variant="destructive">Destructive</Badge>
      <Badge variant="outline">Outline</Badge>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Badge variant="primary" shape="full">
        Full
      </Badge>
      <Badge variant="primary" shape="minimal">
        Minimal
      </Badge>
      <Badge variant="primary" shape="sharp">
        Sharp
      </Badge>
    </div>
  ),
};
```


### Component: `bouncy-box`

This section contains the source code for the `bouncy-box` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\bouncy-box\index.tsx`)**
```tsx
import { clsx } from "clsx";
import { motion, type HTMLMotionProps } from "framer-motion";
import React from "react";

// Define the component's props, extending Framer Motion's div props
export interface BouncyBoxProps extends HTMLMotionProps<"div"> {
  /** The amount to scale down on press. 1 is no scale, 0.9 is 90%. */
  scaleAmount?: number;
}

export const BouncyBox = React.forwardRef<HTMLDivElement, BouncyBoxProps>(
  ({ className, children, scaleAmount = 0.95, ...props }, ref) => {
    return (
      <motion.span
        ref={ref}
        className={clsx(
          "cursor-pointer inline-block", // Use inline-flex to wrap content tightly
          className
        )}
        // The magic prop: animates to this state while tapped/clicked
        whileTap={{ scale: scaleAmount }}
        // Configure the spring physics for a nice "bouncy" feel
        transition={{ type: "spring", stiffness: 400, damping: 30 }}
        {...props}
      >
        {children}
      </motion.span>
    );
  }
);

BouncyBox.displayName = "BouncyBox";
```

**Storybook Stories (`bouncy-box.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Button } from "../button"; // Import Button
import { Card } from "../card"; // Import Card
import { Typography } from "../typography"; // Import Typography
import { BouncyBox } from "./index";

const meta: Meta<typeof BouncyBox> = {
  title: "Components/BouncyBox",
  component: BouncyBox,
  tags: ["autodocs"],
  argTypes: {
    scaleAmount: {
      control: { type: "range", min: 0.7, max: 1, step: 0.01 },
    },
  },
  parameters: {
    layout: "centered", // Center the component for better viewing
    docs: {
      description: {
        component:
          "A wrapper component that adds a bouncy, pressable animation to any child element on click. Built with Framer Motion.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    scaleAmount: 0.95,
  },
  render: (args) => (
    <BouncyBox {...args}>
      <Card shape="minimal" className="w-64 cursor-pointer">
        <Typography variant="h4">Click Me!</Typography>
        <Typography variant="p">
          This entire card will bounce when you press down on it.
        </Typography>
      </Card>
    </BouncyBox>
  ),
};

export const WrappingAButton: Story = {
  name: "Wrapping an Interactive Element",
  render: () => (
    <BouncyBox
      onClick={() => alert("Wrapper Clicked!")}
      className="rounded-full"
    >
      <Button
        size="lg"
        onClick={(e) => {
          // Prevent the wrapper's onClick from firing if needed
          e.stopPropagation();
          alert("Button Clicked!");
        }}
      >
        Click the Button
      </Button>
    </BouncyBox>
  ),
};

export const MoreBouncy: Story = {
  name: "More Bouncy",
  args: {
    scaleAmount: 0.85,
  },
  render: (args) => (
    <BouncyBox {...args}>
      <Card shape="full" className="w-48 h-48 flex items-center justify-center">
        <Typography variant="h3">Boing!</Typography>
      </Card>
    </BouncyBox>
  ),
};
```


### Component: `button`

This section contains the source code for the `button` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\button\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import { AnimatePresence, motion } from "framer-motion";
import { Loader2 } from "lucide-react"; // Import Loader from lucide-react
import React from "react";
import useRipple from "use-ripple-hook";

export const buttonVariants = cva(
  "font-semibold cursor-pointer  min-w-max focus:outline-none transition-all duration-300 ease-in-out flex items-center justify-center relative overflow-hidden",
  {
    variants: {
      variant: {
        primary:
          "bg-graphite-primary hover:shadow-md disabled:bg-graphite-primary/70  text-graphite-primaryForeground hover:opacity-90 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring ",
        secondary:
          "bg-graphite-secondary text-graphite-secondaryForeground disabled:bg-graphite-secondary/70 hover:bg-graphite-secondary/80  focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        ghost:
          "bg-transparent text-graphite-foreground disabled:opacity-70 hover:bg-graphite-secondary focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        link: "bg-transparent text-graphite-primary disabled:opacity-70 hover:text-graphite-primary hover:underline !p-1 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
      },
      size: {
        xs: "h-8 px-2 text-xs",
        sm: "h-10 px-4 text-sm",
        md: "h-12 px-6 text-base",
        lg: "h-14 px-8 text-lg",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
      isLoading: {
        true: "cursor-wait",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      shape: "full",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  startIcon?: React.ReactNode;
  endIcon?: React.ReactNode;
  isLoading?: boolean;
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      className,
      variant = "primary",
      size,
      shape,
      children,
      disabled,
      startIcon,
      endIcon,
      isLoading,
      ...props
    },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);
    const rippleColor =
      variant === "primary" ? "rgba(255, 255, 255, 0.4)" : "rgba(0, 0, 0, 0.1)";

    const rippleRef = localRef as React.RefObject<HTMLElement>;
    const [, event] = useRipple({
      ref: rippleRef,
      color: rippleColor,
      duration: 400,
      disabled: disabled || isLoading,
    });

    const loaderSizeMap = {
      xs: "h-4 w-4",
      sm: "h-4 w-4",
      md: "h-5 w-5",
      lg: "h-6 w-6",
    };

    return (
      <button
        className={buttonVariants({
          variant,
          size,
          shape,
          className,
          isLoading,
        })}
        ref={localRef}
        onPointerDown={event}
        disabled={disabled || isLoading}
        {...props}
      >
        <AnimatePresence mode="wait" initial={false}>
          {isLoading ? (
            <motion.div
              key="spinner"
              initial={{ opacity: 0, scale: 0.5 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.5 }}
              transition={{ duration: 0.2 }}
            >
              {/* Use lucide-react Loader with animate-spin */}
              <Loader2
                className={`animate-spin ease-[cubic-bezier(0.95,0.05,0.795,0.035)] ${
                  loaderSizeMap[size || "md"]
                }`}
              />
            </motion.div>
          ) : (
            <motion.span
              key="content"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
              className="relative z-10 flex items-center justify-center"
            >
              {startIcon && (
                <span className="mr-2 flex items-center">{startIcon}</span>
              )}
              {children}
              {endIcon && (
                <span className="ml-2 flex items-center">{endIcon}</span>
              )}
            </motion.span>
          )}
        </AnimatePresence>
      </button>
    );
  }
);

Button.displayName = "Button";
```

**Storybook Stories (`Button.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { ChevronRight, Plus } from "lucide-react";
import { useState } from "react";
import { Button } from "./index";

const meta: Meta<typeof Button> = {
  title: "Components/Button",
  component: Button,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "ghost", "link"],
    },
    size: {
      control: "select",
      options: ["xs", "sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "The border radius of the button.",
    },
    isLoading: { control: "boolean" }, // Added isLoading control
    disabled: { control: "boolean" },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    variant: "primary",
    size: "md",
    shape: "full",
    children: "Primary Button",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary">Primary</Button>
      <Button variant="secondary">Secondary</Button>
      <Button variant="ghost">Ghost</Button>
      <Button variant="link">Link</Button>
    </div>
  ),
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary" size="lg">
        Large
      </Button>
      <Button variant="primary" size="md">
        Medium
      </Button>
      <Button variant="primary" size="sm">
        Small
      </Button>
      <Button variant="primary" size="xs">
        Extra Small
      </Button>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary" shape="full">
        Full
      </Button>
      <Button variant="primary" shape="minimal">
        Minimal
      </Button>
      <Button variant="primary" shape="sharp">
        Sharp
      </Button>
    </div>
  ),
};

export const WithIcons: Story = {
  name: "With Start/End Icons",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button
        variant="primary"
        size="md"
        startIcon={<Plus className="h-5 w-5" />}
      >
        Add Item
      </Button>
      <Button
        variant="secondary"
        size="md"
        shape="minimal"
        endIcon={<ChevronRight className="h-5 w-5" />}
      >
        Continue
      </Button>
    </div>
  ),
};

// --- NEW STORIES FOR LOADING STATE ---

export const Loading: Story = {
  name: "Loading State",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Button variant="primary" isLoading>
        Saving...
      </Button>
      <Button variant="secondary" isLoading>
        Loading...
      </Button>
      <Button variant="ghost" isLoading>
        Processing...
      </Button>
    </div>
  ),
};

export const InteractiveLoading: Story = {
  name: "Interactive Loading",
  render: () => {
    const [isLoading, setIsLoading] = useState(false);
    const handleClick = () => {
      setIsLoading(true);
      setTimeout(() => {
        setIsLoading(false);
      }, 2000);
    };
    return (
      <Button variant="primary" isLoading={isLoading} onClick={handleClick}>
        {isLoading ? "Submitting..." : "Click to Submit"}
      </Button>
    );
  },
};
```


### Component: `button-group`

This section contains the source code for the `button-group` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\button-group\index.tsx`)**
```tsx
import { clsx } from "clsx";
import React from "react";

// Explicitly define the shape type for clarity and type safety
type ButtonShape = "full" | "minimal" | "sharp";

// Define the component's props
interface ButtonGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  shape?: ButtonShape;
}

export const ButtonGroup = ({
  children,
  className,
  shape = "full",
  ...props
}: ButtonGroupProps) => {
  // Map the shape prop to the correct Tailwind CSS classes for the outer corners
  const shapeClasses: Record<ButtonShape, { left: string; right: string }> = {
    full: { left: "rounded-l-full", right: "rounded-r-full" },
    minimal: { left: "rounded-l-lg", right: "rounded-r-lg" },
    sharp: { left: "rounded-l-none", right: "rounded-r-none" },
  };

  const childArray = React.Children.toArray(children);

  return (
    <div
      className={clsx("inline-flex items-center", className)}
      role="group" // Important for accessibility
      {...props}
    >
      {childArray.map((child, index) => {
        if (!React.isValidElement(child)) {
          return child;
        }

        const isFirst = index === 0;
        const isLast = index === childArray.length - 1;

        // --- NEW, ROBUST LOGIC INSPIRED BY SPLITBUTTON ---
        // Determine the precise rounding classes based on the child's position.
        // This is more explicit and reliable than trying to reset with '!rounded-none'.
        let positionClasses = "";
        if (isFirst) {
          // The first child gets the group's left rounding and a sharp right corner.
          positionClasses = clsx(shapeClasses[shape].left, "rounded-r-none");
        } else if (isLast) {
          // The last child gets the group's right rounding and a sharp left corner.
          positionClasses = clsx(shapeClasses[shape].right, "rounded-l-none");
        } else {
          // All middle children are forced to be sharp on both sides.
          positionClasses = "rounded-none";
        }

        const newClassName = clsx(
          child.props.className,
          positionClasses,
          // Create the overlapping border effect for a seamless look.
          !isFirst && "-ml-px",
          // Ensure the focused button renders on top of its siblings.
          "focus:z-10"
        );

        return React.cloneElement(child, {
          ...child.props,
          className: newClassName,
        });
      })}
    </div>
  );
};

ButtonGroup.displayName = "ButtonGroup";
```

**Storybook Stories (`Button-group.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Bold, Italic, Underline } from "lucide-react";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { ButtonGroup } from "./index";

const meta: Meta<typeof ButtonGroup> = {
  title: "Components/ButtonGroup",
  component: ButtonGroup,
  tags: ["autodocs"],
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "Determines the border-radius of the group's outer corners.",
    },
  },
  parameters: {
    docs: {
      description: {
        component:
          "A container for grouping related buttons. It automatically styles its children to create a seamless, 'glued-together' look.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    shape: "full",
  },
  render: (args) => (
    <ButtonGroup {...args}>
      <Button variant="secondary">Left</Button>
      <Button variant="secondary">Middle</Button>
      <Button variant="secondary">Right</Button>
    </ButtonGroup>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-col items-start gap-4">
      <ButtonGroup shape="full">
        <Button variant="secondary">Full</Button>
        <Button variant="secondary">Full</Button>
        <Button variant="secondary">Full</Button>
      </ButtonGroup>
      <ButtonGroup shape="minimal">
        <Button variant="secondary">Minimal</Button>
        <Button variant="secondary">Minimal</Button>
        <Button variant="secondary">Minimal</Button>
      </ButtonGroup>
      <ButtonGroup shape="sharp">
        <Button variant="secondary">Sharp</Button>
        <Button variant="secondary">Sharp</Button>
        <Button variant="secondary">Sharp</Button>
      </ButtonGroup>
    </div>
  ),
};

export const WithIconButtons: Story = {
  name: "With Icon Buttons (Toolbar Example)",
  render: () => (
    <div className="flex flex-col items-start gap-4">
      <p className="text-sm text-gray-500">
        A common use case, like a text editor toolbar.
      </p>
      <ButtonGroup shape="minimal">
        <IconButton variant="primary" size="sm" aria-label="Bold">
          <Bold className="h-4 w-4" />
        </IconButton>
        <IconButton variant="secondary" size="sm" aria-label="Italic">
          <Italic className="h-4 w-4" />
        </IconButton>
        <IconButton variant="secondary" size="sm" aria-label="Underline">
          <Underline className="h-4 w-4" />
        </IconButton>
      </ButtonGroup>
    </div>
  ),
};
```


### Component: `calendar`

This section contains the source code for the `calendar` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\calendar\index.tsx`)**
```tsx
"use client";

import { clsx } from "clsx";
import * as React from "react";
import { DayPicker } from "react-day-picker";
import { buttonVariants } from "../button"; // Your existing button variants
import { iconButtonVariants } from "../icon-button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={clsx("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: clsx(
          buttonVariants({ variant: "ghost", shape: "full" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex justify-center",
        head_cell:
          "text-gray-500 rounded-md w-9 font-normal text-[0.8rem] text-center",
        row: "flex w-full mt-2 justify-center",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-full [&:has([aria-selected].day-outside)]:bg-graphite-secondary/50 [&:has([aria-selected])]:bg-graphite-secondary first:[&:has([aria-selected])]:rounded-l-full last:[&:has([aria-selected])]:rounded-r-full focus-within:relative focus-within:z-20",
        day: clsx(
          iconButtonVariants({ variant: "ghost", shape: "full" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-graphite-primary text-graphite-primaryForeground hover:bg-graphite-primary hover:text-graphite-primaryForeground focus:bg-graphite-primary focus:text-graphite-primaryForeground",
        day_today: "bg-graphite-secondary text-graphite-secondaryForeground",
        day_outside:
          "day-outside text-gray-500 opacity-50 aria-selected:bg-graphite-secondary/50 aria-selected:text-gray-500 aria-selected:opacity-30",
        day_disabled: "text-gray-500 opacity-50",
        day_range_middle:
          "aria-selected:bg-graphite-secondary aria-selected:text-graphite-secondaryForeground",
        day_hidden: "invisible",
        ...classNames,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };
```

**Storybook Stories (`calendar.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { addDays } from "date-fns";
import { useState } from "react";
import type { DateRange } from "react-day-picker";
import { PaginatedCalendar } from "../date-picker/paginated-calendar"; // Adjust the import path as needed
import { Card } from "../card/index";
const meta: Meta<typeof PaginatedCalendar> = {
  title: "Components/PaginatedCalendar",
  component: PaginatedCalendar,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A custom, paginated calendar component with day, month, and year views. It supports both single and range date selection and features swipe and click navigation.",
      },
    },
  },
  argTypes: {
    mode: {
      control: "select",
      options: ["single", "range"],
      description:
        "Determines if a single date or a date range can be selected.",
    },
    value: {
      control: false,
      description: "The currently selected date or date range.",
    },
    onSelect: {
      control: false,
      description: "Callback function triggered when a date is selected.",
    },
  },
};

export default meta;
type Story = StoryObj<typeof PaginatedCalendar>;

// --- STORIES ---

export const SingleDate: Story = {
  name: "1. Single Date Selection",
  args: {
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | DateRange | undefined>(new Date());

    return (
      <Card className="min-w-[320px]">
        <PaginatedCalendar
          {...args}
          value={date}
          onSelect={(newVal) => setDate(newVal)}
        />
      </Card>
    );
  },
};

export const DateRange: Story = {
  name: "2. Date Range Selection",
  args: {
    mode: "range",
  },
  parameters: {
    docs: {
      description: {
        story:
          "In range mode, the first click sets the start date, and the second click sets the end date. Clicking a new date after a range is complete will start a new selection.",
      },
    },
  },
  render: function Render(args) {
    const [range, setRange] = useState<Date | DateRange | undefined>({
      from: new Date(),
      to: addDays(new Date(), 7),
    });

    return (
      <Card className="min-w-[320px]">
        <PaginatedCalendar
          {...args}
          value={range}
          onSelect={(newVal) => setRange(newVal)}
        />
      </Card>
    );
  },
};

export const NoInitialValue: Story = {
  name: "3. No Initial Value",
  args: {
    mode: "single",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The calendar can also be initialized without a pre-selected date.",
      },
    },
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | DateRange | undefined>();

    return (
      <Card className="min-w-[320px]">
        <PaginatedCalendar
          {...args}
          value={date}
          onSelect={(newVal) => setDate(newVal)}
        />
      </Card>
    );
  },
};
```


### Component: `card`

This section contains the source code for the `card` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\card\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import React from "react";

const cardVariants = cva(
  // Base classes: Added transition for smooth color/border changes
  "p-5 shadow-xs transition-colors duration-200",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
        // Selected variant adds a border to indicate its state
        selected: "bg-graphite-card border-2 border-graphite-primary",
      },
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    // Set default variant to primary
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
    },
  }
);

export interface CardProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof cardVariants> {}

export const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, shape, variant, ...props }, ref) => {
    return (
      <div
        className={cardVariants({ shape, variant, className })}
        ref={ref}
        {...props}
      />
    );
  }
);

Card.displayName = "Card";
```

**Storybook Stories (`Card.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Button } from "../button";
import { Typography } from "../typography";
import { Card } from "./index";

const meta: Meta<typeof Card> = {
  title: "Components/Card",
  component: Card,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "selected"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
  },
  render: (args) => (
    <Card {...args} className="max-w-md">
      <Typography variant="h3">This is a Card</Typography>
      <Typography variant="p">
        A card is a flexible container for content. You can place any other
        components inside it.
      </Typography>
    </Card>
  ),
};

// --- NEW STORY TO SHOWCASE VARIANTS ---
export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card variant="primary" shape="minimal">
        <Typography variant="h4">Primary</Typography>
        <Typography variant="p">The default card style.</Typography>
      </Card>
      <Card variant="secondary" shape="minimal">
        <Typography variant="h4">Secondary</Typography>
        <Typography variant="p">For less emphasis.</Typography>
      </Card>
      <Card variant="selected" shape="minimal">
        <Typography variant="h4">Selected</Typography>
        <Typography variant="p">To indicate selection.</Typography>
      </Card>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card shape="full">
        <Typography variant="h4">Full</Typography>
        <Typography variant="p">The default, highly-rounded style.</Typography>
      </Card>
      <Card shape="minimal">
        <Typography variant="h4">Minimal</Typography>
        <Typography variant="p">A more subtle, modern rounding.</Typography>
      </Card>
      <Card shape="sharp">
        <Typography variant="h4">Sharp</Typography>
        <Typography variant="p">No rounding for a blocky look.</Typography>
      </Card>
    </div>
  ),
};

export const Composition: Story = {
  name: "Composition Example",
  render: () => (
    <Card shape="minimal" className="max-w-sm flex flex-col gap-4">
      <div>
        <Typography variant="h3">Upgrade to Pro</Typography>
        <Typography variant="muted">
          Unlock all features and get unlimited access.
        </Typography>
      </div>
      <Typography variant="p">
        Gain access to advanced analytics, priority support, and exclusive
        content by upgrading your plan today.
      </Typography>
      <div className="flex justify-end">
        <Button>Learn More</Button>
      </div>
    </Card>
  ),
};
```


### Component: `checkbox`

This section contains the source code for the `checkbox` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\checkbox\index.tsx`)**
```tsx
import { clsx } from "clsx";
import React from "react";

// Using the exact CheckIcon component you provided.
const CheckIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    {...props}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M4.5 12.75l6 6 9-13.5"
    />
  </svg>
);

export interface CheckboxProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
}

export const Checkbox = React.forwardRef<HTMLInputElement, CheckboxProps>(
  ({ className, id, label, ...props }, ref) => {
    const uniqueId = React.useId();
    const checkboxId = id || uniqueId;

    return (
      <div className="inline-flex items-center">
        {/* Container is now h-6 w-6 to match the design */}
        <div className="relative flex items-center justify-center h-6 w-6">
          <input
            type="checkbox"
            ref={ref}
            id={checkboxId}
            className={clsx(
              "peer h-6 w-6 shrink-0 appearance-none transition-colors duration-200",
              // Changed to rounded-lg for the softer, squircle shape
              "rounded-lg",
              // Unchecked state with a border-2 to match the visual weight
              "border-2 border-graphite-border",
              // Checked state
              "checked:border-graphite-primary checked:bg-graphite-primary",
              // Focus state
              "focus:outline-none focus:ring-2 focus:ring-graphite-ring focus:ring-offset-2",
              // Disabled state
              "disabled:cursor-not-allowed disabled:opacity-50 disabled:checked:bg-graphite-border disabled:checked:border-graphite-border",
              className
            )}
            {...props}
          />
          <CheckIcon
            className={clsx(
              "pointer-events-none absolute h-4 w-4 text-graphite-primaryForeground",
              // Increased stroke weight for better visibility and to match the design
              "stroke-[3.5]",
              // Animation scales the icon in when the peer input is checked
              "transition-transform duration-200 ease-in-out transform scale-0 peer-checked:scale-100"
            )}
          />
        </div>
        {label && (
          <label
            htmlFor={checkboxId}
            className="ml-3 text-sm font-medium text-graphite-foreground select-none"
          >
            {label}
          </label>
        )}
      </div>
    );
  }
);

Checkbox.displayName = "Checkbox";
```

**Storybook Stories (`Checkbox.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { Checkbox } from "./index";

const meta: Meta<typeof Checkbox> = {
  title: "Components/Checkbox",
  component: Checkbox,
  tags: ["autodocs"],
  argTypes: {
    label: { control: "text" },
    checked: { control: "boolean" },
    disabled: { control: "boolean" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    label: "Accept terms and conditions",
  },
};

export const Checked: Story = {
  args: {
    label: "Save my preferences",
    defaultChecked: true, // Use defaultChecked for uncontrolled initial state
  },
};

export const Disabled: Story = {
  name: "Disabled States",
  render: () => (
    <div className="flex flex-col gap-4">
      <Checkbox disabled label="Unchecked and Disabled" />
      <Checkbox disabled defaultChecked label="Checked and Disabled" />
    </div>
  ),
};

export const Interactive: Story = {
  name: "Interactive (Controlled)",
  render: () => {
    const [isChecked, setIsChecked] = useState(false);
    return (
      <div className="flex flex-col gap-2">
        <Checkbox
          checked={isChecked}
          onChange={(e) => setIsChecked(e.target.checked)}
          label="Click me to see the state change"
        />
        <p className="text-sm text-gray-500">
          Current state: {isChecked ? "Checked" : "Unchecked"}
        </p>
      </div>
    );
  },
};

export const WithoutLabel: Story = {
  name: "Without a Label",
  args: {
    "aria-label": "A checkbox without a visible label", // Important for accessibility
  },
};
```


### Component: `chip`

This section contains the source code for the `chip` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\chip\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import React from "react";
import useRipple from "use-ripple-hook";

const chipVariants = cva(
  // Base classes for a fixed height, padding, and pill shape
  "inline-flex items-center justify-center h-10 px-4 rounded-full font-semibold text-sm border-2 transition-colors relative overflow-hidden disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      // The main variant is its selection state
      selected: {
        true: "bg-graphite-primary text-graphite-primaryForeground border border-graphite-primary",
        false:
          "bg-transparent text-graphite-foreground border border-graphite-border hover:bg-graphite-secondary",
      },
    },
    defaultVariants: {
      selected: false,
    },
  }
);

export interface ChipProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof chipVariants> {
  startIcon?: React.ReactNode;
  endIcon?: React.ReactNode;
}

export const Chip = React.forwardRef<HTMLButtonElement, ChipProps>(
  (
    { className, selected, children, disabled, startIcon, endIcon, ...props },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);

    // Ripple color changes based on the selection state
    const rippleColor = selected
      ? "rgba(255, 255, 255, 0.3)"
      : "rgba(0, 0, 0, 0.1)";

    const rippleRef = localRef as React.RefObject<HTMLElement>;
    const [, event] = useRipple({
      ref: rippleRef,
      color: rippleColor,
      duration: 400,
      disabled: disabled,
    });

    return (
      <button
        className={chipVariants({ selected, className })}
        ref={localRef}
        onPointerDown={event}
        disabled={disabled}
        {...props}
      >
        <span className="relative z-10 flex items-center justify-center">
          {startIcon && (
            <span className="mr-2 flex items-center">{startIcon}</span>
          )}
          {children}
          {endIcon && <span className="ml-2 flex items-center">{endIcon}</span>}
        </span>
      </button>
    );
  }
);

Chip.displayName = "Chip";
```

**Storybook Stories (`chip.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Check, X } from "lucide-react";
import { useState } from "react";
import { Chip } from "./index";

const meta: Meta<typeof Chip> = {
  title: "Components/Chip",
  component: Chip,
  tags: ["autodocs"],
  argTypes: {
    selected: {
      control: "boolean",
    },
    disabled: {
      control: "boolean",
    },
    children: {
      control: "text",
    },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    children: "Default Chip",
  },
};

export const Selected: Story = {
  args: {
    children: "Selected Chip",
    selected: true,
  },
};

export const Interactive: Story = {
  name: "Interactive (Toggle)",
  render: (args) => {
    const [isSelected, setIsSelected] = useState(false);
    return (
      <Chip
        {...args}
        selected={isSelected}
        onClick={() => setIsSelected(!isSelected)}
        startIcon={isSelected && <Check className="h-4 w-4" />}
      >
        {isSelected ? "Filter Enabled" : "Enable Filter"}
      </Chip>
    );
  },
};

export const WithIcons: Story = {
  name: "With Start and End Icons",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Chip>
        <span className="font-normal mr-2">Tag:</span>
        React
      </Chip>
      <Chip endIcon={<X className="h-4 w-4" />}>Dismissible</Chip>
    </div>
  ),
};

export const Disabled: Story = {
  name: "Disabled States",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <Chip disabled>Disabled</Chip>
      <Chip selected disabled>
        Selected & Disabled
      </Chip>
    </div>
  ),
};
```


### Component: `date-picker`

This section contains the source code for the `date-picker` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\date-picker\header.tsx`)**
```tsx
import { format } from "date-fns";
import { Pencil } from "lucide-react";
import React from "react";
import type { DateRange } from "react-day-picker";
import { IconButton } from "../icon-button";
import { Typography } from "../typography";

interface DatePickerHeaderProps {
  mode: "single" | "range";
  selectedDate?: Date;
  selectedRange?: DateRange;
  onEditClick: () => void;
}

export const DatePickerHeader = ({
  mode,
  selectedDate,
  selectedRange,
  onEditClick,
}: DatePickerHeaderProps) => {
  const getSingleDateText = () => {
    if (!selectedDate) return "Select date";
    return format(selectedDate, "E, MMM d");
  };

  const getRangeDateText = () => {
    if (!selectedRange?.from) return "Select dates";
    if (selectedRange.from && !selectedRange.to) {
      return format(selectedRange.from, "MMM d");
    }
    if (selectedRange.from && selectedRange.to) {
      return `${format(selectedRange.from, "MMM d")} – ${format(
        selectedRange.to,
        "MMM d"
      )}`;
    }
    return "Select dates";
  };

  return (
    <div className="flex items-center justify-between pt-6 px-0 pb-2">
      <div>
        {mode === "range" && (
          <Typography variant="muted">Depart – Return dates</Typography>
        )}
        <Typography variant="h2" className="!mt-0">
          {mode === "single" ? getSingleDateText() : getRangeDateText()}
        </Typography>
      </div>
      <IconButton
        variant="ghost"
        size="md"
        aria-label="Enter date manually"
        onClick={onEditClick}
      >
        <Pencil className="h-5 w-5" />
      </IconButton>
    </div>
  );
};
```

**Storybook Stories (`Date-picker.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { addDays } from "date-fns";
import React, { useState } from "react";
import type { DateRange } from "react-day-picker";
import { DatePicker } from "./index";

const meta: Meta<typeof DatePicker> = {
  title: "Components/DatePicker",
  component: DatePicker,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A fully custom, MD3-compliant date picker with single/range modes, a spacious paginated calendar, and a manual input mode. It has three variants: `docked` (desktop), `modal`, and `fullscreen` (mobile).",
      },
    },
  },
  argTypes: {
    mode: {
      control: "select",
      options: ["single", "range"],
      description:
        "Determines if a single date or a date range can be selected.",
    },
    variant: {
      control: "select",
      options: ["docked", "modal", "fullscreen"],
      description:
        "Overrides the default responsive behavior to force a specific variant.",
    },
    size: { control: "select", options: ["sm", "md", "lg"] },
    shape: { control: "select", options: ["full", "minimal", "sharp"] },
    label: { control: "text" },
    disabled: { control: "boolean" },
    value: { control: false },
    onChange: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof DatePicker>;

export const Docked: Story = {
  name: "1. Docked (Desktop Default)",
  args: {
    variant: "docked",
    label: "Event Date",
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | undefined>(new Date());
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={date}
          onChange={(val) => setDate(val as Date)}
        />
      </div>
    );
  },
};

export const ModalSingle: Story = {
  name: "2. Modal (Single Date)",
  args: {
    variant: "modal",
    label: "Appointment",
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | undefined>(new Date());
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={date}
          onChange={(val) => setDate(val as Date)}
        />
      </div>
    );
  },
};

export const ModalRange: Story = {
  name: "3. Modal (Date Range)",
  args: {
    variant: "modal",
    label: "Vacation",
    mode: "range",
  },
  render: function Render(args) {
    const [range, setRange] = useState<DateRange | undefined>({
      from: new Date(),
      to: addDays(new Date(), 5),
    });
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={range}
          onChange={(val) => setRange(val as DateRange)}
        />
      </div>
    );
  },
};

export const Fullscreen: Story = {
  name: "4. Fullscreen (Mobile Default)",
  args: {
    variant: "fullscreen",
    label: "Booking",
    mode: "range",
  },
  parameters: { viewport: { defaultViewport: "mobile1" } },
  render: function Render(args) {
    const [range, setRange] = useState<DateRange | undefined>({
      from: new Date(),
      to: addDays(new Date(), 5),
    });
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={range}
          onChange={(val) => setRange(val as DateRange)}
        />
      </div>
    );
  },
};

export const InputMode: Story = {
  name: "5. Manual Input Mode",
  args: {
    variant: "modal",
    label: "Date of Birth",
    mode: "single",
  },
  render: function Render(args) {
    const [date, setDate] = useState<Date | undefined>(new Date("1990-01-01"));
    return (
      <div className="w-80">
        <DatePicker
          {...args}
          value={date}
          onChange={(val) => setDate(val as Date)}
        />
      </div>
    );
  },
  parameters: {
    docs: {
      description: {
        story:
          "Click the pencil icon in the modal to switch to the manual text input view.",
      },
    },
  },
};
```


### Component: `dialog`

This section contains the source code for the `dialog` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\dialog\index.tsx`)**
```tsx
// src/components/dialog/index.tsx
import { clsx } from "clsx";
import FocusTrap from "focus-trap-react";
import { AnimatePresence, motion, type Variants } from "motion/react";
import React, {
  createContext,
  useContext,
  useEffect,
  useId,
  useState,
} from "react";
import ReactDOM from "react-dom";
import { Card, type CardProps } from "../card";
import { Typography } from "../typography";

// --- CONTEXT and PORTAL (No Changes) ---
type DialogVariant = "basic" | "fullscreen";
interface DialogContextProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  setTriggerRef: (node: HTMLElement | null) => void;
  titleId: string;
  descriptionId: string;
  variant: DialogVariant;
}
const DialogContext = createContext<DialogContextProps | null>(null);
const useDialogContext = () => {
  const context = useContext(DialogContext);
  if (!context) {
    throw new Error("Dialog components must be used within a <Dialog>");
  }
  return context;
};
const Portal: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);
  return mounted ? ReactDOM.createPortal(children, document.body) : null;
};

// --- ROOT Component (No Changes) ---
export interface DialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  children: React.ReactNode;
  variant?: DialogVariant;
}
const Dialog: React.FC<DialogProps> = ({
  open,
  onOpenChange,
  children,
  variant = "basic",
}) => {
  const [triggerRef, setTriggerRef] = useState<HTMLElement | null>(null);
  const titleId = useId();
  const descriptionId = useId();
  return (
    <DialogContext.Provider
      value={{
        open,
        onOpenChange,
        setTriggerRef,
        titleId,
        descriptionId,
        variant,
      }}
    >
      {children}
    </DialogContext.Provider>
  );
};

// --- TRIGGER (No Changes) ---
interface DialogTriggerProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}
const DialogTrigger = React.forwardRef<HTMLButtonElement, DialogTriggerProps>(
  ({ children, asChild = false, onClick, ...props }, ref) => {
    const { onOpenChange, setTriggerRef } = useDialogContext();
    const handleRef = (node: HTMLButtonElement | null) => {
      setTriggerRef(node);
      if (typeof ref === "function") ref(node);
      else if (ref) ref.current = node;
    };
    const triggerProps = {
      ...props,
      ref: handleRef,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        onOpenChange(true);
        onClick?.(e);
      },
    };
    if (asChild && React.isValidElement(children)) {
      return React.cloneElement(children, triggerProps);
    }
    return <button {...triggerProps}>{children}</button>;
  }
);
DialogTrigger.displayName = "DialogTrigger";

// --- NATIVE iOS-STYLE ANIMATION VARIANTS ---
// iOS modal presentation uses a subtle scale with spring physics
const basicDialogVariants: Variants = {
  hidden: {
    opacity: 0,
    scale: 0.92,
  },
  visible: {
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.3,
      ease: [0.2, 0, 0, 1.1], // Material Design "Emphasized" curve
    },
  },
  exit: {
    opacity: 0,
    scale: 0.95,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1], // Material Design "Accelerate" curve
    },
  },
};

// Material You fullscreen dialog - slides up from bottom with deceleration
const fullscreenDialogVariants: Variants = {
  hidden: {
    y: "100%", // Start completely off-screen
    opacity: 0, // Material You doesn't fade the dialog itself
  },
  visible: {
    y: "0%",
    opacity: 1,

    transition: {
      duration: 0.35, // Material You standard duration
      ease: [0.2, 0.7, 0.1, 1], // Material You emphasized decelerate
    },
  },
  exit: {
    y: "100%",
    opacity: 0.2, // Keep opaque during exit
    transition: {
      duration: 0.2, // Slightly faster exit
      ease: [0.2, 0.2, 0.5, 1], // Material You emphasized decelerate
    },
  },
};

// iOS backdrop - quick fade
const iosBackdropVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      duration: 0.25,
      ease: [0.25, 0.46, 0.45, 0.94], // iOS ease curve
    },
  },
  exit: {
    opacity: 0,
    transition: {
      duration: 0.2,
      ease: [0.25, 0.46, 0.45, 0.94],
    },
  },
};

// Material You backdrop - slower, more pronounced fade
const materialBackdropVariants: Variants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      duration: 0.25,
      ease: [0.4, 0, 0.2, 1], // Material You standard
    },
  },
  exit: {
    opacity: 0,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1],
    },
  },
};

// Content animation for fullscreen - delayed appearance
const materialContentVariants: Variants = {
  hidden: {
    opacity: 0,
    y: 8, // Slight upward movement
  },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.25,
      delay: 0.1, // Delay for staggered effect
      ease: [0.4, 0, 0.2, 1],
    },
  },
};

// --- CONTENT (ENHANCED WITH NATIVE TRANSITIONS) ---
export interface DialogContentProps
  extends React.HTMLAttributes<HTMLDivElement> {
  shape?: CardProps["shape"];
}
const DialogContent = React.forwardRef<HTMLDivElement, DialogContentProps>(
  ({ className, children, shape = "minimal", ...props }, ref) => {
    const { open, onOpenChange, titleId, descriptionId, variant } =
      useDialogContext();

    useEffect(() => {
      if (open) {
        if (variant === "basic") {
          document.body.style.overflow = "hidden";
        }
        if (variant === "fullscreen") {
          document.body.style.overflow = "hidden";
          document.body.style.overscrollBehavior = "none";
          // Material You doesn't fix position, just prevents scroll
        }
      }
      return () => {
        document.body.style.overflow = "";
        document.body.style.overscrollBehavior = "";
        document.body.style.position = "";
        document.body.style.width = "";
      };
    }, [open, variant]);

    const isFullscreen = variant === "fullscreen";
    const backdropVariants = isFullscreen
      ? materialBackdropVariants
      : iosBackdropVariants;

    return (
      <Portal>
        <AnimatePresence mode="wait">
          {open && (
            <FocusTrap
              active={open}
              focusTrapOptions={{
                onDeactivate: () => onOpenChange(false),
                escapeDeactivates: true,
                allowOutsideClick: true,
              }}
            >
              <div
                ref={ref}
                className={clsx(
                  "fixed inset-0 z-50 flex",
                  !isFullscreen && "items-center justify-center p-4 sm:p-8",
                  isFullscreen &&
                    "items-end sm:items-center sm:justify-center sm:p-8"
                )}
                {...props}
              >
                {/* Backdrop */}
                <motion.div
                  initial="hidden"
                  animate="visible"
                  exit="exit"
                  variants={backdropVariants}
                  className={clsx(
                    "absolute inset-0",
                    // Material You uses lighter scrim
                    isFullscreen ? "bg-black/32" : "bg-black/50"
                  )}
                  onClick={() => onOpenChange(false)}
                  style={{ willChange: "opacity" }}
                />

                {/* Dialog */}
                <motion.div
                  role="dialog"
                  aria-modal="true"
                  aria-labelledby={titleId}
                  aria-describedby={descriptionId}
                  variants={
                    isFullscreen
                      ? fullscreenDialogVariants
                      : basicDialogVariants
                  }
                  initial="hidden"
                  animate="visible"
                  exit="exit"
                  className={clsx(
                    "relative z-10 flex flex-col",
                    isFullscreen
                      ? [
                          "w-full bg-white shadow-2xl",
                          // Material You fullscreen on mobile, dialog on desktop
                          "h-full sm:h-auto sm:max-h-[90vh] sm:w-full sm:max-w-2xl",
                          "sm:rounded-3xl", // Material You large corner radius
                          "overflow-hidden",
                        ]
                      : "w-full max-w-lg",
                    className
                  )}
                  style={{
                    willChange: "transform, opacity",
                    backfaceVisibility: "hidden",
                    transform: "translate3d(0, 0, 0)",
                  }}
                >
                  {isFullscreen ? (
                    <motion.div
                      className="flex h-full flex-col sm:h-auto"
                      initial="hidden"
                      animate="visible"
                      variants={materialContentVariants}
                      style={{
                        willChange: "opacity",
                        transform: "translate3d(0, 0, 0)",
                      }}
                    >
                      {React.Children.map(children, (child, index) => {
                        const isLastChild =
                          index === React.Children.count(children) - 1;
                        const isHeader =
                          React.isValidElement(child) &&
                          child.type === DialogHeader;
                        const isFooter =
                          React.isValidElement(child) &&
                          child.type === DialogFooter;

                        return (
                          <div
                            key={index}
                            className={clsx(
                              "flex-shrink-0",
                              !isHeader &&
                                !isFooter &&
                                isLastChild &&
                                "flex-1 overflow-y-auto",
                              !isHeader &&
                                !isFooter &&
                                !isLastChild &&
                                "flex-1 flex flex-col"
                            )}
                            style={{
                              ...(!isHeader &&
                                !isFooter &&
                                isLastChild && {
                                  WebkitOverflowScrolling: "touch",
                                  overscrollBehavior: "contain",
                                }),
                            }}
                          >
                            {child}
                          </div>
                        );
                      })}
                    </motion.div>
                  ) : (
                    <Card
                      shape={shape}
                      className="relative w-full p-8 shadow-2xl"
                    >
                      {children}
                    </Card>
                  )}
                </motion.div>
              </div>
            </FocusTrap>
          )}
        </AnimatePresence>
      </Portal>
    );
  }
);
DialogContent.displayName = "DialogContent";

// --- CLOSE and HELPER Components (Enhanced Material You styling) ---
interface DialogCloseProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  asChild?: boolean;
}
const DialogClose = React.forwardRef<HTMLButtonElement, DialogCloseProps>(
  ({ children, asChild = false, onClick, ...props }, ref) => {
    const { onOpenChange } = useDialogContext();
    const closeProps = {
      ...props,
      ref,
      onClick: (e: React.MouseEvent<HTMLButtonElement>) => {
        onOpenChange(false);
        onClick?.(e);
      },
    };
    if (asChild && React.isValidElement(children)) {
      return React.cloneElement(children, closeProps);
    }
    return <button {...closeProps}>{children}</button>;
  }
);
DialogClose.displayName = "DialogClose";

const DialogHeader = (props: React.HTMLAttributes<HTMLDivElement>) => {
  const { variant } = useDialogContext();
  return (
    <div
      className={clsx(
        variant === "basic" &&
          "flex flex-col space-y-1.5 text-center sm:text-left",
        variant === "fullscreen" && [
          "flex flex-shrink-0 flex-row items-center justify-between",
          // Material You header styling
          "px-6 py-4 sm:px-8 sm:py-6",
          "bg-white",
          "border-b border-gray-200/60",
        ],
        props.className
      )}
      style={{
        ...(variant === "fullscreen" && {
          willChange: "transform",
          transform: "translate3d(0, 0, 0)",
        }),
      }}
      {...props}
    />
  );
};
DialogHeader.displayName = "DialogHeader";

const DialogFooter = (props: React.HTMLAttributes<HTMLDivElement>) => {
  const { variant } = useDialogContext();
  return (
    <div
      className={clsx(
        variant === "basic" && "mt-6 flex gap-2 sm:justify-end",
        variant === "fullscreen" && [
          "flex flex-shrink-0 flex-row justify-end gap-3",
          // Material You footer styling
          "px-6 py-4 sm:px-8 sm:py-6",
          "bg-white",
          "border-t border-gray-200/60",
        ],
        props.className
      )}
      style={{
        ...(variant === "fullscreen" && {
          willChange: "transform",
          transform: "translate3d(0, 0, 0)",
        }),
      }}
      {...props}
    />
  );
};
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  HTMLHeadingElement,
  React.HTMLAttributes<HTMLHeadingElement>
>((props, ref) => {
  const { titleId, variant } = useDialogContext();
  return (
    <h2
      ref={ref}
      id={titleId}
      className={clsx(
        "font-semibold tracking-tight",
        // Material You uses larger titles in fullscreen
        variant === "fullscreen" ? "text-2xl sm:text-3xl" : "text-xl"
      )}
      {...props}
    />
  );
});
DialogTitle.displayName = "DialogTitle";

const DialogDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>((props, ref) => {
  const { descriptionId } = useDialogContext();
  return <Typography variant="muted" ref={ref} id={descriptionId} {...props} />;
});
DialogDescription.displayName = "DialogDescription";

// --- Enhanced Scrollable Content Area ---
const DialogBody = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>((props, ref) => {
  const { variant } = useDialogContext();
  return (
    <div
      ref={ref}
      className={clsx(
        variant === "fullscreen" &&
          "flex-1 overflow-y-auto px-6 py-4 sm:px-8 sm:py-6",
        variant === "basic" && "flex-1",
        props.className
      )}
      style={{
        ...(variant === "fullscreen" && {
          WebkitOverflowScrolling: "touch",
          overscrollBehavior: "contain",
          willChange: "scroll-position",
          transform: "translate3d(0, 0, 0)",
        }),
      }}
      {...props}
    />
  );
});
DialogBody.displayName = "DialogBody";

// --- EXPORTS ---
export {
  Dialog,
  DialogBody,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
};
```

**Storybook Stories (`Dialog.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { X } from "lucide-react";
import { useState } from "react";
// Import the AppBar component
import { AppBar } from "../appbar";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { Input } from "../input";
import { Typography } from "../typography";
import {
  Dialog,
  DialogBody,
  DialogClose,
  DialogContent,
  type DialogContentProps,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  type DialogProps,
  DialogTitle,
  DialogTrigger,
} from "./index";

// Combined type for story controls
type StoryComponentProps = DialogProps & Pick<DialogContentProps, "shape">;

const meta: Meta<StoryComponentProps> = {
  title: "Components/Dialog",
  component: Dialog,
  tags: ["autodocs"],
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "A fully accessible, custom-built dialog component with support for basic and fullscreen variants.",
      },
    },
  },
  argTypes: {
    variant: {
      control: "select",
      options: ["basic", "fullscreen"],
      description: "Determines the dialog's appearance and animation.",
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "Controls the border-radius of the basic dialog card.",
      table: { category: "DialogContent Props" },
      if: { arg: "variant", eq: "basic" },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Basic: Story = {
  name: "Basic Dialog",
  args: {
    variant: "basic",
    shape: "minimal",
  },
  parameters: {
    layout: "centered",
  },
  render: (args) => {
    const [isOpen, setIsOpen] = useState(false);
    return (
      <Dialog open={isOpen} onOpenChange={setIsOpen} variant={args.variant}>
        <DialogTrigger asChild>
          <Button>Open Basic Dialog</Button>
        </DialogTrigger>
        <DialogContent shape={args.shape}>
          <DialogHeader>
            <DialogTitle>Basic Dialog Title</DialogTitle>
            <DialogDescription>
              This is a standard modal dialog.
            </DialogDescription>
          </DialogHeader>
          <div className="py-4">
            <Typography variant="p">
              It floats in the center and has a scale/fade animation.
            </Typography>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="secondary">Cancel</Button>
            </DialogClose>
            <Button>Confirm</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  },
};

export const FullScreen: Story = {
  name: "Full-Screen Dialog with AppBar",
  args: {
    variant: "fullscreen",
  },
  parameters: {
    viewport: {
      defaultViewport: "mobile1",
    },
    docs: {
      description: {
        story:
          "The fullscreen variant integrated with the collapsible AppBar. The `AppBar.Provider` wraps the content inside the `DialogContent` to manage the scroll state, enabling animations and sticky behavior.",
      },
    },
  },
  render: (args) => {
    const [isOpen, setIsOpen] = useState(false);
    return (
      <div className="h-screen w-screen bg-gray-100 p-4">
        <Dialog open={isOpen} onOpenChange={setIsOpen} variant={args.variant}>
          <DialogTrigger asChild>
            <Button>Open Full-Screen Dialog</Button>
          </DialogTrigger>
          <DialogContent>
            {/*
              1. The AppBar.Provider creates the scroll container for the Dialog.
                 It tracks scroll events and provides them to the AppBar component.
            */}
            <AppBar.Provider>
              {/*
                2. The AppBar replaces the simple DialogHeader. It's configured
                   to be large, collapsible, and conditionally sticky.
              */}
              <AppBar
                size="md"
                scrollBehavior="sticky"
                startAdornment={
                  <DialogClose asChild>
                    <IconButton variant="ghost" shape="full">
                      <X className="h-5 w-5" />
                    </IconButton>
                  </DialogClose>
                }
                animatedBehavior={["appbar-color"]}
                animatedColor="background"
                endAdornments={[
                  <Button key="save" size={"sm"} variant="secondary">
                    Save
                  </Button>,
                ]}
              >
                <Typography variant="h4" className="truncate ">
                  Create New Event
                </Typography>
              </AppBar>

              {/*
                3. The DialogBody contains the main scrollable content.
                   IMPORTANT: It needs top padding equal to the expanded height of the AppBar
                   to prevent content from being hidden underneath it initially.
                   Large row (96px) + Large header content (h2, ~52px) = ~148px.
              */}
              <DialogBody className="pt-[100px] px-4 pb-8">
                <div className="grid gap-6">
                  <Input label="Event name" placeholder="Team Sync" />
                  <Input label="Location" placeholder="Conference Room 4" />
                  <Typography variant="p">
                    Scroll down to see the AppBar collapse and hide...
                  </Typography>
                  <div className="h-96 rounded-lg border-2 border-dashed border-gray-200 bg-gray-50" />
                  <div className="h-96 rounded-lg border-2 border-dashed border-gray-200 bg-gray-50" />
                  <Typography variant="p" className="text-center">
                    End of content.
                  </Typography>
                </div>
              </DialogBody>
            </AppBar.Provider>
          </DialogContent>
        </Dialog>
      </div>
    );
  },
};

export const Router: Story = {
  name: "Full-Screen Dialog with AppBar",
  args: {
    variant: "fullscreen",
  },
  parameters: {
    viewport: {
      defaultViewport: "mobile1",
    },
    docs: {
      description: {
        story:
          "The fullscreen variant integrated with the collapsible AppBar. The `AppBar.Provider` wraps the content inside the `DialogContent` to manage the scroll state, enabling animations and sticky behavior.",
      },
    },
  },
  render: (args) => {
    const [isOpen, setIsOpen] = useState(false);
    return (
      <div className="h-screen w-screen bg-gray-100 p-4">
        <Dialog open={isOpen} onOpenChange={setIsOpen} variant={args.variant}>
          <DialogTrigger asChild>
            <Button>Open Full-Screen Dialog</Button>
          </DialogTrigger>
          <DialogContent>
            {/*
              1. The AppBar.Provider creates the scroll container for the Dialog.
                 It tracks scroll events and provides them to the AppBar component.
            */}
            <AppBar.Provider>
              {/*
                2. The AppBar replaces the simple DialogHeader. It's configured
                   to be large, collapsible, and conditionally sticky.
              */}
              <AppBar
                size="md"
                scrollBehavior="sticky"
                startAdornment={
                  <DialogClose asChild>
                    <IconButton variant="ghost" shape="full">
                      <X className="h-5 w-5" />
                    </IconButton>
                  </DialogClose>
                }
                animatedBehavior={["appbar-color"]}
                animatedColor="background"
                endAdornments={[
                  <Button key="save" size={"sm"} variant="secondary">
                    Save
                  </Button>,
                ]}
              >
                <Typography variant="h4" className="truncate ">
                  Create New Event
                </Typography>
              </AppBar>

              {/*
                3. The DialogBody contains the main scrollable content.
                   IMPORTANT: It needs top padding equal to the expanded height of the AppBar
                   to prevent content from being hidden underneath it initially.
                   Large row (96px) + Large header content (h2, ~52px) = ~148px.
              */}
              <DialogBody className="pt-[100px] px-4 pb-8">
                <div className="grid gap-6">
                  <Input label="Event name" placeholder="Team Sync" />
                  <Input label="Location" placeholder="Conference Room 4" />
                  <Typography variant="p">
                    Scroll down to see the AppBar collapse and hide...
                  </Typography>
                  <div className="h-96 rounded-lg border-2 border-dashed border-gray-200 bg-gray-50" />
                  <div className="h-96 rounded-lg border-2 border-dashed border-gray-200 bg-gray-50" />
                  <Typography variant="p" className="text-center">
                    End of content.
                  </Typography>
                </div>
              </DialogBody>
            </AppBar.Provider>
          </DialogContent>
        </Dialog>
      </div>
    );
  },
};
```


### Component: `dropdown-menu`

This section contains the source code for the `dropdown-menu` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\dropdown-menu\index.tsx`)**
```tsx
"use client";

import * as RadixDropdownMenu from "@radix-ui/react-dropdown-menu";
import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import { Check, ChevronRight, Circle } from "lucide-react";
import React, { createContext, useContext } from "react";
import useRipple from "use-ripple-hook";

type DropdownMenuShape = "full" | "minimal" | "sharp";

// --- Context to pass shape down the tree ---
interface DropdownMenuContextProps {
  shape: DropdownMenuShape;
}

const DropdownMenuContext = createContext<DropdownMenuContextProps>({
  shape: "minimal",
});

const useDropdownMenuContext = () => useContext(DropdownMenuContext);

// --- Root Component (Wrapped to provide context) ---
interface DropdownMenuProps extends RadixDropdownMenu.DropdownMenuProps {
  shape?: DropdownMenuShape;
}

const DropdownMenu: React.FC<DropdownMenuProps> = ({
  shape = "minimal",
  ...props
}) => {
  return (
    <DropdownMenuContext.Provider value={{ shape }}>
      <RadixDropdownMenu.Root {...props} />
    </DropdownMenuContext.Provider>
  );
};

const DropdownMenuTrigger = RadixDropdownMenu.Trigger;
const DropdownMenuGroup = RadixDropdownMenu.Group;
const DropdownMenuPortal = RadixDropdownMenu.Portal;
const DropdownMenuSub = RadixDropdownMenu.Sub;
const DropdownMenuRadioGroup = RadixDropdownMenu.RadioGroup;

// --- CVA for Content Components ---
const contentVariants = cva(
  [
    "z-50 min-w-[12rem] max-h-[var(--radix-dropdown-menu-content-available-height)] overflow-y-auto overflow-x-hidden",
    "border border-graphite-border bg-graphite-card p-1.5",
    "shadow-md",
  ],
  {
    variants: {
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      shape: "minimal",
    },
  }
);

// --- Enhanced Animated Content Container ---
const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Content>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Content>
>(({ className, sideOffset = 8, ...props }, ref) => {
  const { shape } = useDropdownMenuContext();
  return (
    <RadixDropdownMenu.Portal>
      <RadixDropdownMenu.Content
        ref={ref}
        sideOffset={sideOffset}
        className={clsx(
          contentVariants({ shape }),
          "data-[state=open]:animate-menu-enter",
          "data-[state=closed]:animate-menu-exit",
          "data-[side=top]:origin-bottom",
          "data-[side=bottom]:origin-top",
          "data-[side=left]:origin-right",
          "data-[side=right]:origin-left",
          className
        )}
        {...props}
      />
    </RadixDropdownMenu.Portal>
  );
});
DropdownMenuContent.displayName = RadixDropdownMenu.Content.displayName;

// --- Enhanced Menu Item (Restored Original Styles) ---
const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Item>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.Item
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center gap-2 rounded-lg px-3 py-2.5 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        "[&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    />
  );
});
DropdownMenuItem.displayName = RadixDropdownMenu.Item.displayName;

// --- Enhanced Checkbox Item (Restored Original Styles) ---
const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.CheckboxItem>
>(({ className, children, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.CheckboxItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center rounded-lg py-2.5 pl-8 pr-3 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixDropdownMenu.ItemIndicator>
          <Check className="h-4 w-4 animate-check-in" />
        </RadixDropdownMenu.ItemIndicator>
      </span>
      {children}
    </RadixDropdownMenu.CheckboxItem>
  );
});
DropdownMenuCheckboxItem.displayName =
  RadixDropdownMenu.CheckboxItem.displayName;

// --- Enhanced Radio Item (Restored Original Styles) ---
const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.RadioItem>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.RadioItem>
>(({ className, children, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.RadioItem
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center rounded-lg py-2.5 pl-8 pr-3 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "data-[disabled]:pointer-events-none data-[disabled]:opacity-38",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex h-4 w-4 items-center justify-center">
        <RadixDropdownMenu.ItemIndicator>
          <Circle className="h-2 w-2 fill-current animate-check-in" />
        </RadixDropdownMenu.ItemIndicator>
      </span>
      {children}
    </RadixDropdownMenu.RadioItem>
  );
});
DropdownMenuRadioItem.displayName = RadixDropdownMenu.RadioItem.displayName;

// --- Enhanced Sub-Menu Trigger (Restored Original Styles) ---
const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, children, inset, ...props }, ref) => {
  // MODIFICATION: Get shape from context
  const { shape } = useDropdownMenuContext();
  const localRef = React.useRef<HTMLDivElement>(null);
  const [ripple, event] = useRipple({
    ref: localRef,
    color: "rgba(128, 128, 128, 0.1)",
    duration: 400,
  });
  React.useImperativeHandle(ref, () => localRef.current!);

  return (
    <RadixDropdownMenu.SubTrigger
      ref={localRef}
      onPointerDown={event}
      className={clsx(
        // ORIGINAL STYLES ARE PRESERVED
        "relative flex cursor-pointer select-none items-center gap-2 rounded-lg px-3 py-2.5 text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-[cubic-bezier(0.2,0,0,1)]",
        "hover:bg-graphite-secondary/60 focus:bg-graphite-secondary",
        "data-[state=open]:bg-graphite-secondary data-[highlighted]:bg-graphite-secondary",
        "focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-graphite-foreground/20",
        "[&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        inset && "pl-8",
        // MODIFICATION: Add logic to override radius only when needed
        shape === "sharp" && "!rounded-none",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRight className="ml-auto h-4 w-4 transition-transform duration-200 ease-[cubic-bezier(0.2,0,0,1)] group-data-[state=open]:rotate-90" />
    </RadixDropdownMenu.SubTrigger>
  );
});
DropdownMenuSubTrigger.displayName = RadixDropdownMenu.SubTrigger.displayName;

// --- Enhanced Sub-Menu Content ---
const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.SubContent>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.SubContent>
>(({ className, ...props }, ref) => {
  const { shape } = useDropdownMenuContext();
  return (
    <RadixDropdownMenu.SubContent
      ref={ref}
      className={clsx(
        contentVariants({ shape }),
        "data-[state=open]:data-[side=right]:animate-submenu-enter-right",
        "data-[state=closed]:data-[side=right]:animate-submenu-exit-right",
        "data-[state=open]:data-[side=left]:animate-submenu-enter-left",
        "data-[state=closed]:data-[side=left]:animate-submenu-exit-left",
        "data-[state=open]:data-[side=top]:animate-menu-enter",
        "data-[state=closed]:data-[side=top]:animate-menu-exit",
        "data-[state=open]:data-[side=bottom]:animate-menu-enter",
        "data-[state=closed]:data-[side=bottom]:animate-menu-exit",
        className
      )}
      {...props}
    />
  );
});
DropdownMenuSubContent.displayName = RadixDropdownMenu.SubContent.displayName;

// --- Other Components (Unchanged) ---
const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Label>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <RadixDropdownMenu.Label
    ref={ref}
    className={clsx(
      "px-3 py-2 text-xs font-medium text-graphite-foreground/70 tracking-wide",
      inset && "pl-8",
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = RadixDropdownMenu.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof RadixDropdownMenu.Separator>,
  React.ComponentPropsWithoutRef<typeof RadixDropdownMenu.Separator>
>(({ className, ...props }, ref) => (
  <RadixDropdownMenu.Separator
    ref={ref}
    className={clsx("-mx-1 my-1.5 h-px bg-graphite-border/60", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = RadixDropdownMenu.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={clsx(
        "ml-auto text-xs font-mono tracking-wider text-graphite-foreground/50",
        className
      )}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};
```

**Storybook Stories (`DropdownMenu.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Cloud,
  CreditCard,
  LifeBuoy,
  LogOut,
  Mail,
  MessageSquare,
  Plus,
  PlusCircle,
  Settings,
  User,
  UserPlus,
  Users,
} from "lucide-react";
import { useState } from "react";
import { Button } from "../button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "./index";

const meta: Meta<typeof DropdownMenu> = {
  title: "Components/DropdownMenu",
  component: DropdownMenu,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
  },
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
};

export default meta;
type Story = StoryObj<typeof DropdownMenu>;

export const Default: Story = {
  name: "1. Basic Usage",
  args: {
    shape: "minimal",
  },
  render: (args) => (
    <DropdownMenu {...args}>
      <DropdownMenuTrigger asChild>
        <Button>Open Menu</Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent>
        <DropdownMenuItem>
          <User className="mr-2 h-4 w-4" />
          <span>Profile</span>
          <DropdownMenuShortcut>⇧⌘P</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <CreditCard className="mr-2 h-4 w-4" />
          <span>Billing</span>
          <DropdownMenuShortcut>⌘B</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <Settings className="mr-2 h-4 w-4" />
          <span>Settings</span>
          <DropdownMenuShortcut>⌘S</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem disabled>
          <Cloud className="mr-2 h-4 w-4" />
          <span>API (Disabled)</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
          <DropdownMenuShortcut>⇧⌘Q</DropdownMenuShortcut>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};

// New story to showcase shapes
export const AllShapes: Story = {
  name: "2. All Shapes",
  render: () => (
    <div className="flex items-center gap-4">
      <DropdownMenu shape="full">
        <DropdownMenuTrigger asChild>
          <Button>Full</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem>Profile</DropdownMenuItem>
          <DropdownMenuItem>Settings</DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
      <DropdownMenu shape="minimal">
        <DropdownMenuTrigger asChild>
          <Button>Minimal</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem>Profile</DropdownMenuItem>
          <DropdownMenuItem>Settings</DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
      <DropdownMenu shape="sharp">
        <DropdownMenuTrigger asChild>
          <Button>Sharp</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent>
          <DropdownMenuItem>Profile</DropdownMenuItem>
          <DropdownMenuItem>Settings</DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  ),
};

export const WithGroupsAndLabels: Story = {
  name: "3. Groups & Labels",
  args: {
    shape: "minimal",
  },
  render: (args) => (
    <DropdownMenu {...args}>
      <DropdownMenuTrigger asChild>
        <Button variant="secondary">Open Grouped Menu</Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56">
        <DropdownMenuLabel>My Account</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem>
            <User className="mr-2 h-4 w-4" />
            <span>Profile</span>
          </DropdownMenuItem>
          <DropdownMenuItem>
            <Settings className="mr-2 h-4 w-4" />
            <span>Settings</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem>
            <Users className="mr-2 h-4 w-4" />
            <span>Team</span>
          </DropdownMenuItem>
          <DropdownMenuItem>
            <UserPlus className="mr-2 h-4 w-4" />
            <span>Invite users</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          <LifeBuoy className="mr-2 h-4 w-4" />
          <span>Support</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};

export const WithCheckboxes: Story = {
  name: "4. Checkbox Items",
  args: {
    shape: "minimal",
  },
  render: (args) => {
    const [showStatusBar, setShowStatusBar] = useState(true);
    const [showActivityBar, setShowActivityBar] = useState(false);
    return (
      <DropdownMenu {...args}>
        <DropdownMenuTrigger asChild>
          <Button>View Options</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-56">
          <DropdownMenuLabel>Panel Visibility</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuCheckboxItem
            checked={showStatusBar}
            onCheckedChange={setShowStatusBar}
          >
            Status Bar
          </DropdownMenuCheckboxItem>
          <DropdownMenuCheckboxItem
            checked={showActivityBar}
            onCheckedChange={setShowActivityBar}
          >
            Activity Bar
          </DropdownMenuCheckboxItem>
          <DropdownMenuCheckboxItem disabled>Panel</DropdownMenuCheckboxItem>
        </DropdownMenuContent>
      </DropdownMenu>
    );
  },
};

export const WithRadioGroup: Story = {
  name: "5. Radio Group Items",
  args: {
    shape: "minimal",
  },
  render: (args) => {
    const [position, setPosition] = useState("bottom");
    return (
      <DropdownMenu {...args}>
        <DropdownMenuTrigger asChild>
          <Button variant="secondary">Set Position</Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent className="w-56">
          <DropdownMenuLabel>Panel Position</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuRadioGroup value={position} onValueChange={setPosition}>
            <DropdownMenuRadioItem value="top">Top</DropdownMenuRadioItem>
            <DropdownMenuRadioItem value="bottom">Bottom</DropdownMenuRadioItem>
            <DropdownMenuRadioItem value="right">Right</DropdownMenuRadioItem>
          </DropdownMenuRadioGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    );
  },
};

export const WithSubMenu: Story = {
  name: "6. Sub-Menus",
  args: {
    shape: "minimal",
  },
  render: (args) => (
    <DropdownMenu {...args}>
      <DropdownMenuTrigger asChild>
        <Button>Open With Sub-Menu</Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56">
        <DropdownMenuItem>
          <Mail className="mr-2 h-4 w-4" />
          <span>Email</span>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <MessageSquare className="mr-2 h-4 w-4" />
          <span>Message</span>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuSub>
          <DropdownMenuSubTrigger>
            <UserPlus className="mr-2 h-4 w-4" />
            <span>Invite</span>
          </DropdownMenuSubTrigger>
          <DropdownMenuPortal>
            <DropdownMenuSubContent>
              <DropdownMenuItem>
                <Plus className="mr-2 h-4 w-4" />
                <span>New User</span>
              </DropdownMenuItem>
              <DropdownMenuItem>
                <PlusCircle className="mr-2 h-4 w-4" />
                <span>New Team</span>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <span>More...</span>
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuPortal>
        </DropdownMenuSub>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};
```


### Component: `elastic-scroll-area`

This section contains the source code for the `elastic-scroll-area` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\elastic-scroll-area\index.tsx`)**
```tsx
"use client";

import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import { clsx } from "clsx";
import {
  animate,
  motion,
  useMotionValue,
  useTransform,
  type MotionValue,
} from "framer-motion";
import { ArrowDown, Loader2 } from "lucide-react";
import React, {
  forwardRef,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react";

// --- CONSTANTS ---
const OVERSCROLL_DAMPING = 0.25;
const MAX_OVERSCROLL_DESKTOP = 200;
const SNAP_BACK_STIFFNESS = 300;
const SNAP_BACK_DAMPING = 30;
const DEFAULT_PULL_THRESHOLD = 80;

// --- TYPE DEFINITIONS ---
interface RefreshIndicatorProps {
  pullProgress: MotionValue<number>;
  isRefreshing: boolean;
}

export interface ElasticScrollAreaProps
  extends React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> {
  elasticity?: boolean;
  dampingFactor?: number;
  scrollbarVisibility?: "auto" | "always" | "scroll";
  pullToRefresh?: boolean;
  onRefresh?: () => Promise<unknown>;
  pullThreshold?: number;
  RefreshIndicatorComponent?: React.ComponentType<RefreshIndicatorProps>;
}
function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(value, max));
}

// --- DEFAULT REFRESH INDICATOR ---
const DefaultRefreshIndicator: React.FC<RefreshIndicatorProps> = ({
  pullProgress,
  isRefreshing,
}) => {
  const rotation = useTransform(
    pullProgress,
    [0, DEFAULT_PULL_THRESHOLD],
    [0, 180]
  );

  return isRefreshing ? (
    <Loader2 className="h-5 w-5 animate-spin text-graphite-primary" />
  ) : (
    <motion.div style={{ rotate: rotation }}>
      <ArrowDown className="h-5 w-5 text-graphite-foreground/70" />
    </motion.div>
  );
};

// --- OVERSCROLL & PULL-TO-REFRESH LOGIC HOOK ---
const useElasticAndRefresh = (
  viewportRef: React.RefObject<HTMLDivElement>,
  y: MotionValue<number>,
  options: {
    isEnabled: boolean;
    damping: number;
    isRefreshEnabled: boolean;
    onRefresh?: () => Promise<unknown>;
    pullThreshold: number;
  }
) => {
  const { isEnabled, damping, isRefreshEnabled, onRefresh, pullThreshold } =
    options;

  const [isRefreshing, setIsRefreshing] = useState(false);
  const isTouching = useRef(false);
  const startY = useRef(0);
  const isOverscrolling = useRef(false);
  const wheelTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const springToZero = useCallback(() => {
    animate(y, 0, {
      type: "spring",
      stiffness: SNAP_BACK_STIFFNESS,
      damping: SNAP_BACK_DAMPING,
    });
  }, [y]);

  // --- MODIFIED: triggerRefresh now snaps content back immediately ---
  const triggerRefresh = useCallback(async () => {
    if (!onRefresh) {
      console.warn(
        "ElasticScrollArea: `onRefresh` prop is missing but `pullToRefresh` is enabled."
      );
      springToZero();
      return;
    }
    setIsRefreshing(true);
    // Snap the content back to 0 immediately.
    // The indicator's style will be handled separately in the JSX.
    springToZero();
    try {
      await onRefresh();
    } finally {
      setIsRefreshing(false);
    }
  }, [onRefresh, springToZero]);

  useEffect(() => {
    const viewport = viewportRef.current;
    if (!viewport || !isEnabled) return;

    const handleWheel = (event: WheelEvent) => {
      if (isRefreshing) return;

      const { scrollTop, scrollHeight, clientHeight } = viewport;
      const isAtTop = scrollTop <= 0;
      const isAtBottom = scrollTop >= scrollHeight - clientHeight;
      const isScrollingUp = event.deltaY < 0;
      const isScrollingDown = event.deltaY > 0;

      if ((isAtTop && isScrollingUp) || (isAtBottom && isScrollingDown)) {
        event.preventDefault();

        // Use a more controlled accumulation approach
        const currentY = y.get();
        const resistance = Math.abs(currentY) / MAX_OVERSCROLL_DESKTOP;
        const adjustedDelta = event.deltaY * damping * (1 - resistance);

        const newY = Math.max(
          -MAX_OVERSCROLL_DESKTOP,
          Math.min(MAX_OVERSCROLL_DESKTOP, currentY - adjustedDelta)
        );

        y.set(newY);

        // Clear any existing timeout and set a shorter one
        if (wheelTimeoutRef.current) clearTimeout(wheelTimeoutRef.current);
        wheelTimeoutRef.current = setTimeout(() => {
          const finalY = y.get();
          if (Math.abs(finalY) > 0) {
            if (isRefreshEnabled && finalY >= pullThreshold) {
              triggerRefresh();
            } else {
              springToZero();
            }
          }
        }, 50); // Shorter timeout for more responsive feel
      }
    };

    const handleTouchStart = (event: TouchEvent) => {
      if (isRefreshing || event.touches.length !== 1) return;
      isTouching.current = true;
      startY.current = event.touches[0].clientY;
    };

    const handleTouchMove = (event: TouchEvent) => {
      if (!isTouching.current || isRefreshing || event.touches.length !== 1)
        return;

      const { scrollTop, scrollHeight, clientHeight } = viewport;
      const currentY = event.touches[0].clientY;
      const deltaY = currentY - startY.current;
      const isAtTop = scrollTop <= 0;
      const isAtBottom = scrollTop >= scrollHeight - clientHeight;
      const isPullingDown = deltaY > 0;
      const isPullingUp = deltaY < 0;

      if ((isAtTop && isPullingDown) || (isAtBottom && isPullingUp)) {
        event.preventDefault();
        isOverscrolling.current = true;
        y.set(deltaY * damping);
      } else {
        if (isOverscrolling.current) {
          isOverscrolling.current = false;
          y.set(0);
          startY.current = currentY;
        }
      }
    };

    const handleTouchEnd = () => {
      if (!isTouching.current) return;
      isTouching.current = false;
      if (isOverscrolling.current) {
        if (isRefreshEnabled && y.get() >= pullThreshold) {
          triggerRefresh();
        } else {
          springToZero();
        }
        isOverscrolling.current = false;
      }
    };

    viewport.addEventListener("wheel", handleWheel, { passive: false });
    viewport.addEventListener("touchstart", handleTouchStart, {
      passive: false,
    });
    viewport.addEventListener("touchmove", handleTouchMove, { passive: false });
    viewport.addEventListener("touchend", handleTouchEnd, { passive: true });
    viewport.addEventListener("touchcancel", handleTouchEnd, {
      passive: true,
    });

    return () => {
      viewport.removeEventListener("wheel", handleWheel);
      viewport.removeEventListener("touchstart", handleTouchStart);
      viewport.removeEventListener("touchmove", handleTouchMove);
      viewport.removeEventListener("touchend", handleTouchEnd);
      viewport.removeEventListener("touchcancel", handleTouchEnd);
      if (wheelTimeoutRef.current) clearTimeout(wheelTimeoutRef.current);
    };
  }, [
    viewportRef,
    isEnabled,
    damping,
    y,
    springToZero,
    isRefreshEnabled,
    pullThreshold,
    triggerRefresh,
    isRefreshing,
  ]);

  return { isRefreshing };
};

// --- MAIN COMPONENT ---
const ElasticScrollAreaRoot = forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  ElasticScrollAreaProps
>(
  (
    {
      className,
      children,
      elasticity = true,
      dampingFactor = OVERSCROLL_DAMPING,
      scrollbarVisibility = "auto",
      pullToRefresh = false,
      onRefresh,
      pullThreshold = DEFAULT_PULL_THRESHOLD,
      RefreshIndicatorComponent = DefaultRefreshIndicator,
      ...props
    },
    ref
  ) => {
    const viewportRef = useRef<HTMLDivElement>(null);
    const y = useMotionValue(0);

    const { isRefreshing } = useElasticAndRefresh(viewportRef, y, {
      isEnabled: elasticity || pullToRefresh,
      damping: dampingFactor,
      isRefreshEnabled: pullToRefresh,
      onRefresh,
      pullThreshold,
    });

    const pullProgress = useTransform(y, (v) => (v > 0 ? v : 0));
    const indicatorOpacity = useTransform(
      pullProgress,
      [0, pullThreshold * 0.5],
      [0, 1]
    );

    return (
      <ScrollAreaPrimitive.Root
        ref={ref}
        className={clsx("relative h-full w-full overflow-hidden", className)}
        {...props}
      >
        {pullToRefresh && (
          <motion.div
            className="pointer-events-none absolute inset-x-0 top-[-40px] z-20 flex justify-center"
            // --- MODIFIED: Decouple indicator from content during refresh ---
            style={{
              y: isRefreshing ? pullThreshold + 40 : pullProgress,
              opacity: isRefreshing ? 1 : indicatorOpacity,
            }}
            transition={{ type: "spring", stiffness: 300, damping: 30 }}
          >
            <div className="flex h-10 w-10 items-center justify-center rounded-full bg-graphite-card shadow-md">
              <RefreshIndicatorComponent
                pullProgress={pullProgress}
                isRefreshing={isRefreshing}
              />
            </div>
          </motion.div>
        )}

        <motion.div style={{ y }} className="h-full w-full">
          <ScrollAreaPrimitive.Viewport
            ref={viewportRef}
            className="h-full w-full rounded-[inherit]"
          >
            {children}
          </ScrollAreaPrimitive.Viewport>
        </motion.div>

        <ScrollBar scrollbarVisibility={scrollbarVisibility} />
        <ScrollAreaPrimitive.Corner />
      </ScrollAreaPrimitive.Root>
    );
  }
);
ElasticScrollAreaRoot.displayName = "ElasticScrollArea";

// --- STYLED SUB-COMPONENTS ---
const ScrollBar = forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Scrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Scrollbar> & {
    scrollbarVisibility?: ElasticScrollAreaProps["scrollbarVisibility"];
  }
>(
  (
    {
      className,
      orientation = "vertical",
      scrollbarVisibility = "auto",
      ...props
    },
    ref
  ) => (
    <ScrollAreaPrimitive.Scrollbar
      ref={ref}
      orientation={orientation}
      className={clsx(
        "flex touch-none select-none transition-opacity duration-200",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent p-[1px]",
        orientation === "horizontal" &&
          "h-2.5 border-t border-t-transparent p-[1px]",
        {
          "opacity-100": scrollbarVisibility === "always",
          "data-[state=hidden]:opacity-0": scrollbarVisibility === "scroll",
          "opacity-0 data-[state=visible]:opacity-100":
            scrollbarVisibility === "auto",
        },
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.Thumb className="relative flex-1 rounded-full bg-graphite-border" />
    </ScrollAreaPrimitive.Scrollbar>
  )
);
ScrollBar.displayName = ScrollAreaPrimitive.Scrollbar.displayName;

export const ElasticScrollArea = Object.assign(ElasticScrollAreaRoot, {
  ScrollBar,
});
```

**Storybook Stories (`elastic-scroll-area.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { motion, useTransform, type MotionValue } from "framer-motion";
import { Sun } from "lucide-react";
import { Typography } from "../typography";
import { ElasticScrollArea } from "./index";

const meta: Meta<typeof ElasticScrollArea> = {
  title: "Components/ElasticScrollArea",
  component: ElasticScrollArea,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A scroll container that provides a native-like 'rubber band' or elastic overscroll effect, common in modern operating systems like iOS and macOS. It is built on top of Radix UI's accessible Scroll Area primitive and powered by Framer Motion for physics-based animations.",
      },
    },
  },
  argTypes: {
    elasticity: {
      control: "boolean",
      description: "Toggles the elastic overscroll effect.",
    },
    dampingFactor: {
      control: { type: "range", min: 0.05, max: 0.5, step: 0.01 },
      description:
        "Controls the resistance of the pull. Lower values are stiffer.",
    },
    scrollbarVisibility: {
      control: "select",
      options: ["auto", "always", "scroll"],
      description: "Controls the visibility of the scrollbar.",
    },
    pullToRefresh: {
      control: "boolean",
      description: "Enables the pull-to-refresh functionality.",
    },
    pullThreshold: {
      control: { type: "number", min: 40, max: 200, step: 10 },
      description: "The pixel distance to pull to trigger a refresh.",
    },
    onRefresh: { action: "refreshed" },
    children: { control: false },
    RefreshIndicatorComponent: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof ElasticScrollArea>;

// Helper component to generate scrollable content
const DummyContent = ({ itemCount = 30 }: { itemCount?: number }) => (
  <main className="p-6">
    <Typography variant="h3">Scroll Me</Typography>
    <Typography variant="muted">
      Use your mouse wheel, trackpad, or touch to scroll. Try scrolling past the
      top or bottom edges.
    </Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2">
      {Array.from({ length: itemCount }).map((_, i) => (
        <div
          key={i}
          className="h-24 rounded-2xl bg-graphite-secondary flex items-center justify-center"
        >
          <Typography variant="small" className="text-graphite-foreground/50">
            Item {i + 1}
          </Typography>
        </div>
      ))}
    </div>
  </main>
);

// A mock async function for the onRefresh prop
const simulateRefresh = () => {
  return new Promise((resolve) => setTimeout(resolve, 2000));
};

// A smart render function to wrap stories in a sized container
const render = (args: any) => (
  <div className="w-96 h-[600px] rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
    <ElasticScrollArea {...args} />
  </div>
);

// --- STORIES ---

export const Default: Story = {
  name: "1. Default Elasticity",
  args: {
    elasticity: true,
    dampingFactor: 0.25,
    scrollbarVisibility: "auto",
    children: <DummyContent />,
  },
  render,
};

export const PullToRefresh: Story = {
  name: "2. With Pull to Refresh",
  args: {
    ...Default.args,
    pullToRefresh: true,
    onRefresh: simulateRefresh,
    pullThreshold: 80,
  },
  parameters: {
    docs: {
      description: {
        story:
          "**This demonstrates the new behavior.** Set `pullToRefresh={true}` and provide an `onRefresh` async function. When you pull and release, the content will immediately snap back into place while the indicator remains visible during the loading state.",
      },
    },
  },
  render,
};

// --- Custom Indicator Example ---
const CustomWeatherIndicator = ({
  pullProgress,
  isRefreshing,
}: {
  pullProgress: MotionValue<number>;
  isRefreshing: boolean;
}) => {
  const rotation = useTransform(pullProgress, [0, 150], [0, 360]);
  return (
    <motion.div style={{ rotate: rotation }}>
      <Sun
        className={
          isRefreshing
            ? "h-6 w-6 text-yellow-500 animate-spin"
            : "h-6 w-6 text-yellow-500"
        }
      />
    </motion.div>
  );
};

export const CustomRefreshIndicator: Story = {
  name: "3. Custom Refresh Indicator",
  args: {
    ...PullToRefresh.args,
    pullThreshold: 100,
    RefreshIndicatorComponent: CustomWeatherIndicator,
  },
  parameters: {
    docs: {
      description: {
        story:
          "You can pass a custom component to `RefreshIndicatorComponent` to create unique loading experiences.",
      },
    },
  },
  render,
};

export const ScrollbarVisibility: Story = {
  name: "4. Scrollbar Visibility",
  parameters: {
    docs: {
      description: {
        story:
          "The `scrollbarVisibility` prop controls how the scrollbar is displayed. `auto` shows on hover/scroll, `always` keeps it visible, and `scroll` only shows during active scrolling.",
      },
    },
  },
  render: () => (
    <div className="flex gap-4 items-start">
      <div className="flex flex-col items-center gap-2">
        <Typography variant="small" className="font-bold">
          'auto' (default)
        </Typography>
        <div className="w-64 h-96 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
          <ElasticScrollArea scrollbarVisibility="auto">
            <DummyContent itemCount={15} />
          </ElasticScrollArea>
        </div>
      </div>
      <div className="flex flex-col items-center gap-2">
        <Typography variant="small" className="font-bold">
          'always'
        </Typography>
        <div className="w-64 h-96 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
          <ElasticScrollArea scrollbarVisibility="always">
            <DummyContent itemCount={15} />
          </ElasticScrollArea>
        </div>
      </div>
      <div className="flex flex-col items-center gap-2">
        <Typography variant="small" className="font-bold">
          'scroll'
        </Typography>
        <div className="w-64 h-96 rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
          <ElasticScrollArea scrollbarVisibility="scroll">
            <DummyContent itemCount={15} />
          </ElasticScrollArea>
        </div>
      </div>
    </div>
  ),
};

export const DisabledElasticity: Story = {
  name: "5. Elasticity Disabled",
  args: {
    ...Default.args,
    elasticity: false,
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `elasticity` is set to `false`, the component behaves as a standard scroll area with no overscroll effect.",
      },
    },
  },
  render,
};
```


### Component: `fab`

This section contains the source code for the `fab` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\fab\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import {
  AnimatePresence,
  type HTMLMotionProps,
  motion,
  type Transition,
} from "framer-motion";
import React from "react";
import useRipple from "use-ripple-hook";
import { BouncyBox } from "../bouncy-box";

const fabVariants = cva(
  // We ensure justify-start is the base, and will conditionally add justify-center
  "font-semibold focus:outline-none flex items-center justify-start relative overflow-hidden group bg-graphite-primary text-graphite-primaryForeground shadow-lg hover:shadow-xl focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
  {
    variants: {
      size: {
        // We only need height here, as width and padding will be animated
        sm: "h-10",
        md: "h-14",
        lg: "h-16",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      size: "md",
      shape: "full",
    },
  }
);

export interface FABProps
  extends Omit<HTMLMotionProps<"button">, "children" | "ref">,
    VariantProps<typeof fabVariants> {
  icon: React.ReactNode;
  isExtended?: boolean;
  children?: React.ReactNode;
}

// A more refined spring transition for a smoother feel
const transition = {
  type: "spring",
  stiffness: 500,
  damping: 40,
  mass: 1,
} as Transition;

export const FAB = React.forwardRef<HTMLButtonElement, FABProps>(
  (
    { className, size, shape, children, disabled, icon, isExtended, ...props },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);
    const rippleRef = localRef as React.RefObject<HTMLElement>;
    const [, event] = useRipple({
      ref: rippleRef,
      color: "rgba(255, 255, 255, 0.3)",
      duration: 400,
      disabled: disabled,
    });

    const fabSize = fabSizeMap[size || "md"];

    return (
      <motion.button
        // --- MODIFICATION START ---
        // 1. Set the initial state before the component mounts
        initial={{ scale: 0, opacity: 0 }}
        // 2. Animate to the final state, merging with existing animations
        animate={{
          scale: 1, // Animate scale to 1
          opacity: 1, // Animate opacity to 1
          paddingLeft: isExtended ? fabSize / 2 : fabSize / 4,
          paddingRight: isExtended ? fabSize / 2 : fabSize / 4,
        }}
        // --- MODIFICATION END ---
        transition={transition}
        className={clsx(
          fabVariants({ size, shape, className }),
          // Center the content ONLY when collapsed
          !isExtended && "justify-center"
        )}
        ref={localRef}
        onPointerDown={event}
        disabled={disabled}
        {...props}
      >
        {/* The Icon: Add the magic `layout` prop */}
        <motion.span layout="position" className="flex-shrink-0 z-10">
          {icon}
        </motion.span>

        <AnimatePresence>
          {isExtended && (
            <motion.div
              // Animate width from 0 to auto
              initial={{ width: 0, opacity: 0 }}
              animate={{ width: "auto", opacity: 1, marginLeft: "0.75rem" }}
              exit={{ width: 0, opacity: 0, marginLeft: 0 }}
              transition={transition}
              className="whitespace-nowrap overflow-hidden"
            >
              {children}
            </motion.div>
          )}
        </AnimatePresence>
      </motion.button>
    );
  }
);

const fabSizeMap: Record<string, number> = {
  sm: 40,
  md: 56,
  lg: 64,
};

FAB.displayName = "FAB";
```

**Storybook Stories (`FAB.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { CreditCard, LogOut, Plus, Settings, User } from "lucide-react";
import { useState } from "react";
import { Button } from "../button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuTrigger,
} from "../dropdown-menu"; // Assuming this is the correct path
import { FAB } from "./index";

const meta: Meta<typeof FAB> = {
  title: "Components/FAB",
  component: FAB,
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    isExtended: { control: "boolean" },
    disabled: { control: "boolean" },
    onClick: { action: "clicked" },
  },
  args: {
    icon: <Plus className="h-7 w-7" />,
    children: "Create New",
    "aria-label": "Create New Item",
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    isExtended: false,
    shape: "full",
  },
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: (args) => (
    <div className="flex flex-col items-start space-y-6">
      <p className="font-semibold">Shape: Full</p>
      <div className="flex items-center gap-4">
        <FAB {...args} shape="full" isExtended={false} />
        <FAB {...args} shape="full" isExtended={true} />
      </div>
      <p className="font-semibold">Shape: Minimal</p>
      <div className="flex items-center gap-4">
        <FAB {...args} shape="minimal" isExtended={false} />
        <FAB {...args} shape="minimal" isExtended={true} />
      </div>
      <p className="font-semibold">Shape: Sharp</p>
      <div className="flex items-center gap-4">
        <FAB {...args} shape="sharp" isExtended={false} />
        <FAB {...args} shape="sharp" isExtended={true} />
      </div>
    </div>
  ),
};

export const InteractiveAnimation: Story = {
  name: "Interactive Animation",
  parameters: {
    docs: {
      description: {
        story:
          "This story uses a CSS Grid animation for a perfectly smooth transition. The text label's grid column animates from `0fr` to `1fr`.",
      },
    },
  },
  render: (args) => {
    const [isExtended, setIsExtended] = useState(false);

    return (
      <div className="space-y-4 flex flex-col">
        <p>Click the button below to see the smooth FAB animation.</p>
        <Button
          variant="secondary"
          size="sm"
          onClick={() => setIsExtended((prev) => !prev)}
        >
          {isExtended ? "Collapse FAB" : "Extend FAB"}
        </Button>
        <div>
          <FAB {...args} isExtended={isExtended} />
        </div>
      </div>
    );
  },
};

// New story showcasing FAB with a Dropdown Menu
export const WithDropdownMenu: Story = {
  name: "With Dropdown Menu",
  parameters: {
    layout: "centered",
    docs: {
      description: {
        story:
          "A FAB can be used as a trigger for a Dropdown Menu. Wrap the FAB with the `DropdownMenuTrigger` component and pass the `asChild` prop.",
      },
    },
  },
  render: (args) => (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        {/* Render the FAB as the trigger, using args from Storybook controls */}
        <FAB {...args} isExtended={false} />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuItem>
          <User className="mr-2 h-4 w-4" />
          <span>Profile</span>
          <DropdownMenuShortcut>⇧⌘P</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <CreditCard className="mr-2 h-4 w-4" />
          <span>Billing</span>
          <DropdownMenuShortcut>⌘B</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuItem>
          <Settings className="mr-2 h-4 w-4" />
          <span>Settings</span>
          <DropdownMenuShortcut>⌘S</DropdownMenuShortcut>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
          <DropdownMenuShortcut>⇧⌘Q</DropdownMenuShortcut>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
};
```


### Component: `icon-button`

This section contains the source code for the `icon-button` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\icon-button\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import { AnimatePresence, motion } from "framer-motion";
import { Loader, Loader2 } from "lucide-react"; // Import Loader from lucide-react
import React from "react";
import useRipple from "use-ripple-hook";

export const iconButtonVariants = cva(
  "font-semibold focus:outline-none min-w-max transition-all duration-300 ease-in-out flex items-center justify-center relative overflow-hidden p-0",
  {
    variants: {
      variant: {
        primary:
          "bg-graphite-primary disabled:bg-graphite-primary/70 text-graphite-primaryForeground hover:opacity-90 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        secondary:
          "bg-graphite-secondary disabled:bg-graphite-secondary/70 text-graphite-secondaryForeground hover:bg-graphite-secondary/80  focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        ghost:
          "bg-transparent disabled:opacity-70 text-graphite-foreground hover:bg-graphite-secondary focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
        link: "bg-transparent disabled:opacity-70 text-graphite-primary hover:text-graphite-primary hover:underline !p-1 focus:ring-2 focus:ring-offset-2 focus:ring-graphite-ring",
      },
      size: {
        xs: "h-8 w-8",
        sm: "h-10 w-10",
        md: "h-12 w-12",
        lg: "h-14 w-14",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-lg",
        sharp: "rounded-none",
      },
      isLoading: {
        true: "cursor-wait",
      },
    },
    defaultVariants: {
      variant: "primary",
      size: "md",
      shape: "full",
    },
  }
);

export interface IconButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof iconButtonVariants> {
  isLoading?: boolean;
}

export const IconButton = React.forwardRef<HTMLButtonElement, IconButtonProps>(
  (
    {
      className,
      variant,
      size,
      shape,
      children,
      disabled,
      isLoading,
      ...props
    },
    ref
  ) => {
    const localRef = React.useRef<HTMLButtonElement>(null);
    React.useImperativeHandle(ref, () => localRef.current as HTMLButtonElement);
    const rippleColor =
      variant === "primary" ? "rgba(255, 255, 255, 0.4)" : "rgba(0, 0, 0, 0.1)";
    const rippleRef = localRef as React.RefObject<HTMLElement>;
    const [, event] = useRipple({
      ref: rippleRef,
      color: rippleColor,
      duration: 600,
      disabled: disabled || isLoading,
    });

    const loaderSizeMap = {
      xs: "h-4 w-4",
      sm: "h-5 w-5",
      md: "h-6 w-6",
      lg: "h-8 w-8",
    };

    return (
      <button
        className={iconButtonVariants({
          variant,
          size,
          shape,
          className,
          isLoading,
        })}
        ref={localRef}
        onPointerDown={event}
        disabled={disabled || isLoading}
        {...props}
      >
        <AnimatePresence mode="wait" initial={false}>
          {isLoading ? (
            <motion.div
              key="spinner"
              initial={{ opacity: 0, scale: 0.5 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.5 }}
              transition={{ duration: 0.2 }}
            >
              {/* Use lucide-react Loader with animate-spin */}
              <Loader2
                className={`animate-spin ${loaderSizeMap[size || "md"]}`}
              />
            </motion.div>
          ) : (
            <motion.span
              key="content"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
              className="relative z-10"
            >
              {children}
            </motion.span>
          )}
        </AnimatePresence>
      </button>
    );
  }
);

IconButton.displayName = "IconButton";
```

**Storybook Stories (`Icon-button.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Plus } from "lucide-react";
import { useState } from "react";
import { IconButton } from "./index";

const meta: Meta<typeof IconButton> = {
  title: "Components/IconButton",
  component: IconButton,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary", "ghost", "link"],
    },
    size: {
      control: "select",
      options: ["xs", "sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "The border radius of the icon button.",
    },
    isLoading: { control: "boolean" }, // Added isLoading control
    disabled: { control: "boolean" },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    variant: "primary",
    size: "md",
    shape: "full",
    children: <Plus className="h-6 w-6" />,
    "aria-label": "Add new item",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton variant="primary" size="md" aria-label="Primary">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="secondary" size="md" aria-label="Secondary">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="ghost" size="md" aria-label="Ghost">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="link" size="md" aria-label="Link">
        <Plus className="h-6 w-6" />
      </IconButton>
    </div>
  ),
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton variant="primary" size="lg" aria-label="Large">
        <Plus className="h-8 w-8" />
      </IconButton>
      <IconButton variant="primary" size="md" aria-label="Medium">
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="primary" size="sm" aria-label="Small">
        <Plus className="h-5 w-5" />
      </IconButton>
      <IconButton variant="primary" size="xs" aria-label="Extra Small">
        <Plus className="h-4 w-4" />
      </IconButton>
    </div>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton
        variant="primary"
        size="md"
        shape="full"
        aria-label="Full Shape"
      >
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton
        variant="primary"
        size="md"
        shape="minimal"
        aria-label="Minimal Shape"
      >
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton
        variant="primary"
        size="md"
        shape="sharp"
        aria-label="Sharp Shape"
      >
        <Plus className="h-6 w-6" />
      </IconButton>
    </div>
  ),
};

// --- NEW STORIES FOR LOADING STATE ---

export const Loading: Story = {
  name: "Loading State",
  render: () => (
    <div className="flex flex-wrap items-center gap-4">
      <IconButton variant="primary" size="md" aria-label="Loading" isLoading>
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="secondary" size="md" aria-label="Loading" isLoading>
        <Plus className="h-6 w-6" />
      </IconButton>
      <IconButton variant="ghost" size="md" aria-label="Loading" isLoading>
        <Plus className="h-6 w-6" />
      </IconButton>
    </div>
  ),
};

export const InteractiveLoading: Story = {
  name: "Interactive Loading",
  render: () => {
    const [isLoading, setIsLoading] = useState(false);
    const handleClick = () => {
      setIsLoading(true);
      setTimeout(() => {
        setIsLoading(false);
      }, 2000);
    };
    return (
      <IconButton
        variant="primary"
        size="lg"
        aria-label="Submit"
        isLoading={isLoading}
        onClick={handleClick}
      >
        <Plus className="h-8 w-8" />
      </IconButton>
    );
  },
};
```


### Component: `input`

This section contains the source code for the `input` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\input\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import React from "react";

const inputWrapperVariants = cva(
  "flex items-center transition-all duration-200 w-full px-4 border-2",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
      },
      shape: {
        full: "rounded-4xl",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
      size: {
        sm: "h-10 text-sm",
        md: "h-12 text-base",
        lg: "h-14 text-lg",
      },
      isErrored: { true: "" },
      isFocused: { true: "" },
      disabled: {
        true: "bg-graphite-secondary opacity-50 cursor-not-allowed",
      },
    },
    compoundVariants: [
      {
        variant: "primary",
        isErrored: false,
        isFocused: false,
        className: "border-graphite-border",
      },
      {
        variant: "secondary",
        isErrored: false,
        isFocused: false,
        className: "border-transparent",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "primary",
        isFocused: false,
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "secondary",
        isFocused: false,
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
    ],
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
      size: "md",
    },
  }
);

// FIX #2: Use VariantProps to remove the unused import warning and keep types in sync.
export interface InputProps
  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "size">,
    VariantProps<typeof inputWrapperVariants> {
  label?: string;
  startAdornment?: React.ReactNode;
  endAdornment?: React.ReactNode;
  error?: string;
  wrapperClassName?: string;
}

export const Input = React.forwardRef<HTMLInputElement, InputProps>(
  (
    {
      className,
      id,
      label,
      startAdornment,
      endAdornment,
      error,
      disabled,
      shape,
      size,
      wrapperClassName,
      variant,
      onFocus,
      onBlur,
      onKeyDown,
      onPaste,
      type,
      ...props
    },
    ref
  ) => {
    const uniqueId = React.useId();
    const inputId = id || uniqueId;
    const hasError = !!error;
    const [isFocused, setIsFocused] = React.useState(false);

    const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
      setIsFocused(true);
      onFocus?.(e);
    };

    const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
      setIsFocused(false);
      onBlur?.(e);
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (type === "number") {
        // FIX #1: Corrected the syntax error here.
        const { value } = e.currentTarget;
        const allowedKeys = [
          "Backspace",
          "Delete",
          "Tab",
          "Escape",
          "Enter",
          "ArrowLeft",
          "ArrowRight",
          "Home",
          "End",
        ];
        if (e.key === "." && !value.includes(".")) {
          return;
        }
        if (allowedKeys.includes(e.key)) {
          return;
        }
        if (e.ctrlKey || e.metaKey) {
          return;
        }
        if (!/^[0-9]$/.test(e.key)) {
          e.preventDefault();
        }
      }
      onKeyDown?.(e);
    };

    const handlePaste = (e: React.ClipboardEvent<HTMLInputElement>) => {
      if (type === "number") {
        const pastedText = e.clipboardData.getData("text");
        if (!/^\d*\.?\d*$/.test(pastedText)) {
          e.preventDefault();
        }
      }
      onPaste?.(e);
    };

    return (
      <div className="w-full flex flex-col gap-2">
        {label && (
          <label
            htmlFor={inputId}
            className="block text-sm font-medium text-graphite-primary"
          >
            {label}
          </label>
        )}
        <div
          className={inputWrapperVariants({
            variant,
            shape,
            size,
            isErrored: hasError,
            isFocused,
            disabled,
            className: wrapperClassName,
          })}
        >
          {startAdornment && (
            <div className="flex items-center mr-2">{startAdornment}</div>
          )}
          <input
            id={inputId}
            ref={ref}
            disabled={disabled}
            type={type}
            onFocus={handleFocus}
            onBlur={handleBlur}
            onKeyDown={handleKeyDown}
            onPaste={handlePaste}
            className={clsx(
              "w-full flex-1 bg-transparent focus:outline-none",
              "disabled:cursor-not-allowed",
              variant === "secondary" && "placeholder:text-gray-500",
              className
            )}
            {...props}
          />
          {endAdornment && (
            <div className="flex items-center ml-2">{endAdornment}</div>
          )}
        </div>
        {hasError && <p className="mt-2 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);

Input.displayName = "Input";
```

**Storybook Stories (`Input.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Eye, EyeOff, Mail, Search } from "lucide-react";
import { useState } from "react";
import { Input } from "./index";

const meta: Meta<typeof Input> = {
  title: "Components/Input",
  component: Input,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    label: { control: "text" },
    placeholder: { control: "text" },
    disabled: { control: "boolean" },
    error: { control: "text" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
    size: "md", // Default size
    label: "Email Address",
    placeholder: "you@example.com",
    startAdornment: <Mail className="h-4 w-4" />,
  },
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-col gap-6 max-w-sm">
      <Input
        size="sm"
        label="Small"
        placeholder="Small input (sm)"
        startAdornment={<Search className="h-4 w-4" />}
      />
      <Input
        size="md"
        label="Medium (Default)"
        placeholder="Medium input (md)"
        startAdornment={<Search className="h-5 w-5" />}
      />
      <Input
        size="lg"
        label="Large"
        placeholder="Large input (lg)"
        startAdornment={<Search className="h-6 w-6" />}
      />
    </div>
  ),
};

export const AllVariantsAndShapes: Story = {
  name: "All Variants & Shapes",
  render: () => (
    <div className="flex flex-col gap-8 max-w-sm">
      <div>
        <h3 className="font-bold mb-4">Primary Variant</h3>
        <div className="flex flex-col gap-4">
          <Input variant="primary" shape="full" placeholder="Full Shape" />
          <Input
            variant="primary"
            shape="minimal"
            placeholder="Minimal Shape"
          />
          <Input variant="primary" shape="sharp" placeholder="Sharp Shape" />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary Variant</h3>
        <div className="flex flex-col gap-4">
          <Input variant="secondary" shape="full" placeholder="Full Shape" />
          <Input
            variant="secondary"
            shape="minimal"
            placeholder="Minimal Shape"
          />
          <Input variant="secondary" shape="sharp" placeholder="Sharp Shape" />
        </div>
      </div>
    </div>
  ),
};

export const AllStates: Story = {
  name: "All States",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl">
      <div>
        <h3 className="font-bold mb-4">Primary States</h3>
        <div className="flex flex-col gap-4">
          <Input
            variant="primary"
            label="Default"
            placeholder="Enter text..."
          />
          <Input
            variant="primary"
            label="With Value"
            defaultValue="Some text"
          />
          <Input
            variant="primary"
            label="Focused"
            placeholder="This input is focused"
            autoFocus
          />
          <Input
            variant="primary"
            label="Error State"
            defaultValue="invalid-email@"
            error="Please enter a valid email address."
          />
          <Input
            variant="primary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary States</h3>
        <div className="flex flex-col gap-4">
          <Input
            variant="secondary"
            label="Default"
            placeholder="Enter text..."
          />
          <Input
            variant="secondary"
            label="With Value"
            defaultValue="Some text"
          />
          <Input
            variant="secondary"
            label="Focused"
            placeholder="This input is focused"
            autoFocus
          />
          <Input
            variant="secondary"
            label="Error State"
            defaultValue="invalid-email@"
            error="Please enter a valid email address."
          />
          <Input
            variant="secondary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
    </div>
  ),
};

export const WithAdornments: Story = {
  name: "With Adornments",
  render: () => (
    <div className="space-y-4 max-w-sm">
      <Input
        label="Search"
        placeholder="Search for anything..."
        startAdornment={<Search className="h-5 w-5" />}
      />
      <Input
        variant="secondary"
        label="Website"
        startAdornment={<span className="text-gray-400 text-sm">https://</span>}
        endAdornment={<span className="text-gray-400 text-sm">.com</span>}
        defaultValue="chesai"
      />
    </div>
  ),
};

export const NumberInput: Story = {
  name: "Number Input",
  args: {
    label: "Age",
    placeholder: "Enter numbers only",
    type: "number",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `type='number'`, this input prevents non-numeric characters from being typed or pasted.",
      },
    },
  },
};

export const PasswordInput: Story = {
  name: "Password Input Example",
  render: () => {
    const [isVisible, setIsVisible] = useState(false);
    return (
      <div className="max-w-sm">
        <Input
          label="Password"
          type={isVisible ? "text" : "password"}
          placeholder="Enter your password"
          endAdornment={
            <button
              type="button"
              onClick={() => setIsVisible(!isVisible)}
              aria-label={isVisible ? "Hide password" : "Show password"}
              className="p-1 hover:text-gray-600"
            >
              {isVisible ? (
                <EyeOff className="h-5 w-5" />
              ) : (
                <Eye className="h-5 w-5" />
              )}
            </button>
          }
        />
      </div>
    );
  },
};
```


### Component: `list`

This section contains the source code for the `list` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\list\index.tsx`)**
```tsx
"use client";

import { useLongPress } from "@uidotdev/usehooks";
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import { Reorder } from "framer-motion";
import React, { useState } from "react";
import { ListContext } from "../../context/List.context";
import { Typography } from "../typography";
import { ListItem, ListItemProps } from "./ListItem";

const listVariants = cva("flex w-full flex-col overflow-hidden", {
  variants: {
    variant: {
      primary: "bg-graphite-card",
      secondary: "bg-graphite-secondary",
    },
    shape: {
      full: "rounded-2xl",
      minimal: "rounded-lg",
      sharp: "rounded-none",
    },
  },
  defaultVariants: {
    variant: "primary",
    shape: "minimal",
  },
});

const Divider = () => <div className="h-px bg-graphite-border" />;

interface ListProps<T>
  extends React.HTMLAttributes<HTMLUListElement>,
    VariantProps<typeof listVariants> {
  children: React.ReactNode;
  dividers?: boolean;
  header?: React.ReactNode;
  reorderable?: boolean;
  items?: T[];
  onReorder?: (newOrder: T[]) => void;
  selectable?: boolean;
}

const ListRoot = <T extends { id: string | number }>({
  className,
  children,
  dividers = false,
  header,
  variant,
  shape,
  reorderable = false,
  items,
  onReorder,
  selectable = false,
  ...props
}: ListProps<T>) => {
  const [isSelectionMode, setIsSelectionMode] = useState(false);
  const [selectedItems, setSelectedItems] = useState<Set<string | number>>(
    new Set()
  );

  const toggleSelection = (id: string | number) => {
    setSelectedItems((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(id)) {
        newSet.delete(id);
      } else {
        newSet.add(id);
      }
      return newSet;
    });
  };

  const longPressAttrs = useLongPress(
    () => {
      if (selectable && !reorderable) setIsSelectionMode(true);
    },
    { threshold: 500 }
  );

  const startReorder = (id: string | number) => {
    // Optional: could add logic here if needed when drag starts
  };

  const childArray = React.Children.toArray(children);

  const renderContent = () => (
    <>
      {childArray.map((child, index) => {
        if (!React.isValidElement(child)) return child;
        const isLast = index === childArray.length - 1;
        return (
          <React.Fragment key={(child.props as ListItemProps).id}>
            {child}
            {dividers && !isLast && <Divider />}
          </React.Fragment>
        );
      })}
    </>
  );

  return (
    <ListContext.Provider
      value={{
        isSelectionMode,
        setIsSelectionMode,
        selectedItems,
        toggleSelection,
        isReorderable: reorderable,
        startReorder,
      }}
    >
      <div {...(selectable && longPressAttrs)}>
        {header && (
          <div className="px-4 py-2">
            <Typography
              variant="small"
              className="font-bold text-graphite-primary"
            >
              {header}
            </Typography>
          </div>
        )}
        {reorderable ? (
          <Reorder.Group
            as="ul"
            axis="y"
            values={items || []}
            onReorder={onReorder as any}
            className={clsx(listVariants({ variant, shape, className }))}
            {...props}
          >
            {children}
          </Reorder.Group>
        ) : (
          <ul
            className={clsx(listVariants({ variant, shape, className }))}
            {...props}
          >
            {renderContent()}
          </ul>
        )}
      </div>
    </ListContext.Provider>
  );
};

export const List = Object.assign(ListRoot, {
  Item: ListItem,
});
```

**Storybook Stories (`List.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { MoreVertical, Trash2 } from "lucide-react";
import React, { useState } from "react";
import { Avatar } from "../avatar";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { List } from "./index";

const meta: Meta<typeof List> = {
  title: "Components/List",
  component: List,
  subcomponents: { "List.Item": List.Item },
  tags: ["autodocs"],
  argTypes: {
    header: { control: "text" },
    dividers: { control: "boolean" },
    variant: { control: "select", options: ["primary", "secondary"] },
    shape: { control: "select", options: ["full", "minimal", "sharp"] },
    selectable: { control: "boolean" },
    reorderable: { control: "boolean" },
  },
};

export default meta;
type Story = StoryObj<typeof List>;

const sampleItems = [
  { id: 1, name: "Alisa Hester", status: "Online", avatar: "a" },
  { id: 2, name: "Barrera Ramsey", status: "Last seen 5m ago", avatar: "b" },
  { id: 3, name: "Carroll Buchanan", status: "Typing...", avatar: "c" },
  { id: 4, name: "Decker Mckenzie", status: "Away", avatar: "d" },
];

export const Default: Story = {
  name: "1. Default List",
  args: {
    header: "Contacts",
    dividers: true,
    variant: "primary",
    shape: "minimal",
  },
  render: (args) => (
    <List {...args}>
      {sampleItems.map((item) => (
        <List.Item
          key={item.id}
          id={item.id}
          headline={item.name}
          supportingText={item.status}
          startAdornment={<Avatar fallback={item.name} />}
          endAdornment={
            <IconButton variant="ghost">
              <MoreVertical />
            </IconButton>
          }
        />
      ))}
    </List>
  ),
};

export const SelectionMode: Story = {
  name: "2. Selection Mode (Long Press)",
  args: { ...Default.args, selectable: true },
  parameters: {
    docs: {
      description: {
        story:
          "Long press any item to enter selection mode. Clicks will then toggle selection. The `selectable` prop must be true.",
      },
    },
  },
  render: (args) => <Default.render {...args} />,
};

export const SwipeToReveal: Story = {
  name: "3. Swipe to Reveal Actions",
  args: { ...Default.args },
  parameters: {
    docs: {
      description: {
        story:
          "Swipe an item left to reveal hidden actions. The component handles the animation.",
      },
    },
  },
  render: (args) => (
    <List {...args}>
      {sampleItems.map((item) => (
        <List.Item
          key={item.id}
          id={item.id}
          headline={item.name}
          supportingText={item.status}
          startAdornment={<Avatar fallback={item.name} />}
          swipeActions={
            <div className="flex h-full">
              <Button
                shape="sharp"
                className="h-full !rounded-none bg-red-500 hover:bg-red-600"
                onClick={() => alert(`Deleted ${item.name}`)}
              >
                <Trash2 />
              </Button>
            </div>
          }
        />
      ))}
    </List>
  ),
};

export const DragToReorder: Story = {
  name: "4. Drag to Reorder",
  args: { ...Default.args, reorderable: true, dividers: true },
  parameters: {
    docs: {
      description: {
        story:
          "When `reorderable` is true, a drag handle appears. Drag items to reorder the list. This requires passing `items` and `onReorder` props.",
      },
    },
  },
  render: function Render(args) {
    const [items, setItems] = useState(sampleItems);
    return (
      <List {...args} items={items} onReorder={setItems}>
        {items.map((item) => (
          <List.Item
            key={item.id}
            id={item.id}
            headline={item.name}
            supportingText={item.status}
            startAdornment={<Avatar fallback={item.name} />}
          />
        ))}
      </List>
    );
  },
};
```


### Component: `pull-to-refresh`

This section contains the source code for the `pull-to-refresh` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\pull-to-refresh\index.tsx`)**
```tsx
"use client";

import { clsx } from "clsx";
import { animate, motion, useMotionValue, useTransform } from "framer-motion";
import { ArrowDown, Loader2 } from "lucide-react";
import React, { useEffect, useRef, useState } from "react";

// --- CONSTANTS ---
const PULL_THRESHOLD = 100;
const REFRESH_Y_POSITION = 160;

// --- TYPE DEFINITIONS ---
interface RefreshIndicatorProps {
  /** The current pull distance as a motion value. */
  pullProgress: ReturnType<typeof useMotionValue<number>>;
  /** Whether the component is in the "refreshing" state. */
  isRefreshing: boolean;
}

export interface PullToRefreshProps {
  children: React.ReactNode;
  onRefresh: () => Promise<unknown>;
  IndicatorComponent?: React.ComponentType<RefreshIndicatorProps>;
  pullThreshold?: number;
  className?: string;
}

// --- DEFAULT INDICATOR ---
const DefaultRefreshIndicator: React.FC<RefreshIndicatorProps> = ({
  pullProgress,
  isRefreshing,
}) => {
  const rotation = useTransform(pullProgress, [0, PULL_THRESHOLD], [0, 180]);

  return isRefreshing ? (
    <Loader2 className="h-6 w-6 animate-spin text-graphite-primary" />
  ) : (
    <motion.div style={{ rotate: rotation }}>
      <ArrowDown className="h-6 w-6 text-graphite-foreground/70" />
    </motion.div>
  );
};

// --- MAIN COMPONENT ---
export const PullToRefresh = ({
  children,
  onRefresh,
  IndicatorComponent = DefaultRefreshIndicator,
  pullThreshold = PULL_THRESHOLD,
  className,
}: PullToRefreshProps) => {
  const [isRefreshing, setIsRefreshing] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const isDraggingRef = useRef(false);
  const startTouchYRef = useRef(0);

  const y = useMotionValue(0);
  const pullProgress = useTransform(y, (v) => (v > 0 ? v : 0));

  // Dampen the pull distance for the elastic effect on the content
  const contentY = useTransform(pullProgress, (v) => v * 0.4);
  const indicatorOpacity = useTransform(
    pullProgress,
    [0, pullThreshold * 0.75],
    [0, 1]
  );
  const indicatorScale = useTransform(
    pullProgress,
    [pullThreshold * 0.5, pullThreshold],
    [0.5, 1]
  );

  const handleTouchStart = (event: TouchEvent): void => {
    if (isRefreshing) return;

    const container = containerRef.current;
    if (!container) return;

    // Only start if we're at the top and touching with a single finger
    if (container.scrollTop === 0 && event.touches.length === 1) {
      startTouchYRef.current = event.touches[0].clientY;
      isDraggingRef.current = true;
    }
  };

  const handleTouchMove = (event: TouchEvent): void => {
    if (!isDraggingRef.current || isRefreshing) return;

    const touch = event.touches[0];
    if (!touch) return;

    const currentY = touch.clientY;
    const deltaY = currentY - startTouchYRef.current;

    // Only handle downward pulls
    if (deltaY > 0) {
      // Prevent default scroll behavior when pulling down
      event.preventDefault();

      // Apply some resistance to make it feel natural
      const resistance = Math.min(deltaY * 0.6, pullThreshold * 1.2);
      y.set(resistance);
    } else {
      // If pulling up, reset and allow normal scrolling
      isDraggingRef.current = false;
      y.set(0);
    }
  };

  const handleTouchEnd = async (): Promise<void> => {
    if (!isDraggingRef.current || isRefreshing) return;

    isDraggingRef.current = false;
    const currentY = y.get();

    if (currentY >= pullThreshold) {
      setIsRefreshing(true);
      animate(y, REFRESH_Y_POSITION, {
        type: "spring",
        stiffness: 300,
        damping: 30,
      });

      try {
        await onRefresh();
      } finally {
        setIsRefreshing(false);
        animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
      }
    } else {
      animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
    }
  };

  // Mouse events for desktop support
  const handleMouseDown = (event: MouseEvent): void => {
    if (isRefreshing) return;

    const container = containerRef.current;
    if (!container) return;

    if (container.scrollTop === 0) {
      startTouchYRef.current = event.clientY;
      isDraggingRef.current = true;
    }
  };

  const handleMouseMove = (event: MouseEvent): void => {
    if (!isDraggingRef.current || isRefreshing) return;

    const currentY = event.clientY;
    const deltaY = currentY - startTouchYRef.current;

    if (deltaY > 0) {
      event.preventDefault();
      const resistance = Math.min(deltaY * 0.6, pullThreshold * 1.2);
      y.set(resistance);
    } else {
      isDraggingRef.current = false;
      y.set(0);
    }
  };

  const handleMouseUp = async (): Promise<void> => {
    if (!isDraggingRef.current || isRefreshing) return;

    isDraggingRef.current = false;
    const currentY = y.get();

    if (currentY >= pullThreshold) {
      setIsRefreshing(true);
      animate(y, REFRESH_Y_POSITION, {
        type: "spring",
        stiffness: 300,
        damping: 30,
      });

      try {
        await onRefresh();
      } finally {
        setIsRefreshing(false);
        animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
      }
    } else {
      animate(y, 0, { type: "spring", stiffness: 300, damping: 30 });
    }
  };

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // Add touch event listeners
    container.addEventListener("touchstart", handleTouchStart, {
      passive: false,
    });
    container.addEventListener("touchmove", handleTouchMove, {
      passive: false,
    });
    container.addEventListener("touchend", handleTouchEnd, { passive: true });

    // Add mouse event listeners for desktop
    container.addEventListener("mousedown", handleMouseDown);

    // Mouse move and up need to be on document to handle cases where
    // the mouse moves outside the container
    const handleDocumentMouseMove = (event: MouseEvent) =>
      handleMouseMove(event);
    const handleDocumentMouseUp = () => handleMouseUp();

    document.addEventListener("mousemove", handleDocumentMouseMove);
    document.addEventListener("mouseup", handleDocumentMouseUp);

    return () => {
      container.removeEventListener("touchstart", handleTouchStart);
      container.removeEventListener("touchmove", handleTouchMove);
      container.removeEventListener("touchend", handleTouchEnd);
      container.removeEventListener("mousedown", handleMouseDown);
      document.removeEventListener("mousemove", handleDocumentMouseMove);
      document.removeEventListener("mouseup", handleDocumentMouseUp);
    };
  }, [isRefreshing]);

  return (
    <div
      className={clsx(
        "relative w-full h-full overflow-hidden bg-graphite-background",
        className
      )}
    >
      {/* Indicator */}
      <motion.div
        className="absolute inset-x-0 top-[-50px] z-10 flex justify-center pt-4"
        style={{
          opacity: indicatorOpacity,
          scale: indicatorScale,
          y: contentY,
        }}
      >
        <div className="flex h-10 w-10 items-center justify-center rounded-full bg-graphite-card shadow-md">
          <IndicatorComponent
            pullProgress={pullProgress}
            isRefreshing={isRefreshing}
          />
        </div>
      </motion.div>

      {/* Scrollable Content */}
      <motion.div
        ref={containerRef}
        style={{
          y: contentY,
          // Remove touch-action to allow our custom handling
        }}
        className="absolute inset-0 z-0 h-full overflow-y-auto"
      >
        {children}
      </motion.div>
    </div>
  );
};
```

**Storybook Stories (`pull-to-refresh.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { motion, useTransform, type MotionValue } from "framer-motion";
import { Sun } from "lucide-react";
import { Typography } from "../typography";
import { PullToRefresh } from "./index";

const meta: Meta<typeof PullToRefresh> = {
  title: "Components/PullToRefresh",
  component: PullToRefresh,
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "An elastic pull-to-refresh component built with Framer Motion's pan gesture. It wraps scrollable content and triggers an async `onRefresh` action. Requires a container with a defined height.",
      },
    },
  },
  argTypes: {
    onRefresh: { action: "refreshed" },
    pullThreshold: {
      control: { type: "range", min: 50, max: 200, step: 10 },
    },
    children: { control: false },
    IndicatorComponent: { control: false },
  },
};

export default meta;
type Story = StoryObj<typeof PullToRefresh>;

// Helper component to generate scrollable content
const DummyContent = () => (
  <main className="p-6 pt-4">
    <Typography variant="h3">Pull Down to Refresh</Typography>
    <Typography variant="muted">
      This container is scrollable. The pull gesture only works when you are at
      the very top.
    </Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
      {Array.from({ length: 30 }).map((_, i) => (
        <div key={i} className="h-24 rounded-2xl bg-graphite-secondary" />
      ))}
    </div>
  </main>
);

// A mock async function for the onRefresh prop
const simulateRefresh = () => {
  return new Promise((resolve) => setTimeout(resolve, 2000));
};

export const Default: Story = {
  name: "1. Default Behavior",
  args: {
    onRefresh: simulateRefresh,
    pullThreshold: 100,
  },
  render: (args) => (
    <div className="w-96 h-[600px] rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
      <PullToRefresh {...args}>
        <DummyContent />
      </PullToRefresh>
    </div>
  ),
};

// --- Custom Indicator Example ---

interface CustomIndicatorProps {
  pullProgress: MotionValue<number>;
  isRefreshing: boolean;
}

const CustomWeatherIndicator = ({
  pullProgress,
  isRefreshing,
}: CustomIndicatorProps) => {
  // Use the motion value passed from the parent for transforms
  const rotation = useTransform(pullProgress, [0, 150], [0, 360]);

  return (
    <motion.div style={{ rotate: rotation }}>
      <Sun
        className={
          isRefreshing
            ? "h-6 w-6 text-yellow-500 animate-spin"
            : "h-6 w-6 text-yellow-500"
        }
      />
    </motion.div>
  );
};

export const CustomIndicator: Story = {
  name: "2. With a Custom Indicator",
  args: {
    ...Default.args,
    IndicatorComponent: CustomWeatherIndicator,
    pullThreshold: 150,
  },
  parameters: {
    docs: {
      description: {
        story:
          "You can pass any component to the `IndicatorComponent` prop. It will receive `pullProgress` (a MotionValue) and `isRefreshing` props, allowing you to create custom, fluid animations.",
      },
    },
  },
  render: (args) => (
    <div className="w-96 h-[600px] rounded-2xl border-2 border-graphite-border shadow-lg overflow-hidden">
      <PullToRefresh {...args}>
        <DummyContent />
      </PullToRefresh>
    </div>
  ),
};
```


### Component: `radio-group`

This section contains the source code for the `radio-group` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\radio-group\index.tsx`)**
```tsx
import React from "react";
import { clsx } from "clsx";

// --- Individual Radio Item ---
export interface RadioGroupItemProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  value?: string; // Added explicit value prop
}

const RadioGroupItem = React.forwardRef<HTMLInputElement, RadioGroupItemProps>(
  ({ className, id, label, ...props }, ref) => {
    const uniqueId = React.useId();
    const radioId = id || uniqueId;

    return (
      <div className="inline-flex items-center">
        <div className="relative flex h-5 w-5 items-center justify-center">
          <input
            type="radio"
            ref={ref}
            id={radioId}
            className={clsx(
              "peer h-5 w-5 shrink-0 appearance-none rounded-full border-2 transition-colors duration-200",
              // Unchecked state
              "border-graphite-border",
              // Checked state
              "checked:border-graphite-primary",
              // Focus state
              "focus:outline-none focus:ring-2 focus:ring-graphite-ring focus:ring-offset-2",
              // Disabled state
              "disabled:cursor-not-allowed disabled:opacity-50 disabled:checked:border-graphite-border",
              className
            )}
            {...props}
          />
          {/* The Inner Dot */}
          <div
            className={clsx(
              "pointer-events-none absolute h-2.5 w-2.5 rounded-full bg-graphite-primary",
              "transition-transform duration-200 ease-in-out transform scale-0 peer-checked:scale-100"
            )}
          />
        </div>
        {label && (
          <label
            htmlFor={radioId}
            className="ml-3 select-none text-sm font-medium text-graphite-foreground"
          >
            {label}
          </label>
        )}
      </div>
    );
  }
);
RadioGroupItem.displayName = "RadioGroup.Item";

// --- Radio Group Container ---
interface RadioGroupProps extends React.HTMLAttributes<HTMLDivElement> {
  label?: string;
  value?: string;
  onValueChange?: (value: string) => void;
  name?: string;
  disabled?: boolean;
}

const RadioGroup = React.forwardRef<HTMLDivElement, RadioGroupProps>(
  (
    {
      className,
      label,
      children,
      value,
      onValueChange,
      name,
      disabled,
      ...props
    },
    ref
  ) => {
    const uniqueId = React.useId();
    const groupName = name || uniqueId;
    const labelId = `radiogroup-label-${uniqueId}`;

    return (
      <div className="flex flex-col gap-2">
        {label && (
          <div
            id={labelId}
            className="mb-2 block text-sm font-medium text-graphite-primary"
          >
            {label}
          </div>
        )}
        <div
          ref={ref}
          role="radiogroup"
          aria-labelledby={label ? labelId : undefined}
          className={clsx("flex flex-col gap-3", className)}
          {...props}
        >
          {React.Children.map(children, (child) => {
            if (!React.isValidElement<RadioGroupItemProps>(child)) return child;

            // Inject props into each RadioGroup.Item
            return React.cloneElement(child, {
              name: groupName,
              checked: child.props.value === value,
              disabled: disabled || child.props.disabled,
              onChange: (e: React.ChangeEvent<HTMLInputElement>) => {
                onValueChange?.(e.currentTarget.value);
                child.props.onChange?.(e);
              },
            });
          })}
        </div>
      </div>
    );
  }
);
RadioGroup.displayName = "RadioGroup";

// Export as a compound component
const Radio = Object.assign(RadioGroup, { Item: RadioGroupItem });
export { Radio, RadioGroup, RadioGroupItem };
```

**Storybook Stories (`Radio-group.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Radio } from "./index";
import React, { useState } from "react";

const meta: Meta<typeof Radio> = {
  title: "Components/RadioGroup",
  component: Radio,
  tags: ["autodocs"],
  argTypes: {
    label: { control: "text" },
    disabled: { control: "boolean" },
  },
  // We render the group with items for all stories
  render: (args) => {
    const [plan, setPlan] = useState("basic");

    return (
      <Radio {...args} value={plan} onValueChange={setPlan}>
        <Radio.Item value="basic" label="Basic" />
        <Radio.Item value="premium" label="Premium" />
        <Radio.Item value="enterprise" label="Enterprise (Disabled)" disabled />
      </Radio>
    );
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  name: "Interactive",
  args: {
    label: "Select a Plan",
  },
};

export const Disabled: Story = {
  name: "Disabled Group",
  args: {
    label: "This entire group is disabled",
    disabled: true,
  },
};
```


### Component: `select`

This section contains the source code for the `select` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\select\index.tsx`)**
```tsx
"use client";

import * as SelectPrimitive from "@radix-ui/react-select";
import { useMediaQuery } from "@uidotdev/usehooks";
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import { Check, ChevronDown } from "lucide-react";
import React, { createContext, useContext, useRef, useState } from "react";
import useRipple from "use-ripple-hook";
import { Button } from "../button";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "../dialog";

// --- CONTEXT ---
interface SelectContextProps {
  variant: "primary" | "secondary";
  shape: "full" | "minimal" | "sharp";
  size: "sm" | "md" | "lg";
}

const SelectContext = createContext<SelectContextProps>({
  variant: "primary",
  shape: "minimal",
  size: "md",
});

const useSelectContext = () => useContext(SelectContext);

// --- CVA VARIANTS ---
const selectTriggerVariants = cva(
  "flex items-center justify-between transition-all duration-200 w-full px-4 border-2 text-left",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
      },
      shape: {
        full: "rounded-full",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
      size: {
        sm: "h-10 text-sm",
        md: "h-12 text-base",
        lg: "h-14 text-lg",
      },
      isErrored: { true: "" },
      disabled: {
        true: "bg-graphite-secondary opacity-50 cursor-not-allowed",
      },
    },
    compoundVariants: [
      {
        variant: "primary",
        isErrored: false,
        className:
          "border-graphite-border data-[state=open]:border-graphite-primary",
      },
      {
        variant: "secondary",
        isErrored: false,
        className:
          "border-transparent data-[state=open]:border-graphite-primary",
      },
      {
        isErrored: true,
        className: "border-red-500 data-[state=open]:border-red-600",
      },
    ],
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
      size: "md",
    },
  }
);

const selectContentVariants = cva(
  "relative z-50 min-w-[8rem] overflow-hidden border shadow-md",
  {
    variants: {
      variant: {
        primary:
          "bg-graphite-card text-graphite-foreground border-graphite-border",
        secondary:
          "bg-graphite-secondary text-graphite-secondaryForeground border-transparent",
      },
      shape: {
        full: "rounded-3xl",
        minimal: "rounded-xl",
        sharp: "rounded-none",
      },
    },
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
    },
  }
);

const selectItemVariants = cva(
  "relative flex w-full cursor-pointer select-none items-center rounded-lg pr-2 pl-8 outline-none overflow-hidden transition-colors duration-150 ease-in-out data-[highlighted]:bg-graphite-secondary/80 focus:bg-graphite-secondary/80 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
  {
    variants: {
      size: {
        sm: "py-2 text-sm",
        md: "py-2 text-base",
        lg: "py-2.5 text-lg",
      },
      shape: {
        full: "",
        minimal: "",
        sharp: "!rounded-none",
      },
    },
    defaultVariants: {
      size: "md",
    },
  }
);

// --- PRIMITIVE COMPONENTS (For Desktop Popover) ---

const SelectGroup = SelectPrimitive.Group;
const SelectValue = SelectPrimitive.Value;

interface SelectProps extends SelectPrimitive.SelectProps {
  children: React.ReactNode;
  variant?: SelectContextProps["variant"];
  shape?: SelectContextProps["shape"];
  size?: SelectContextProps["size"];
}

const Select: React.FC<SelectProps> = ({
  children,
  variant = "primary",
  shape = "minimal",
  size = "md",
  ...props
}) => {
  return (
    <SelectContext.Provider value={{ variant, shape, size }}>
      <SelectPrimitive.Root {...props}>{children}</SelectPrimitive.Root>
    </SelectContext.Provider>
  );
};

interface SelectTriggerProps
  extends React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger> {
  error?: string;
  variant?: VariantProps<typeof selectTriggerVariants>["variant"];
  shape?: VariantProps<typeof selectTriggerVariants>["shape"];
  size?: VariantProps<typeof selectTriggerVariants>["size"];
}

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  SelectTriggerProps
>(
  (
    { className, children, variant, shape, size, error, disabled, ...props },
    ref
  ) => {
    const context = useSelectContext();
    return (
      <SelectPrimitive.Trigger
        ref={ref}
        disabled={disabled}
        className={selectTriggerVariants({
          variant: variant || context.variant,
          shape: shape || context.shape,
          size,
          isErrored: !!error,
          disabled,
          className,
        })}
        {...props}
      >
        {children}
        <SelectPrimitive.Icon asChild>
          <ChevronDown className="h-4 w-4 opacity-50" />
        </SelectPrimitive.Icon>
      </SelectPrimitive.Trigger>
    );
  }
);
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "item-aligned", ...props }, ref) => {
  const { variant, shape } = useSelectContext();
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        ref={ref}
        className={clsx(
          selectContentVariants({ variant, shape }),
          position === "popper"
            ? "data-[state=open]:animate-menu-enter data-[state=closed]:animate-menu-exit w-[var(--radix-select-trigger-width)]"
            : "data-[state=open]:animate-select-enter data-[state=closed]:animate-select-exit",
          "data-[side=bottom]:origin-top data-[side=top]:origin-bottom ",
          className
        )}
        position={position}
        {...props}
      >
        <SelectPrimitive.Viewport
          className={clsx(
            "p-1",
            // Only apply max-height and fade mask for popper position (which supports scrolling)
            position === "popper" && [
              "max-h-64",
              "[mask-image:linear-gradient(to_bottom,transparent,black_1rem,black_calc(100%-1rem),transparent)]",
            ],
            position === "popper" && "w-full"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  );
});
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => {
  const { shape, variant, size } = useSelectContext();
  const localRef = useRef<HTMLDivElement>(null);
  const rippleColor =
    variant === "primary" ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)";

  const [, event] = useRipple({
    ref: localRef,
    color: rippleColor,
    duration: 400,
    disabled: props.disabled,
  });

  React.useImperativeHandle(ref, () => localRef.current as HTMLDivElement);

  return (
    <SelectPrimitive.Item
      ref={localRef}
      onPointerDown={event}
      className={clsx(selectItemVariants({ size, shape }), className)}
      {...props}
    >
      <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <Check className="h-4 w-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText className="truncate">
        {children}
      </SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  );
});
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => {
  const { size } = useSelectContext();
  return (
    <SelectPrimitive.Label
      ref={ref}
      className={clsx(
        "py-1.5 pl-8 pr-2 font-semibold",
        {
          "text-sm": size === "sm",
          "text-base": size === "md",
          "text-lg": size === "lg",
        },
        className
      )}
      {...props}
    />
  );
});
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={clsx("-mx-1 my-1 h-px bg-graphite-border", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

// --- HELPER COMPONENT FOR MOBILE DIALOG ITEMS ---
interface DialogSelectItemProps {
  item: { value: string; label: string; disabled?: boolean };
  isSelected: boolean;
  onSelect: (value: string) => void;
  variant: "primary" | "secondary";
}

const DialogSelectItem: React.FC<DialogSelectItemProps> = ({
  item,
  isSelected,
  onSelect,
  variant,
}) => {
  const localRef = useRef<HTMLButtonElement>(null);
  const rippleColor =
    variant === "primary" ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)";

  const [, event] = useRipple({
    ref: localRef,
    color: rippleColor,
    duration: 400,
    disabled: item.disabled,
  });

  return (
    <button
      ref={localRef}
      type="button"
      onPointerDown={event}
      disabled={item.disabled}
      onClick={() => onSelect(item.value)}
      className={clsx(
        "relative flex w-full cursor-pointer select-none items-center rounded-lg py-3 pl-8 pr-2 text-left text-sm outline-none overflow-hidden",
        "transition-colors duration-150 ease-in-out",
        "focus:bg-graphite-secondary/80",
        isSelected && "font-semibold text-graphite-primary",
        "disabled:pointer-events-none disabled:opacity-50"
      )}
    >
      <span className="relative z-10 flex items-center w-full">
        {isSelected && (
          <span className="absolute -left-6 flex h-3.5 w-3.5 items-center justify-center">
            <Check className="h-4 w-4" />
          </span>
        )}
        <span className="truncate">{item.label}</span>
      </span>
    </button>
  );
};

// --- MAIN WRAPPER COMPONENT ---

interface SelectWrapperProps
  extends Omit<SelectProps, "children" | "onChange">,
    VariantProps<typeof selectTriggerVariants> {
  label?: string;
  error?: string;
  placeholder?: string;
  items: { value: string; label: string; disabled?: boolean }[];
  id?: string;
  contentPosition?: React.ComponentProps<typeof SelectContent>["position"];
  onValueChange?: (value: string) => void;
  value?: string;
}

const SelectInput = React.forwardRef<HTMLButtonElement, SelectWrapperProps>(
  (
    {
      label,
      error,
      placeholder,
      items,
      id,
      variant = "primary",
      shape = "minimal",
      size = "md",
      disabled,
      contentPosition = "item-aligned",
      value,
      onValueChange,
      ...props
    },
    ref
  ) => {
    const isMobile = useMediaQuery("(max-width: 768px)");
    const uniqueId = React.useId();
    const [isOpen, setIsOpen] = useState(false);
    const [tempValue, setTempValue] = useState(value);
    const selectId = id || uniqueId;

    // --- Mobile Dialog Version ---
    if (isMobile && contentPosition === "popper") {
      const handleOpenChange = (open: boolean) => {
        if (open) {
          setTempValue(value);
        }
        setIsOpen(open);
      };

      const handleConfirm = () => {
        if (tempValue !== undefined) {
          onValueChange?.(tempValue);
        }
        setIsOpen(false);
      };

      const displayLabel =
        items.find((item) => item.value === value)?.label || placeholder;

      return (
        <div className="w-full flex flex-col gap-2">
          {label && (
            <div className="block text-sm font-medium text-graphite-primary">
              {label}
            </div>
          )}
          <Dialog open={isOpen} onOpenChange={handleOpenChange}>
            <DialogTrigger asChild>
              <button
                ref={ref}
                type="button"
                id={selectId}
                disabled={disabled}
                className={selectTriggerVariants({
                  variant,
                  shape,
                  size,
                  isErrored: !!error,
                  disabled,
                })}
              >
                <span className="truncate">{displayLabel}</span>
                <ChevronDown className="h-4 w-4 opacity-50" />
              </button>
            </DialogTrigger>
            <DialogContent
              shape={shape}
              className="fixed bottom-0 m-0 w-full max-w-full rounded-b-none rounded-t-2xl p-4"
            >
              <DialogHeader className="text-left">
                <DialogTitle>{label || placeholder}</DialogTitle>
              </DialogHeader>
              <div
                className={clsx(
                  "mt-4 max-h-[40vh] overflow-y-auto ",
                  "[mask-image:linear-gradient(to_bottom,transparent,black_1rem,black_calc(100%-1rem),transparent)]"
                )}
              >
                {items.map((item) => (
                  <DialogSelectItem
                    key={item.value}
                    item={item}
                    isSelected={tempValue === item.value}
                    onSelect={setTempValue}
                    variant={variant}
                  />
                ))}
              </div>
              <DialogFooter className="flex justify-end gap-4">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setIsOpen(false)}
                >
                  Cancel
                </Button>
                <Button size="sm" variant="primary" onClick={handleConfirm}>
                  Done
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
          {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
        </div>
      );
    }

    // --- Desktop Popover / Item-Aligned Version ---
    return (
      <div className="w-full flex flex-col gap-2">
        {label && (
          <label
            htmlFor={selectId}
            className="block text-sm font-medium text-graphite-primary"
          >
            {label}
          </label>
        )}
        <Select
          disabled={disabled}
          variant={variant}
          shape={shape}
          size={size}
          value={value}
          onValueChange={onValueChange}
          {...props}
        >
          <SelectTrigger
            id={selectId}
            ref={ref}
            size={size}
            error={error}
            disabled={disabled}
          >
            <span className="truncate">
              <SelectValue placeholder={placeholder} />
            </span>
          </SelectTrigger>
          <SelectContent position={contentPosition}>
            {items.map((item) => (
              <SelectItem
                key={item.value}
                value={item.value}
                disabled={item.disabled}
              >
                {item.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        {error && <p className="mt-2 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);
SelectInput.displayName = "SelectInput";

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectInput,
};
```

**Storybook Stories (`Select.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { SelectInput } from "./index";

const meta: Meta<typeof SelectInput> = {
  title: "Components/Select",
  component: SelectInput,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    label: { control: "text" },
    placeholder: { control: "text" },
    disabled: { control: "boolean" },
    error: { control: "text" },
    contentPosition: {
      control: "select",
      options: ["item-aligned", "popper"],
      description: "Controls the positioning and animation of the dropdown.",
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

const fruitItems = [
  {
    value: "apple loremfwekfkweiofkjweifjwoeifoifwejfiowejfiowejfowiejfwi",
    label: "Apple loremfwekfkweiofkjweifjwoeifoifwejfiowejfiowejfowiejfwi",
  },
  { value: "banana", label: "Banana" },
  { value: "blueberry", label: "Blueberry" },
  { value: "grapes", label: "Grapes" },
  { value: "pineapple", label: "Pineapple", disabled: true },
  { value: "strawberry", label: "Strawberry" },
  { value: "orange", label: "Orange" },
  { value: "mango", label: "Mango" },
  { value: "kiwi", label: "Kiwi" },
  { value: "peach", label: "Peach" },
  { value: "pear", label: "Pear" },
  { value: "watermelon", label: "Watermelon" },
  { value: "cherry", label: "Cherry" },
  { value: "raspberry", label: "Raspberry" },
  { value: "lemon", label: "Lemon" },
];
export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
    size: "md",
    label: "Favorite Fruit",
    placeholder: "Select a fruit...",
    items: fruitItems,
    contentPosition: "item-aligned", // Default
  },
  render: (args) => {
    const [value, setValue] = useState("");
    return <SelectInput {...args} value={value} onValueChange={setValue} />;
  },
};

export const PopperPosition: Story = {
  name: "Popper Position",
  args: {
    ...Default.args,
    label: "Popper Positioned Select",
    placeholder: "Select a fruit...",
    contentPosition: "popper",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `contentPosition` is set to `popper`, the content detaches and uses a scale/fade animation, similar to a dropdown menu.",
      },
    },
  },
  render: (args) => {
    const [value, setValue] = useState("");
    return <SelectInput {...args} value={value} onValueChange={setValue} />;
  },
};

// ... keep your other stories like AllSizes, AllVariantsAndShapes, and AllStates
export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-col gap-6 max-w-sm">
      <SelectInput
        size="sm"
        label="Small"
        placeholder="Select size..."
        items={fruitItems}
      />
      <SelectInput
        size="md"
        label="Medium (Default)"
        placeholder="Select size..."
        items={fruitItems}
      />
      <SelectInput
        size="lg"
        label="Large"
        placeholder="Select size..."
        items={fruitItems}
      />
    </div>
  ),
};

export const AllVariantsAndShapes: Story = {
  name: "All Variants & Shapes",
  render: () => (
    <div className="flex flex-col gap-8 max-w-sm">
      <div>
        <h3 className="font-bold mb-4">Primary Variant</h3>
        <div className="flex flex-col gap-4">
          <SelectInput
            variant="primary"
            shape="full"
            placeholder="Full Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="primary"
            shape="minimal"
            placeholder="Minimal Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="primary"
            shape="sharp"
            placeholder="Sharp Shape"
            items={fruitItems}
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary Variant</h3>
        <div className="flex flex-col gap-4">
          <SelectInput
            variant="secondary"
            shape="full"
            placeholder="Full Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="secondary"
            shape="minimal"
            placeholder="Minimal Shape"
            items={fruitItems}
          />
          <SelectInput
            variant="secondary"
            shape="sharp"
            placeholder="Sharp Shape"
            items={fruitItems}
          />
        </div>
      </div>
    </div>
  ),
};

export const AllStates: Story = {
  name: "All States",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl">
      <div className="flex flex-col gap-4">
        <h3 className="font-bold mb-2">Primary States</h3>
        <SelectInput
          variant="primary"
          label="Default"
          placeholder="Select..."
          items={fruitItems}
        />
        <SelectInput
          variant="primary"
          label="With Value"
          defaultValue="apple"
          items={fruitItems}
        />
        <SelectInput
          variant="primary"
          label="Error State"
          error="Please select a fruit."
          items={fruitItems}
        />
        <SelectInput
          variant="primary"
          label="Disabled"
          placeholder="Cannot select"
          disabled
          items={fruitItems}
        />
      </div>
      <div className="flex flex-col gap-4">
        <h3 className="font-bold mb-2">Secondary States</h3>
        <SelectInput
          variant="secondary"
          label="Default"
          placeholder="Select..."
          items={fruitItems}
        />
        <SelectInput
          variant="secondary"
          label="With Value"
          defaultValue="banana"
          items={fruitItems}
        />
        <SelectInput
          variant="secondary"
          label="Error State"
          error="Please select a fruit."
          items={fruitItems}
        />
        <SelectInput
          variant="secondary"
          label="Disabled"
          placeholder="Cannot select"
          disabled
          items={fruitItems}
        />
      </div>
    </div>
  ),
};
```


### Component: `shallow-router`

This section contains the source code for the `shallow-router` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\shallow-router\index.tsx`)**
```tsx
import React, {
  createContext,
  type HTMLAttributes,
  type ReactNode,
  useContext,
  useMemo,
} from "react";
import useShallowRouter from "../../hooks/useShallowRouter";

// --- TYPE DEFINITIONS ---

type RouterMode = "search" | "pathname";

interface RouterOptions {
  mode: RouterMode;
  paramName: string;
  basePath: string;
}

interface ShallowRouterContextType {
  router: ReturnType<typeof useShallowRouter>;
  options: RouterOptions;
}

// --- CONTEXT CREATION & HOOKS ---

const ShallowRouterContext = createContext<ShallowRouterContextType | null>(
  null
);

/**
 * A custom hook to consume the ShallowRouter context.
 * Provides access to routing functions like `push`, `replace`, and the current `path`.
 *
 * @returns {ReturnType<typeof useShallowRouter>} The router instance.
 * @throws {Error} If used outside of a `<ShallowRouter>` provider.
 */
export const useRouter = (): ReturnType<typeof useShallowRouter> => {
  const context = useContext(ShallowRouterContext);
  if (!context) {
    throw new Error("useRouter must be used within a <ShallowRouter> provider");
  }
  return context.router;
};

/**
 * A custom hook to access the configuration options of the nearest ShallowRouter provider.
 * Useful for components that need to behave differently based on the routing mode.
 *
 * @returns {RouterOptions} The router's configuration options.
 * @throws {Error} If used outside of a `<ShallowRouter>` provider.
 */
export const useRouterOptions = (): RouterOptions => {
  const context = useContext(ShallowRouterContext);
  if (!context) {
    throw new Error(
      "useRouterOptions must be used within a <ShallowRouter> provider"
    );
  }
  return context.options;
};

// --- MAIN PROVIDER COMPONENT ---

interface ShallowRouterProps {
  children: ReactNode;
  mode?: RouterMode;
  paramName?: string;
  basePath?: string;
}

/**
 * A provider component that initializes the shallow router and makes its
 * state and methods available to all descendant components.
 */
export const ShallowRouter: React.FC<ShallowRouterProps> = ({
  children,
  mode = "search",
  paramName = "path",
  basePath = "/",
}) => {
  const router = useShallowRouter({ mode, paramName, basePath });
  const options = useMemo(
    () => ({ mode, paramName, basePath }),
    [mode, paramName, basePath]
  );

  const contextValue = useMemo(() => ({ router, options }), [router, options]);

  return (
    <ShallowRouterContext.Provider value={contextValue}>
      {children}
    </ShallowRouterContext.Provider>
  );
};

// --- NEW: ShallowRoute Component ---
interface ShallowRouteProps {
  /** The path to match. Supports a trailing wildcard `*` for prefix matching. */
  path: string;
  children: ReactNode;
}

/**
 * Conditionally renders its children only when its `path` prop matches the current router path.
 * Supports a trailing wildcard `*` for prefix matching (e.g., `/users/*`).
 */
export const ShallowRoute: React.FC<ShallowRouteProps> = ({
  path,
  children,
}) => {
  const { path: currentPath } = useRouter();

  const isWildcard = path.endsWith("/*");
  const basePath = isWildcard ? path.slice(0, -2) : path;

  const isActive = isWildcard
    ? currentPath.startsWith(basePath)
    : currentPath === path;

  return isActive ? <>{children}</> : null;
};

// --- NEW: ShallowPage Component ---
interface ShallowPageProps extends HTMLAttributes<HTMLDivElement> {
  /** The path that this page corresponds to. Used by `ShallowSwitch` to identify the active page. */
  path: string;
}

/**
 * A simple container for a page's content.
 * It should be used as a direct child of `ShallowSwitch`.
 */
export const ShallowPage = React.forwardRef<HTMLDivElement, ShallowPageProps>(
  ({ children, path, ...props }, ref) => {
    return (
      <div ref={ref} key={path} {...props}>
        {children}
      </div>
    );
  }
);
ShallowPage.displayName = "ShallowPage";

// --- NEW: ShallowSwitch Component ---
interface ShallowSwitchProps {
  children:
    | React.ReactElement<ShallowPageProps>
    | React.ReactElement<ShallowPageProps>[];
}

/**
 * Manages rendering `<ShallowPage>` components. It identifies the active
 * page based on the current route and renders only that page.
 */
export const ShallowSwitch: React.FC<ShallowSwitchProps> = ({ children }) => {
  const { path } = useRouter();

  const pages = React.Children.toArray(children).filter(
    (child): child is React.ReactElement<ShallowPageProps> =>
      React.isValidElement(child) && child.type === ShallowPage
  );

  const activePage = pages.find((page) => page.props.path === path) || null;

  return <>{activePage}</>;
};
```

**Storybook Stories (`shallow-router.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { ArrowLeft } from "lucide-react";
import { Button } from "../button";
import { ButtonGroup } from "../button-group";
import { Card } from "../card";
import { IconButton } from "../icon-button";
import { Typography } from "../typography";
import {
  ShallowPage,
  ShallowRoute,
  ShallowRouter,
  ShallowSwitch,
  useRouter,
  useRouterOptions,
} from "./index";

const meta: Meta<typeof ShallowRouter> = {
  title: "Components/ShallowRouter",
  component: ShallowRouter,
  subcomponents: { ShallowRoute, ShallowSwitch, ShallowPage },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A provider for the `useShallowRouter` hook. It enables shallow, client-side navigation using either URL search parameters or the URL pathname, without causing a full page reload. It also includes declarative components like `<ShallowRoute>`, `<ShallowSwitch>`, and `<ShallowPage>` for building navigable UIs.",
      },
    },
  },
  argTypes: {
    mode: {
      control: "select",
      options: ["search", "pathname"],
    },
    paramName: {
      control: "text",
      if: { arg: "mode", eq: "search" },
    },
    basePath: {
      control: "text",
      if: { arg: "mode", eq: "pathname" },
    },
  },
};

export default meta;
type Story = StoryObj<typeof ShallowRouter>;

// --- Demo Components ---

const NavBar = () => {
  const { path, push } = useRouter();
  const { mode } = useRouterOptions();

  return (
    <div className="mb-4 p-4 bg-gray-100 rounded-xl">
      <Typography variant="small" className="font-bold mb-2">
        Navigation (mode: {mode})
      </Typography>
      <ButtonGroup shape="minimal">
        <Button
          size="sm"
          variant={path === "/" ? "primary" : "secondary"}
          onClick={() => push("/")}
        >
          Home
        </Button>
        <Button
          size="sm"
          variant={path === "/profile" ? "primary" : "secondary"}
          onClick={() => push("/profile")}
        >
          Profile
        </Button>
        <Button
          size="sm"
          variant={path === "/settings" ? "primary" : "secondary"}
          onClick={() => push("/settings")}
        >
          Settings
        </Button>
      </ButtonGroup>
    </div>
  );
};

const Header = ({ title }: { title: string }) => {
  const { path, goBack } = useRouter();
  return (
    <div className="flex items-center gap-2 mb-4">
      {path !== "/" && (
        <IconButton
          variant="ghost"
          size="sm"
          onClick={goBack}
          aria-label="Go back"
        >
          <ArrowLeft />
        </IconButton>
      )}
      <Typography variant="h4">{title}</Typography>
    </div>
  );
};

// --- Stories ---

export const BasicRouting: Story = {
  name: "1. Basic Routing with <ShallowRoute>",
  args: {
    mode: "search",
  },
  render: (args) => (
    <ShallowRouter {...args}>
      <Card className="w-96">
        <NavBar />
        <div className="mt-4">
          <ShallowRoute path="/">
            <Typography variant="large">Welcome Home!</Typography>
            <Typography variant="p">
              This content is rendered when the path is exactly `/`.
            </Typography>
          </ShallowRoute>
          <ShallowRoute path="/profile">
            <Typography variant="large">User Profile</Typography>
            <Typography variant="p">
              This is the user's profile page content.
            </Typography>
          </ShallowRoute>
          <ShallowRoute path="/settings">
            <Typography variant="large">Application Settings</Typography>
            <Typography variant="p">
              Adjust your application settings here.
            </Typography>
          </ShallowRoute>
        </div>
      </Card>
    </ShallowRouter>
  ),
};

export const PageSwitching: Story = {
  name: "2. Page Switching with <ShallowSwitch>",
  args: {
    mode: "search",
    paramName: "view",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `<ShallowSwitch>` component manages a collection of `<ShallowPage>` components. It ensures only the active page is rendered, switching instantly as the route changes.",
      },
    },
  },
  render: (args) => (
    <ShallowRouter {...args}>
      <Card className="w-96 h-80 flex flex-col">
        <NavBar />
        <div className="flex-1 relative">
          <ShallowSwitch>
            <ShallowPage path="/">
              <Header title="Home" />
              <Typography variant="p">
                This is the main landing page. Navigate to other sections using
                the buttons above.
              </Typography>
            </ShallowPage>
            <ShallowPage path="/profile">
              <Header title="Profile" />
              <Typography variant="p">
                Here you can view and edit your profile details. All changes are
                saved automatically.
              </Typography>
            </ShallowPage>
            <ShallowPage path="/settings">
              <Header title="Settings" />
              <Typography variant="p">
                Customize your experience. Toggle notifications, change your
                theme, and set your language.
              </Typography>
            </ShallowPage>
          </ShallowSwitch>
        </div>
      </Card>
    </ShallowRouter>
  ),
};
```


### Component: `sheet`

This section contains the source code for the `sheet` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\sheet\index.tsx`)**
```tsx
"use client";

import { useMediaQuery } from "@uidotdev/usehooks";
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import React, { createContext, useContext } from "react";
import { Drawer as VaulDrawer } from "vaul";

// --- Context (Unchanged) ---
interface SheetContextProps {
  mode: "normal" | "detached";
  shape: "full" | "minimal" | "sharp";
  hasSnapPoints: boolean;
  direction: "top" | "bottom" | "left" | "right";
}

const SheetContext = createContext<SheetContextProps>({
  mode: "normal",
  shape: "full",
  hasSnapPoints: false,
  direction: "bottom",
});

const useSheetContext = () => useContext(SheetContext);

// --- MODIFIED: Root Component ---
// Added the `forceBottomSheet` prop.
type SheetProps = React.ComponentProps<typeof VaulDrawer.Root> & {
  mode?: "normal" | "detached";
  shape?: "full" | "minimal" | "sharp";
  side?: "left" | "right";
  /**
   * If true, the sheet will always render as a bottom sheet,
   * overriding the responsive behavior on desktop viewports.
   * @default false
   */
  forceBottomSheet?: boolean; // --- THIS IS THE NEW PROP ---
};

const SheetRoot: React.FC<SheetProps> = ({
  mode = "normal",
  shape = "full",
  side = "right",
  forceBottomSheet = false, // --- NEW PROP WITH DEFAULT ---
  snapPoints,
  activeSnapPoint,
  setActiveSnapPoint,
  ...props
}) => {
  const isDesktop = useMediaQuery("(min-width: 768px)");

  // --- MODIFIED LOGIC ---
  // Determine if we should render as a side sheet. This is only true if:
  // 1. The viewport is desktop-sized.
  // 2. The `forceBottomSheet` prop is false.
  const renderAsSideSheet = isDesktop && !forceBottomSheet;

  const direction = renderAsSideSheet ? side : "bottom";
  // --- END OF MODIFIED LOGIC ---

  return (
    <SheetContext.Provider
      value={{
        mode,
        shape,
        // Disable snap points if we are rendering as a side sheet
        hasSnapPoints: renderAsSideSheet
          ? false
          : !!snapPoints && snapPoints.length > 0,
        direction,
      }}
    >
      <VaulDrawer.Root
        direction={direction}
        {...props}
        // Pass snap points only when not rendering as a side sheet
        snapPoints={renderAsSideSheet ? undefined : snapPoints}
        activeSnapPoint={renderAsSideSheet ? undefined : activeSnapPoint}
        setActiveSnapPoint={renderAsSideSheet ? undefined : setActiveSnapPoint}
      />
    </SheetContext.Provider>
  );
};
SheetRoot.displayName = "Sheet";

// --- RE-EXPORTED PRIMITIVES (Unchanged) ---
const SheetTrigger = VaulDrawer.Trigger;
const SheetClose = VaulDrawer.Close;
const SheetPortal = VaulDrawer.Portal;
const SheetTitle = VaulDrawer.Title;
const SheetDescription = VaulDrawer.Description;

// --- CONTENT & OTHER COMPONENTS (Unchanged) ---
// (Your existing SheetContent, SheetHeader, SheetFooter, and SheetGrabber code remains here)
const contentVariants = cva(
  "fixed z-50 flex flex-col bg-graphite-card shadow-lg",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0",
        bottom: "inset-x-0 bottom-0 max-h-[96%]",
        left: "inset-y-0 left-0 w-full max-w-sm",
        right: "inset-y-0 right-0 w-full max-w-sm",
      },
      height: {
        snap: "h-full",
        auto: "h-auto",
      },
      shape: {
        full: "",
        minimal: "",
        sharp: "",
      },
      mode: {
        normal: "",
        detached: "",
      },
    },
    compoundVariants: [
      { side: "bottom", mode: "normal", className: "mx-auto max-w-xl" },
      {
        side: "bottom",
        mode: "detached",
        className: "inset-x-4 bottom-4 mx-auto max-w-lg",
      },
      {
        side: "bottom",
        mode: "normal",
        shape: "full",
        className: "rounded-t-3xl",
      },
      {
        side: "bottom",
        mode: "normal",
        shape: "minimal",
        className: "rounded-t-lg",
      },
      {
        side: "bottom",
        mode: "normal",
        shape: "sharp",
        className: "rounded-t-none",
      },
      {
        side: "bottom",
        mode: "detached",
        shape: "full",
        className: "rounded-2xl",
      },
      {
        side: "bottom",
        mode: "detached",
        shape: "minimal",
        className: "rounded-lg",
      },
      {
        side: "bottom",
        mode: "detached",
        shape: "sharp",
        className: "rounded-none",
      },
      {
        side: "left",
        shape: "full",
        mode: "normal",
        className: "rounded-r-2xl",
      },
      {
        side: "left",
        shape: "minimal",
        mode: "normal",
        className: "rounded-r-lg",
      },
      {
        side: "left",
        shape: "sharp",
        mode: "normal",
        className: "rounded-r-none",
      },
      {
        side: "left",
        shape: "full",
        mode: "detached",
        className: "left-4 rounded-2xl",
      },
      {
        side: "left",
        shape: "minimal",
        mode: "detached",
        className: "left-4 rounded-lg",
      },
      {
        side: "left",
        shape: "sharp",
        mode: "detached",
        className: "left-4 rounded-none",
      },
      {
        side: "right",
        shape: "full",
        mode: "normal",
        className: "rounded-l-2xl",
      },
      {
        side: "right",
        shape: "minimal",
        mode: "normal",
        className: "rounded-l-lg",
      },
      {
        side: "right",
        shape: "sharp",
        mode: "normal",
        className: "rounded-l-none",
      },
      {
        side: "right",
        shape: "full",
        mode: "detached",
        className: "top-4 bottom-4 right-4 rounded-2xl",
      },
      {
        side: "right",
        shape: "minimal",
        mode: "detached",
        className: "top-4 bottom-4 right-4 rounded-lg",
      },
      {
        side: "right",
        shape: "sharp",
        mode: "detached",
        className: "top-4 bottom-4 right-4 rounded-none",
      },
    ],
    defaultVariants: {
      shape: "full",
      mode: "normal",
    },
  }
);
type SheetContentProps = React.ComponentProps<typeof VaulDrawer.Content> &
  VariantProps<typeof contentVariants>;
const SheetContent = React.forwardRef<
  React.ElementRef<typeof VaulDrawer.Content>,
  SheetContentProps
>(({ className, shape: shapeProp, ...props }, ref) => {
  const {
    mode,
    shape: shapeContext,
    hasSnapPoints,
    direction,
  } = useSheetContext();

  const shape = shapeProp || shapeContext;

  const style =
    mode === "detached"
      ? ({ "--vaul-after-display": "0" } as React.CSSProperties)
      : {};

  return (
    <SheetPortal>
      <VaulDrawer.Overlay className="fixed inset-0 z-50 bg-black/50" />
      <VaulDrawer.Content
        ref={ref}
        style={{ ...props.style, ...style }}
        className={clsx(
          contentVariants({
            side: direction,
            mode,
            shape,
            height: direction === "bottom" && hasSnapPoints ? "snap" : "auto",
          }),
          className
        )}
        {...props}
      />
    </SheetPortal>
  );
});
SheetContent.displayName = "Sheet.Content";
const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={clsx(
      "flex flex-col gap-1 p-6 text-center sm:text-left",
      className
    )}
    {...props}
  />
);
SheetHeader.displayName = "Sheet.Header";
const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={clsx("mt-auto flex flex-col gap-2 p-6", className)}
    {...props}
  />
);
SheetFooter.displayName = "Sheet.Footer";
const SheetGrabber = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => {
  const { direction } = useSheetContext();
  if (direction !== "bottom") {
    return null;
  }
  return (
    <div className="flex-shrink-0 p-4">
      <div
        className={clsx(
          "mx-auto h-1.5 w-12 flex-shrink-0 rounded-full bg-graphite-border",
          className
        )}
        {...props}
      />
    </div>
  );
};
SheetGrabber.displayName = "Sheet.Grabber";

export const Sheet = Object.assign(SheetRoot, {
  Trigger: SheetTrigger,
  Content: SheetContent,
  Close: SheetClose,
  Title: SheetTitle,
  Description: SheetDescription,
  Header: SheetHeader,
  Footer: SheetFooter,
  Grabber: SheetGrabber,
});
```

**Storybook Stories (`sheet.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import clsx from "clsx";
import { useState } from "react";
import { Button } from "../button";
import { Typography } from "../typography";
import { Sheet } from "./index"; // Assuming your component file is named index.tsx

const meta: Meta<typeof Sheet> = {
  title: "Components/Sheet",
  component: Sheet,
  tags: ["autodocs"],
  parameters: {
    layout: "fullscreen",
    docs: {
      description: {
        component:
          "A versatile and responsive sheet component. It renders as a bottom sheet on mobile viewports and intelligently transitions to a side sheet (drawer) on desktop. This behavior can be overridden.",
      },
    },
  },
  argTypes: {
    side: {
      control: "select",
      options: ["left", "right"],
      description:
        "Determines which side the sheet appears from on desktop viewports.",
    },
    mode: {
      control: "select",
      options: ["normal", "detached"],
      description:
        "Controls the visual style ('normal' vs. floating 'detached').",
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
      description: "Controls the border-radius of the sheet.",
    },
    forceBottomSheet: {
      control: "boolean",
      description:
        "If true, forces the component to render as a bottom sheet on all screen sizes.",
    },
    // Vaul-specific props
    snapPoints: {
      control: "object",
      description: "Array of snap points for the bottom sheet mode.",
    },
    fadeFromIndex: {
      control: "number",
      description:
        "Required when snapPoints are used. Snap points are disabled on desktop.",
    },
    dismissible: {
      control: "boolean",
    },
    // We don't control these directly but show their action
    activeSnapPoint: { control: false },
    setActiveSnapPoint: { action: "snapPointChanged" },
  },
};

export default meta;
type Story = StoryObj<typeof Sheet>;

// Helper for rich, scrollable content
const DummyContent = () => (
  <div className="flex-1 overflow-y-auto p-6">
    <Typography variant="h4" className="mb-2">
      Sheet Content
    </Typography>
    <Typography variant="p">
      This is the main content area. If the content becomes too long, this area
      will automatically become scrollable.
    </Typography>
    <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2">
      {Array.from({ length: 12 }).map((_, i) => (
        <div key={`dummy-item-${i}`} className="h-24 rounded-2xl bg-black/5" />
      ))}
    </div>
  </div>
);

// --- STORIES ---

export const ResponsiveBehavior: Story = {
  name: "1. Responsive Behavior (Default)",
  args: {
    side: "right",
    mode: "normal",
    shape: "full",
  },
  parameters: {
    docs: {
      description: {
        story:
          "**This is the primary use case.** By default, the component is a **bottom sheet** on mobile and a **side sheet** on desktop. Resize your browser window to see the transition.",
      },
    },
  },
  render: (args) => (
    <div className="flex p-12 items-center justify-center bg-graphite-background">
      <Sheet {...args}>
        <Sheet.Trigger asChild>
          <Button>Open Sheet</Button>
        </Sheet.Trigger>
        <Sheet.Content>
          <Sheet.Grabber />
          <Sheet.Header>
            <Sheet.Title>
              <Typography variant="h3">Responsive Sheet</Typography>
            </Sheet.Title>
            <Sheet.Description>
              <Typography variant="muted">
                Adapts to your screen size.
              </Typography>
            </Sheet.Description>
          </Sheet.Header>
          <DummyContent />
          <Sheet.Footer>
            <Button size="lg">Save Changes</Button>
            <Sheet.Close asChild>
              <Button size="lg" variant="secondary">
                Close
              </Button>
            </Sheet.Close>
          </Sheet.Footer>
        </Sheet.Content>
      </Sheet>
    </div>
  ),
};

export const ForceBottomSheet: Story = {
  name: "2. Force Bottom Sheet on Desktop",
  args: {
    ...ResponsiveBehavior.args,
    forceBottomSheet: true,
  },
  parameters: {
    docs: {
      description: {
        story:
          "Set `forceBottomSheet={true}` to override the responsive behavior and always render a bottom sheet, even on large screens.",
      },
    },
  },
  render: (args) => <ResponsiveBehavior.render {...args} />,
};

export const SideSheetLeft: Story = {
  name: "3. Side Sheet (Left)",
  args: {
    ...ResponsiveBehavior.args,
    side: "left",
  },
  parameters: {
    docs: {
      description: {
        story:
          "Use the `side` prop to control the drawer's position on desktop.",
      },
    },
  },
  render: (args) => <ResponsiveBehavior.render {...args} />,
};

export const DetachedMode: Story = {
  name: "4. Detached Mode",
  args: {
    ...ResponsiveBehavior.args,
    mode: "detached",
  },
  parameters: {
    docs: {
      description: {
        story:
          "The `detached` mode adds a margin, making the sheet appear to float. This works responsively for both bottom and side sheet variants.",
      },
    },
  },
  render: (args) => <ResponsiveBehavior.render {...args} />,
};

export const WithSnappingPoints: Story = {
  name: "5. With Snapping Points",
  args: {
    snapPoints: [0.3, 0.7, 1],
    fadeFromIndex: 0,
    forceBottomSheet: true, // Snapping is a bottom sheet feature
  },
  parameters: {
    docs: {
      description: {
        story:
          "**Snapping only works in bottom sheet mode.** If the component renders as a side sheet on desktop, snap points are automatically disabled. Here, we use `forceBottomSheet` to demonstrate them on a large screen.",
      },
    },
  },
  render: (args) => (
    <div className="flex p-12 items-center justify-center bg-graphite-background">
      <Sheet {...args}>
        <Sheet.Trigger asChild>
          <Button>Open Snapping Sheet</Button>
        </Sheet.Trigger>
        <Sheet.Content>
          <Sheet.Grabber />
          <DummyContent />
        </Sheet.Content>
      </Sheet>
    </div>
  ),
};

export const ControlledSnapping: Story = {
  name: "6. Controlled Snapping",
  args: {
    snapPoints: ["300px", 1],
    fadeFromIndex: 0,
    forceBottomSheet: true,
  },
  parameters: {
    docs: {
      description: {
        story:
          "Manually control the snap point from outside the component using the `activeSnapPoint` and `setActiveSnapPoint` props. This only works in bottom sheet mode.",
      },
    },
  },
  render: function Render(args) {
    const [activeSnapPoint, setActiveSnapPoint] = useState<
      string | number | null
    >(args.snapPoints![0]);
    return (
      <div className="flex p-12 flex-col items-center justify-center gap-4 bg-graphite-background">
        <Typography variant="large">External Controls</Typography>

        <Sheet
          {...args}
          activeSnapPoint={activeSnapPoint}
          setActiveSnapPoint={setActiveSnapPoint}
        >
          <Sheet.Trigger asChild>
            <Button>Open Controlled Sheet</Button>
          </Sheet.Trigger>
          <Sheet.Content>
            <Sheet.Grabber />
            <Sheet.Header>
              <Typography variant="h3">
                Current Snap: {String(activeSnapPoint)}
              </Typography>
            </Sheet.Header>

            <div
              className={clsx(
                activeSnapPoint === 1 ? "overflow-auto" : "overflow-hidden",
                "p-4"
              )}
            >
              <Typography>
                Lorem ipsum dolor sit amet consectetur adipisicing elit.
                Explicabo, eligendi! Voluptates nobis nam animi similique vero
                tenetur sunt velit? Maxime numquam neque ducimus recusandae quae
                non laudantium eum officiis nostrum. Cupiditate veritatis facere
                reiciendis cum fuga iste, ab qui animi culpa ducimus sed
                molestias? Qui, facilis alias? Ipsum sunt corrupti mollitia
                libero a quibusdam, rerum dignissimos, quam magni id unde.
                Quaerat, modi suscipit odio laboriosam alias, eum recusandae
                quod, aut nobis quidem explicabo impedit optio possimus amet ea.
                Non odio, placeat vel officia iusto vitae accusamus velit sint
                quo facere. Est et eius, esse culpa inventore sequi eum soluta
                perspiciatis illo minima, facilis nobis sed numquam similique.
                Soluta, ipsa eum enim amet dolorum error nemo at ab. Sit,
                repudiandae autem. Reiciendis quo eveniet molestias dolore
                exercitationem? Tenetur deleniti magni facere! Ducimus explicabo
                alias deleniti perferendis delectus accusamus deserunt tenetur
                iste dolor ullam, odio aliquid autem aut illum ad officiis
                vitae. Ipsam repellat neque ab debitis accusantium cupiditate
                laudantium, rem perferendis mollitia repudiandae architecto
                voluptatibus laborum et eius nemo iste harum nisi unde
                asperiores tempora placeat officia esse quia. Vitae, odit? Ipsa,
                similique rem. Minus eveniet totam quidem quia asperiores
                nostrum cupiditate corporis error expedita. Consequatur
                aspernatur, sint eum corporis, nisi earum dicta sed quae
                molestias sunt ipsa ex magni porro. Distinctio animi facilis
                doloremque beatae libero laudantium ducimus aliquam molestias,
                voluptates amet fugiat facere perferendis deserunt harum dicta
                eveniet quis sed deleniti repellendus veniam ullam reiciendis?
                Accusantium reprehenderit laudantium nemo. Quod nemo omnis hic
                optio laudantium saepe magni veniam excepturi, tenetur alias
                eveniet quibusdam, quidem recusandae quasi? Ipsum error
                accusamus corporis. Cum nesciunt ab repellat vitae consequatur
                et qui nemo. Magnam deserunt libero cumque magni ea pariatur,
                iusto consectetur, natus, ducimus sunt eum! Quisquam aliquid
                fugit suscipit architecto sunt quas at optio neque porro
                expedita, placeat dolor perferendis sequi tempora?
              </Typography>
            </div>
          </Sheet.Content>
        </Sheet>
      </div>
    );
  },
};
```


### Component: `split-button`

This section contains the source code for the `split-button` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\split-button\index.tsx`)**
```tsx
import { clsx } from "clsx";
import React from "react";

type ButtonShape = "full" | "minimal" | "sharp";

// Define a type for the children we expect. They must be ReactElements
// and we expect them to have a className prop.
type SplitButtonChildren = [
  React.ReactElement<{ className?: string }>,
  React.ReactElement<{ className?: string }>
];

interface SplitButtonProps extends React.HTMLAttributes<HTMLDivElement> {
  children: SplitButtonChildren;
  shape?: ButtonShape;
}

export const SplitButton = ({
  children,
  className,
  shape = "full",
  ...props
}: SplitButtonProps) => {
  // A runtime check for safety, though TypeScript now enforces the type
  if (React.Children.count(children) !== 2) {
    console.error("SplitButton requires exactly two children.");
    return null;
  }

  // TypeScript now knows mainAction and dropdownTrigger have a .props.className property
  const [mainAction, dropdownTrigger] = children;

  const shapeClasses: Record<ButtonShape, { left: string; right: string }> = {
    full: { left: "rounded-l-full", right: "rounded-r-full" },
    minimal: { left: "rounded-l-lg", right: "rounded-r-lg" },
    sharp: { left: "rounded-l-none", right: "rounded-r-none" },
  };

  const clonedMainAction = React.cloneElement(mainAction, {
    className: clsx(
      mainAction.props.className, // No more error here
      shapeClasses[shape].left,
      "!rounded-r-none"
    ),
  });

  const clonedDropdownTrigger = React.cloneElement(dropdownTrigger, {
    className: clsx(
      dropdownTrigger.props.className, // No more error here
      shapeClasses[shape].right,
      "!rounded-l-none"
    ),
  });

  return (
    <div
      className={clsx("inline-flex items-center gap-0.5", className)}
      {...props}
    >
      {clonedMainAction}
      {clonedDropdownTrigger}
    </div>
  );
};

SplitButton.displayName = "SplitButton";
```

**Storybook Stories (`Split-button.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { ChevronDown, Plus } from "lucide-react";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { SplitButton } from "./index";

const meta: Meta<typeof SplitButton> = {
  title: "Components/SplitButton",
  component: SplitButton,
  tags: ["autodocs"],
  argTypes: {
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
  parameters: {
    docs: {
      description: {
        component:
          "A split button combines a primary action button with a secondary trigger button. It maintains a small gap and applies specific rounding to the outer edges.",
      },
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    shape: "full",
  },
  render: (args) => (
    <SplitButton {...args}>
      <Button variant="primary">
        <Plus className="mr-2 h-4 w-4" />
        Create
      </Button>
      <IconButton variant="primary" aria-label="More options">
        <ChevronDown className="h-4 w-4" />
      </IconButton>
    </SplitButton>
  ),
};

export const AllShapes: Story = {
  name: "All Shapes",
  render: () => (
    <div className="flex flex-col items-start gap-6">
      <SplitButton shape="full">
        <Button variant="secondary">Full Shape</Button>
        <IconButton variant="secondary" aria-label="Options for Full Shape">
          <ChevronDown className="h-4 w-4" />
        </IconButton>
      </SplitButton>
      <SplitButton shape="minimal">
        <Button variant="secondary">Minimal Shape</Button>
        <IconButton variant="secondary" aria-label="Options for Minimal Shape">
          <ChevronDown className="h-4 w-4" />
        </IconButton>
      </SplitButton>
      <SplitButton shape="sharp">
        <Button variant="secondary">Sharp Shape</Button>
        <IconButton variant="secondary" aria-label="Options for Sharp Shape">
          <ChevronDown className="h-4 w-4" />
        </IconButton>
      </SplitButton>
    </div>
  ),
};

export const DifferentSizes: Story = {
  name: "Different Button Sizes",
  render: () => (
    <SplitButton shape="minimal">
      <Button variant="primary" size="lg">
        Large Action
      </Button>
      <IconButton
        variant="primary"
        size="lg"
        aria-label="Options for Large Action"
      >
        <ChevronDown className="h-5 w-5" />
      </IconButton>
    </SplitButton>
  ),
};
```


### Component: `switch`

This section contains the source code for the `switch` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\switch\index.tsx`)**
```tsx
import React from "react";
import { clsx } from "clsx";

export interface SwitchProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
}

export const Switch = React.forwardRef<HTMLInputElement, SwitchProps>(
  ({ className, id, label, ...props }, ref) => {
    const uniqueId = React.useId();
    const switchId = id || uniqueId;

    return (
      <label
        htmlFor={switchId}
        className="inline-flex items-center cursor-pointer"
      >
        <div className="relative">
          <input
            type="checkbox"
            ref={ref}
            id={switchId}
            className="sr-only peer"
            {...props}
          />
          {/* The Track (w-10 = 40px, h-6 = 24px) */}
          <div
            className={clsx(
              "w-10 h-6 rounded-full transition-colors",
              "bg-graphite-border",
              "peer-checked:bg-graphite-primary",
              "peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-graphite-ring peer-focus:ring-offset-2",
              "peer-disabled:opacity-50 peer-disabled:cursor-not-allowed"
            )}
          />
          {/* The Thumb (the circle) */}
          <div
            className={clsx(
              "absolute bg-white rounded-full transition-transform duration-200 ease-in-out shadow-lg",
              // ============================ THIS IS THE FIX ============================
              // Using arbitrary values for exact pixel dimensions
              "h-[17.5px] w-[17.5px]",
              // Recalculated positioning to perfectly center the 17.5px thumb in the 24px track
              // (24px - 17.5px) / 2 = 3.25px
              "top-[3.25px] left-[3.25px]",
              // Recalculated travel distance:
              // 40px (track) - 17.5px (thumb) - 6.5px (offsets) = 16px (translate-x-4)
              "peer-checked:translate-x-4"
              // =======================================================================
            )}
          />
        </div>
        {label && (
          <div className="ml-3 text-sm font-medium text-graphite-foreground select-none">
            {label}
          </div>
        )}
      </label>
    );
  }
);

Switch.displayName = "Switch";
```

**Storybook Stories (`Switch.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { useState } from "react";
import { Switch } from "./index";

const meta: Meta<typeof Switch> = {
  title: "Components/Switch",
  component: Switch,
  tags: ["autodocs"],
  argTypes: {
    label: { control: "text" },
    checked: { control: "boolean" },
    disabled: { control: "boolean" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    label: "Airplane Mode",
  },
};

export const Checked: Story = {
  name: "On by Default",
  args: {
    label: "Enable Notifications",
    defaultChecked: true,
  },
};

export const Disabled: Story = {
  name: "Disabled States",
  render: () => (
    <div className="flex flex-col gap-4">
      <Switch disabled label="Off and Disabled" />
      <Switch disabled defaultChecked label="On and Disabled" />
    </div>
  ),
};

export const Interactive: Story = {
  name: "Interactive (Controlled)",
  render: () => {
    const [isEnabled, setIsEnabled] = useState(true);
    return (
      <div className="flex flex-col gap-2">
        <Switch
          checked={isEnabled}
          onChange={(e) => setIsEnabled(e.target.checked)}
          label="Feature Toggle"
        />
        <p className="text-sm text-gray-500">
          The feature is currently: {isEnabled ? "Enabled" : "Disabled"}
        </p>
      </div>
    );
  },
};

export const WithoutLabel: Story = {
  name: "Without a Label",
  args: {
    "aria-label": "A switch without a visible label",
  },
};
```


### Component: `tabs`

This section contains the source code for the `tabs` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\tabs\index.tsx`)**
```tsx
"use client";

import { cva } from "class-variance-authority";
import { clsx } from "clsx";
import {
  animate,
  AnimatePresence,
  motion,
  type PanInfo,
  useMotionValue,
} from "framer-motion";
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useId,
  useImperativeHandle,
  useRef,
  useState,
} from "react";
import useRipple from "use-ripple-hook";
import { ShallowRouter, useRouter, useRouterOptions } from "../shallow-router";

// --- TYPE DEFINITIONS & CONTEXT ---
type TabVariant = "primary" | "secondary";
type PageTransition = "slide" | "fade";

interface TabsContextProps {
  activeTab: string;
  setActiveTab: (value: string) => void;
  variant: TabVariant;
  pageTransition: PageTransition;
  indicatorId: string;
}

const TabsContext = createContext<TabsContextProps | null>(null);

export const useTabs = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error("useTabs must be used within a <Tabs> provider.");
  }
  return context;
};

// --- ROOT & PROVIDER ---
interface TabsProps {
  children: React.ReactNode;
  defaultValue: string;
  variant?: TabVariant;
  pageTransition?: PageTransition;
  routingMode?: "search" | "pathname";
  routingParamName?: string;
  /**
   * For 'pathname' mode, specifies which tab to redirect to on initial load
   * if the current path is the base path.
   */
  initialTab?: string;
}

const TabsRoot: React.FC<TabsProps> = ({
  children,
  defaultValue,
  variant = "primary",
  pageTransition = "fade",
  routingMode = "search",
  routingParamName = "tab",
  initialTab,
}) => {
  const uniqueId = useId();
  return (
    <ShallowRouter mode={routingMode} paramName={routingParamName}>
      <TabsProvider
        defaultValue={defaultValue}
        variant={variant}
        pageTransition={pageTransition}
        indicatorId={uniqueId}
        initialTab={initialTab}
      >
        {children}
      </TabsProvider>
    </ShallowRouter>
  );
};

interface TabsProviderProps
  extends Omit<TabsProps, "routingMode" | "routingParamName"> {
  indicatorId: string;
}

const TabsProvider: React.FC<TabsProviderProps> = ({
  children,
  defaultValue,
  variant = "primary",
  pageTransition = "fade",
  indicatorId,
  initialTab,
}) => {
  const { path, push, replace } = useRouter();
  const { mode } = useRouterOptions();

  // biome-ignore lint/correctness/useExhaustiveDependencies: strict
  useEffect(() => {
    if (initialTab) {
      replace(initialTab);
    }
  }, [initialTab]);

  const activeTab = path === "/" ? defaultValue : path;

  const setActiveTab = (value: string) => {
    if (value === activeTab) return;
    push(value);
  };

  return (
    <TabsContext.Provider
      value={{ activeTab, setActiveTab, variant, pageTransition, indicatorId }}
    >
      <div>{children}</div>
    </TabsContext.Provider>
  );
};

// --- TAB LIST ---
interface TabsListProps extends React.HTMLAttributes<HTMLDivElement> {}

const TabsList = React.forwardRef<HTMLDivElement, TabsListProps>(
  ({ children, className, ...props }, ref) => {
    const listRef = useRef<HTMLDivElement>(null);
    const [isOverflowing, setIsOverflowing] = useState(false);
    const [scrollPosition, setScrollPosition] = useState<
      "start" | "middle" | "end"
    >("start");

    // Combine forwarded ref with local ref for external access
    useImperativeHandle(ref, () => listRef.current!);

    // Memoized function to check overflow and scroll position
    const checkScrollState = useCallback(() => {
      const el = listRef.current;
      if (!el) return;

      const hasOverflow = el.scrollWidth > el.clientWidth;
      setIsOverflowing(hasOverflow);

      if (!hasOverflow) {
        setScrollPosition("start");
        return;
      }

      // Using a small tolerance for floating point inaccuracies
      const isAtStart = el.scrollLeft <= 1;
      const isAtEnd = el.scrollLeft >= el.scrollWidth - el.clientWidth - 1;

      if (isAtStart) {
        setScrollPosition("start");
      } else if (isAtEnd) {
        setScrollPosition("end");
      } else {
        setScrollPosition("middle");
      }
    }, []);

    // Effect to check scroll state on mount, resize, and content changes
    useEffect(() => {
      const el = listRef.current;
      if (!el) return;

      checkScrollState();

      const resizeObserver = new ResizeObserver(checkScrollState);
      resizeObserver.observe(el);

      const mutationObserver = new MutationObserver(checkScrollState);
      mutationObserver.observe(el, { childList: true, subtree: true });

      return () => {
        resizeObserver.disconnect();
        mutationObserver.disconnect();
      };
    }, [checkScrollState]);

    const handleScroll = () => {
      checkScrollState();
    };

    // CSS mask styles for creating the fade effect on the edges
    const maskStyles: Record<string, React.CSSProperties> = {
      start: {
        // Fade on the right side
        maskImage:
          "linear-gradient(to right, black calc(100% - 48px), transparent 100%)",
      },
      middle: {
        // Fade on both sides
        maskImage:
          "linear-gradient(to right, transparent 0%, black 48px, black calc(100% - 48px), transparent 100%)",
      },
      end: {
        // Fade on the left side
        maskImage: "linear-gradient(to right, transparent 0%, black 48px)",
      },
    };

    return (
      <div
        ref={listRef}
        role="tablist"
        onScroll={handleScroll}
        className={clsx(
          "relative flex border-b border-graphite-border",
          // Apply scrolling and scrollbar hiding only when needed
          isOverflowing && "overflow-x-auto no-scrollbar",
          className
        )}
        style={isOverflowing ? maskStyles[scrollPosition] : {}}
        {...props}
      >
        {children}
      </div>
    );
  }
);
TabsList.displayName = "Tabs.List";

// --- TAB TRIGGER (MODIFIED) ---
const triggerVariants = cva(
  "relative flex px-6 flex-col items-center justify-center gap-1.5 flex-1 min-h-14 max-auto pb-2 pt-2 font-semibold text-sm transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-graphite-ring focus-visible:ring-offset-2",
  {
    variants: {
      variant: { primary: "pt-1", secondary: "" },
      isActive: {
        true: "text-graphite-primary",
        false: "text-graphite-foreground/60 hover:text-graphite-foreground/80",
      },
    },
    defaultVariants: { variant: "primary", isActive: false },
  }
);

interface TabsTriggerProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  value: string;
  icon?: React.ReactNode;
}

const TabsTrigger = React.forwardRef<HTMLButtonElement, TabsTriggerProps>(
  ({ value, children, icon, className, ...props }, ref) => {
    const { activeTab, setActiveTab, variant, indicatorId } = useTabs();
    const isActive = activeTab === value;
    const localRef = React.useRef<HTMLButtonElement>(null);
    const [, event] = useRipple({
      ref: localRef,
      color: "rgba(0, 0, 0, 0.1)",
      duration: 450,
    });
    React.useImperativeHandle(ref, () => localRef.current!);

    // --- NEW LOGIC TO SCROLL ACTIVE TAB INTO VIEW ---
    useEffect(() => {
      if (isActive && localRef.current) {
        localRef.current.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "center",
        });
      }
    }, [isActive]);
    // --- END OF NEW LOGIC ---

    return (
      <button
        ref={localRef}
        role="tab"
        aria-selected={isActive}
        data-state={isActive ? "active" : "inactive"}
        onClick={() => setActiveTab(value)}
        onPointerDown={event}
        className={clsx(triggerVariants({ variant, isActive }), className)}
        {...props}
      >
        {variant === "primary" && icon}
        <span className="relative z-10">{children}</span>
        {isActive && (
          <motion.div
            layoutId={indicatorId}
            className={clsx(
              "absolute bottom-0 rounded-full bg-graphite-primary",
              variant === "primary" ? "w-8" : "w-full"
            )}
            style={{
              height: "2px",
            }}
            transition={{ type: "spring", stiffness: 400, damping: 35 }}
          />
        )}
      </button>
    );
  }
);
TabsTrigger.displayName = "Tabs.Trigger";

// --- TABS CONTENT ---
interface TabsContentProps extends React.HTMLAttributes<HTMLDivElement> {}

const TabsContent = React.forwardRef<HTMLDivElement, TabsContentProps>(
  ({ children, className, ...props }, ref) => {
    const { activeTab, setActiveTab, pageTransition } = useTabs();
    const containerRef = useRef<HTMLDivElement>(null);
    const [containerWidth, setContainerWidth] = useState(0);
    const x = useMotionValue(0);

    if (pageTransition === "fade") {
      // Find the child that corresponds to the active tab.
      const activeChild = React.Children.toArray(children).find(
        (child) =>
          React.isValidElement(child) && child.props?.value === activeTab
      );

      return (
        <div ref={ref} className={clsx("relative", className)} {...props}>
          <AnimatePresence mode="wait">
            {/* If an active child is found, clone it and give it a unique key.
                This key is essential for AnimatePresence to detect when the
                component changes and apply enter/exit animations correctly. */}
            {activeChild && React.isValidElement(activeChild)
              ? React.cloneElement(activeChild, {
                  key: activeTab, // Assign the key here
                })
              : null}
          </AnimatePresence>
        </div>
      );
    }

    const panels = React.Children.toArray(children).filter(
      React.isValidElement
    ) as React.ReactElement<TabsPanelProps>[];
    const tabValues = panels.map((panel) => panel.props.value);
    const activeIndex = tabValues.indexOf(activeTab);

    // biome-ignore lint/correctness/useHookAtTopLevel: strict
    useEffect(() => {
      const measureWidth = () => {
        if (containerRef.current) {
          setContainerWidth(containerRef.current.offsetWidth);
        }
      };
      measureWidth();
      window.addEventListener("resize", measureWidth);
      return () => window.removeEventListener("resize", measureWidth);
    }, []);

    // biome-ignore lint/correctness/useHookAtTopLevel: strict
    useEffect(() => {
      if (containerWidth > 0) {
        const targetX = -activeIndex * containerWidth;
        animate(x, targetX, {
          type: "spring",
          stiffness: 400,
          damping: 40,
        });
      }
    }, [activeIndex, containerWidth, x]);

    // --- MODIFICATION START: Replaced handleDragEnd logic ---
    const handleDragEnd = (event: MouseEvent | TouchEvent, info: PanInfo) => {
      const { offset, velocity } = info;

      // A fast swipe (fling) is prioritized. We use a velocity threshold.
      const velocityThreshold = 300;
      // If not a fling, the user must drag at least a portion of the page width.
      const distanceThreshold = containerWidth * 0.3; // 30% of the width

      if (velocity.x < -velocityThreshold || offset.x < -distanceThreshold) {
        // Decisive swipe to the left (next page)
        const nextIndex = Math.min(activeIndex + 1, panels.length - 1);
        setActiveTab(tabValues[nextIndex]);
      } else if (
        velocity.x > velocityThreshold ||
        offset.x > distanceThreshold
      ) {
        // Decisive swipe to the right (previous page)
        const prevIndex = Math.max(activeIndex - 1, 0);
        setActiveTab(tabValues[prevIndex]);
      } else {
        // Indecisive swipe, snap back to the current active page.
        // This is crucial for preventing the "stuck" state.
        animate(x, -activeIndex * containerWidth, {
          type: "spring",
          stiffness: 400,
          damping: 40,
        });
      }
    };
    // --- END MODIFICATION ---

    return (
      <div
        ref={containerRef}
        className={clsx("overflow-hidden", className)}
        {...props}
      >
        <motion.div
          role="tabpanel"
          ref={ref}
          className="flex cursor-grab active:cursor-grabbing"
          style={{ x }}
          drag="x"
          dragConstraints={{
            left: -containerWidth * (panels.length - 1),
            right: 0,
          }}
          onDragEnd={handleDragEnd}
        >
          {panels}
        </motion.div>
      </div>
    );
  }
);
TabsContent.displayName = "Tabs.Content";

// --- TABS PANEL ---
interface TabsPanelProps extends React.HTMLAttributes<HTMLDivElement> {
  value: string;
}

const TabsPanel = React.forwardRef<HTMLDivElement, TabsPanelProps>(
  ({ value, children, className, ...props }, ref) => {
    const { activeTab, pageTransition } = useTabs();

    if (pageTransition === "fade") {
      // The parent (TabsContent) now handles filtering and keying.
      // This component just needs to render the animatable motion.div.
      // The key={value} here is now redundant but harmless.
      return (
        <motion.div
          ref={ref}
          role="tabpanel"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0, transition: { duration: 0.1 } }}
          transition={{ duration: 0.2 }}
          className={clsx("p-4", className)}
          {...props}
        >
          {children}
        </motion.div>
      );
    }

    return (
      <div
        ref={ref}
        role="tabpanel"
        className={clsx("w-full flex-shrink-0 p-4 min-h-[100px]", className)}
        aria-hidden={activeTab !== value}
        {...props}
      >
        {children}
      </div>
    );
  }
);
TabsPanel.displayName = "Tabs.Panel";

// --- EXPORT COMPOUND COMPONENT ---
export const Tabs = Object.assign(TabsRoot, {
  List: TabsList,
  Trigger: TabsTrigger,
  Content: TabsContent,
  Panel: TabsPanel,
});
```

**Storybook Stories (`Tabs.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import {
  Car,
  Compass,
  Hotel,
  LocateIcon,
  Menu,
  Package,
  Plane,
  Search,
} from "lucide-react";
import { AppBar } from "../appbar";
import { Card } from "../card";
import { IconButton } from "../icon-button";
import { Typography } from "../typography";
import { Tabs } from "./index";

const meta: Meta<typeof Tabs> = {
  title: "Components/Navigators/Tabs",
  component: Tabs,
  subcomponents: {
    "Tabs.List": Tabs.List,
    "Tabs.Trigger": Tabs.Trigger,
    "Tabs.Content": Tabs.Content,
    "Tabs.Panel": Tabs.Panel,
  },
  tags: ["autodocs"],
  parameters: {
    layout: "centered",
    docs: {
      description: {
        component:
          "A fully-featured tabs component with animated indicators and page transitions. It integrates with the `ShallowRouter` to support browser history and deep linking.",
      },
    },
  },
  argTypes: {
    defaultValue: {
      control: "text",
      description: "The value of the tab to be active on initial render.",
    },
    initialTab: {
      control: "text",
      description: "Sets the initial route for 'pathname' mode on first load.",
      if: { arg: "routingMode", eq: "pathname" },
    },
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    pageTransition: {
      control: "select",
      options: ["slide", "fade"],
    },
    routingMode: {
      control: "select",
      options: ["search", "pathname"],
    },
    routingParamName: {
      control: "text",
    },
  },
};

export default meta;
type Story = StoryObj<typeof Tabs>;

export const Primary: Story = {
  name: "1. Primary Variant (with Icons)",
  args: {
    defaultValue: "flights",
    variant: "primary",
    pageTransition: "fade",
    routingParamName: "view",
  },
  render: (args) => (
    <Card className="w-96" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="flights" icon={<Plane size={20} />}>
            Flights
          </Tabs.Trigger>
          <Tabs.Trigger value="trips" icon={<LocateIcon size={20} />}>
            Trips
          </Tabs.Trigger>
          <Tabs.Trigger value="explore" icon={<Compass size={20} />}>
            Explore
          </Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="flights">
            <Typography variant="h4">Find Your Next Flight</Typography>
            <Typography variant="p">
              Search for one-way, round-trip, or multi-city flights.
            </Typography>
          </Tabs.Panel>
          <Tabs.Panel value="trips">
            <Typography variant="h4">Manage Your Trips</Typography>
            <Typography variant="p">
              View upcoming and past trip details here.
            </Typography>
          </Tabs.Panel>
          <Tabs.Panel value="explore">
            <Typography variant="h4">Explore Destinations</Typography>
            <Typography variant="p">
              Get inspired for your next adventure.
            </Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const Secondary: Story = {
  name: "2. Secondary Variant (Text Only)",
  args: {
    defaultValue: "overview",
    variant: "secondary",
    pageTransition: "fade",
  },
  render: (args) => (
    <Card className="w-96" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="overview">Overview</Tabs.Trigger>
          <Tabs.Trigger value="specs">Specifications</Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="overview">
            <Typography variant="h4">Product Overview</Typography>
            <Typography variant="p">
              This is the general description of the product.
            </Typography>
          </Tabs.Panel>
          <Tabs.Panel value="specs">
            <Typography variant="h4">Technical Specifications</Typography>
            <Typography variant="p">
              Detailed technical specifications are listed here.
            </Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const SwipeableCarousel: Story = {
  name: "3. Swipeable Carousel (Slide Transition)",
  args: {
    ...Primary.args,
    pageTransition: "slide",
  },
  parameters: {
    docs: {
      description: {
        story:
          "Set `pageTransition='slide'` to create a carousel effect. You can now drag with a mouse or swipe on a touch screen to navigate between panels.",
      },
    },
  },
  render: (args) => <Primary.render {...args} />,
};

export const PathnameRouting: Story = {
  name: "4. Pathname Routing Mode",
  args: {
    ...Secondary.args,
    routingMode: "pathname",
    initialTab: "overview", // This is now the recommended way
  },
  parameters: {
    docs: {
      description: {
        story:
          "When `routingMode='pathname'`, the `initialTab` prop is used to set the URL correctly on the first render, ensuring the UI and the URL are in sync.",
      },
    },
  },
  render: (args) => <Secondary.render {...args} />,
};

export const Scrollable: Story = {
  name: "5. Scrollable Tabs",
  args: {
    ...Primary.args,
    defaultValue: "flights",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When there are too many tabs to fit in the container, the list becomes horizontally scrollable with faded edges to indicate more content is available.",
      },
    },
  },
  render: (args) => (
    <Card className="w-80" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="flights" icon={<Plane size={20} />}>
            Flights
          </Tabs.Trigger>
          <Tabs.Trigger value="trips" icon={<LocateIcon size={20} />}>
            Trips
          </Tabs.Trigger>
          <Tabs.Trigger value="explore" icon={<Compass size={20} />}>
            Explore
          </Tabs.Trigger>
          <Tabs.Trigger value="hotels" icon={<Hotel size={20} />}>
            Hotels
          </Tabs.Trigger>
          <Tabs.Trigger value="cars" icon={<Car size={20} />}>
            Car Rentals
          </Tabs.Trigger>
          <Tabs.Trigger value="packages" icon={<Package size={20} />}>
            Packages
          </Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="flights">
            <Typography variant="h4">Find Your Next Flight</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="trips">
            <Typography variant="h4">Manage Your Trips</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="explore">
            <Typography variant="h4">Explore Destinations</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="hotels">
            <Typography variant="h4">Book a Hotel</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="cars">
            <Typography variant="h4">Rent a Car</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="packages">
            <Typography variant="h4">Vacation Packages</Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const ScrollableWithSwipe: Story = {
  name: "6. Scrollable Tabs With swipe",
  args: {
    ...Primary.args,
    defaultValue: "flights",
    pageTransition: "slide",
  },
  parameters: {
    docs: {
      description: {
        story:
          "When there are too many tabs to fit in the container, the list becomes horizontally scrollable with faded edges to indicate more content is available.",
      },
    },
  },
  render: (args) => (
    <Card className="w-[450px]" shape="minimal">
      <Tabs {...args}>
        <Tabs.List>
          <Tabs.Trigger value="flights" icon={<Plane size={20} />}>
            Flights
          </Tabs.Trigger>
          <Tabs.Trigger value="trips" icon={<LocateIcon size={20} />}>
            Trips
          </Tabs.Trigger>
          <Tabs.Trigger value="explore" icon={<Compass size={20} />}>
            Explore
          </Tabs.Trigger>
          <Tabs.Trigger value="hotels" icon={<Hotel size={20} />}>
            Hotels
          </Tabs.Trigger>
          <Tabs.Trigger value="cars" icon={<Car size={20} />}>
            Car Rentals
          </Tabs.Trigger>
          <Tabs.Trigger value="packages" icon={<Package size={20} />}>
            Packages
          </Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content>
          <Tabs.Panel value="flights">
            <Typography variant="h4">Find Your Next Flight</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="trips">
            <Typography variant="h4">Manage Your Trips</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="explore">
            <Typography variant="h4">Explore Destinations</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="hotels">
            <Typography variant="h4">Book a Hotel</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="cars">
            <Typography variant="h4">Rent a Car</Typography>
          </Tabs.Panel>
          <Tabs.Panel value="packages">
            <Typography variant="h4">Vacation Packages</Typography>
          </Tabs.Panel>
        </Tabs.Content>
      </Tabs>
    </Card>
  ),
};

export const WithAppBar: Story = {
  name: "7. With AppBar",
  args: {
    defaultValue: "flights",
    variant: "secondary", // Secondary variant looks better inside an AppBar
    pageTransition: "fade",
  },
  parameters: {
    layout: "fullscreen", // Override layout for this story
    docs: {
      description: {
        story:
          "This example demonstrates how to integrate the `Tabs` component with the `AppBar`. The `Tabs.List` is placed inside the `largeHeaderContent` slot of a large `AppBar`. The `AppBar.Provider` manages the scrolling container which holds the `Tabs.Content`, allowing the AppBar to collapse and hide correctly as the user scrolls through the tab panels.",
      },
    },
  },
  render: (args) => {
    const DummyScrollContent = ({ title }: { title: string }) => (
      <main className="p-6">
        <Typography variant="h3">{title}</Typography>
        <div className="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 30 }).map((_, i) => (
            <div key={i} className="h-48 rounded-2xl bg-black/5" />
          ))}
        </div>
      </main>
    );

    return (
      <AppBar.Provider mainContentColor="background">
        <Tabs {...args}>
          <AppBar
            size="lg"
            scrollBehavior="conditionally-sticky"
            stickyHideTarget="main-row"
            appBarColor="card"
            startAdornment={
              <IconButton variant="ghost" aria-label="Menu">
                <Menu />
              </IconButton>
            }
            endAdornments={[
              <IconButton key="search" variant="ghost" aria-label="Search">
                <Search />
              </IconButton>,
            ]}
            children={
              <Typography variant="h4" className="truncate font-bold">
                My App
              </Typography>
            }
            largeHeaderContent={
              // Negative margins stretch the list to the edges and counteract parent padding
              <div className="-mx-4 -mb-4">
                <Tabs.List className="!border-b-0">
                  <Tabs.Trigger value="flights">Flights</Tabs.Trigger>
                  <Tabs.Trigger value="hotels">Hotels</Tabs.Trigger>
                  <Tabs.Trigger value="cars">Cars</Tabs.Trigger>
                  <Tabs.Trigger value="packages">Packages</Tabs.Trigger>
                </Tabs.List>
              </div>
            }
          />

          <div className="pt-[160px]">
            <Tabs.Content>
              <Tabs.Panel value="flights">
                <DummyScrollContent title="Search for Flights" />
              </Tabs.Panel>
              <Tabs.Panel value="hotels">
                <DummyScrollContent title="Find Hotel Deals" />
              </Tabs.Panel>
              <Tabs.Panel value="cars">
                <DummyScrollContent title="Rent a Car" />
              </Tabs.Panel>
              <Tabs.Panel value="packages">
                <DummyScrollContent title="Vacation Packages" />
              </Tabs.Panel>
            </Tabs.Content>
          </div>
        </Tabs>
      </AppBar.Provider>
    );
  },
};
```


### Component: `textarea`

This section contains the source code for the `textarea` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\textarea\index.tsx`)**
```tsx
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import React, { useEffect, useImperativeHandle, useRef } from "react";

const textAreaWrapperVariants = cva(
  "flex items-start transition-all duration-200 w-full px-4 border-2",
  {
    variants: {
      variant: {
        primary: "bg-graphite-card",
        secondary: "bg-graphite-secondary",
      },
      shape: {
        full: "rounded-4xl",
        minimal: "rounded-2xl",
        sharp: "rounded-none",
      },
      size: {
        sm: "py-2 text-sm",
        md: "py-3 text-base",
        lg: "py-4 text-lg",
      },
      isErrored: { true: "" },
      isFocused: { true: "" },
      disabled: {
        true: "bg-graphite-secondary opacity-50 cursor-not-allowed",
      },
    },
    compoundVariants: [
      {
        variant: "primary",
        isErrored: false,
        isFocused: false,
        className: "border-graphite-border",
      },
      {
        variant: "secondary",
        isErrored: false,
        isFocused: false,
        className: "border-transparent",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: false,
        className: "border-graphite-primary",
      },
      {
        variant: "primary",
        isFocused: false,
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "secondary",
        isFocused: false,
        isErrored: true,
        className: "border-red-500",
      },
      {
        variant: "primary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
      {
        variant: "secondary",
        isFocused: true,
        isErrored: true,
        className: "border-red-600",
      },
    ],
    defaultVariants: {
      variant: "primary",
      shape: "minimal",
      size: "md",
    },
  }
);

export interface TextAreaProps
  extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, "size">,
    VariantProps<typeof textAreaWrapperVariants> {
  label?: string;
  error?: string;
  wrapperClassName?: string;
}

export const TextArea = React.forwardRef<HTMLTextAreaElement, TextAreaProps>(
  (
    {
      className,
      id,
      label,
      error,
      disabled,
      shape,
      size,
      wrapperClassName,
      variant,
      onFocus,
      onBlur,
      onChange,
      rows = 3, // Default to 3 rows
      value,
      ...props
    },
    ref
  ) => {
    const uniqueId = React.useId();
    const textAreaId = id || uniqueId;
    const hasError = !!error;
    const [isFocused, setIsFocused] = React.useState(false);

    // Create a local ref to manage the textarea DOM element
    const localRef = useRef<HTMLTextAreaElement>(null);
    // Bridge the forwarded ref with our local ref
    useImperativeHandle(ref, () => localRef.current!);

    // Function to resize the textarea
    const resizeTextArea = () => {
      const textArea = localRef.current;
      if (textArea) {
        // Temporarily reset height to allow scrollHeight to be calculated correctly
        textArea.style.height = "auto";
        // Set the height to match the content's scroll height
        textArea.style.height = `${textArea.scrollHeight}px`;
      }
    };

    // Resize on initial mount and when the value prop changes programmatically
    useEffect(() => {
      resizeTextArea();
    }, [value]);

    const handleFocus = (e: React.FocusEvent<HTMLTextAreaElement>) => {
      setIsFocused(true);
      onFocus?.(e);
    };

    const handleBlur = (e: React.FocusEvent<HTMLTextAreaElement>) => {
      setIsFocused(false);
      onBlur?.(e);
    };

    // Wrap the onChange handler to trigger resize on every input
    const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      resizeTextArea();
      // Forward the event to the original onChange handler if it exists
      onChange?.(e);
    };

    return (
      <div className="w-full flex flex-col gap-2">
        {label && (
          <label
            htmlFor={textAreaId}
            className="block text-sm font-medium text-graphite-primary"
          >
            {label}
          </label>
        )}
        <div
          className={textAreaWrapperVariants({
            variant,
            shape,
            size,
            isErrored: hasError,
            isFocused,
            disabled,
            className: wrapperClassName,
          })}
        >
          <textarea
            id={textAreaId}
            ref={localRef}
            disabled={disabled}
            rows={rows} // Set the initial row height
            onFocus={handleFocus}
            onBlur={handleBlur}
            onChange={handleChange}
            value={value}
            className={clsx(
              // `resize-none` is important for auto-sizing to work smoothly
              // `overflow-hidden` prevents the scrollbar from flashing during resize
              "w-full flex-1 bg-transparent focus:outline-none resize-none overflow-hidden",
              "disabled:cursor-not-allowed",
              variant === "secondary" && "placeholder:text-gray-500",
              className
            )}
            {...props}
          />
        </div>
        {hasError && <p className="mt-2 text-sm text-red-600">{error}</p>}
      </div>
    );
  }
);

TextArea.displayName = "TextArea";
```

**Storybook Stories (`Textarea.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { TextArea } from "./index";

const meta: Meta<typeof TextArea> = {
  title: "Components/TextArea",
  component: TextArea,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    label: { control: "text" },
    placeholder: { control: "text" },
    disabled: { control: "boolean" },
    error: { control: "text" },
    rows: { control: "number" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "primary",
    shape: "minimal",
    size: "md",
    label: "Your Message",
    placeholder: "Enter your comments here...",
    rows: 4,
  },
};

export const AllSizes: Story = {
  name: "All Sizes",
  render: () => (
    <div className="flex flex-col gap-6 max-w-sm">
      <TextArea
        size="sm"
        label="Small"
        placeholder="Small textarea (sm)"
        rows={3}
      />
      <TextArea
        size="md"
        label="Medium (Default)"
        placeholder="Medium textarea (md)"
        rows={3}
      />
      <TextArea
        size="lg"
        label="Large"
        placeholder="Large textarea (lg)"
        rows={3}
      />
    </div>
  ),
  parameters: {
    docs: {
      description: {
        story: "The `size` prop controls the vertical padding and font size.",
      },
    },
  },
};

export const AllVariantsAndShapes: Story = {
  name: "All Variants & Shapes",
  render: () => (
    <div className="flex flex-col gap-8 max-w-sm">
      <div>
        <h3 className="font-bold mb-4">Primary Variant</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="primary"
            shape="full"
            placeholder="Full Shape"
            rows={2}
          />
          <TextArea
            variant="primary"
            shape="minimal"
            placeholder="Minimal Shape"
            rows={2}
          />
          <TextArea
            variant="primary"
            shape="sharp"
            placeholder="Sharp Shape"
            rows={2}
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary Variant</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="secondary"
            shape="full"
            placeholder="Full Shape"
            rows={2}
          />
          <TextArea
            variant="secondary"
            shape="minimal"
            placeholder="Minimal Shape"
            rows={2}
          />
          <TextArea
            variant="secondary"
            shape="sharp"
            placeholder="Sharp Shape"
            rows={2}
          />
        </div>
      </div>
    </div>
  ),
};

export const AllStates: Story = {
  name: "All States",
  render: () => (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-2xl">
      <div>
        <h3 className="font-bold mb-4">Primary States</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="primary"
            label="Default"
            placeholder="Enter a description..."
          />
          <TextArea
            variant="primary"
            label="With Value"
            defaultValue="This is some pre-filled text in the textarea."
          />
          <TextArea
            variant="primary"
            label="Error State"
            defaultValue="This message is too short."
            error="Message must be at least 50 characters."
          />
          <TextArea
            variant="primary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
      <div>
        <h3 className="font-bold mb-4">Secondary States</h3>
        <div className="flex flex-col gap-4">
          <TextArea
            variant="secondary"
            label="Default"
            placeholder="Enter a description..."
          />
          <TextArea
            variant="secondary"
            label="With Value"
            defaultValue="This is some pre-filled text in the textarea."
          />
          <TextArea
            variant="secondary"
            label="Error State"
            defaultValue="This message is too short."
            error="Message must be at least 50 characters."
          />
          <TextArea
            variant="secondary"
            label="Disabled"
            placeholder="Cannot edit"
            disabled
          />
        </div>
      </div>
    </div>
  ),
};

export const WithCustomRows: Story = {
  name: "With Custom Rows",
  args: {
    label: "A Tall Text Area",
    placeholder: "This area starts with 8 rows",
    rows: 8,
  },
};
```


### Component: `tooltip`

This section contains the source code for the `tooltip` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\tooltip\index.tsx`)**
```tsx
// 1. Install this dependency first:
// npm install @uidotdev/usehooks

import {
  arrow,
  autoUpdate,
  flip,
  FloatingPortal,
  offset,
  shift,
  useDismiss,
  useFloating,
  useFocus,
  useHover,
  useInteractions,
  useRole,
} from "@floating-ui/react";
// 2. Import the new hooks from the library
import { useLongPress, useMediaQuery } from "@uidotdev/usehooks";
import { cva, type VariantProps } from "class-variance-authority";
import { clsx } from "clsx";
import React, {
  cloneElement,
  createContext,
  isValidElement,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

// CVA definition remains unchanged
const tooltipVariants = cva("font-semibold relative z-50", {
  variants: {
    variant: {
      primary: "bg-graphite-primary text-graphite-primaryForeground",
      secondary: "bg-graphite-secondary text-graphite-secondaryForeground",
    },
    size: {
      sm: "px-2 py-1 text-xs",
      md: "px-3 py-1.5 text-sm",
      lg: "px-4 py-2 text-base",
    },
    shape: {
      full: "rounded-full",
      minimal: "rounded-lg",
      sharp: "rounded-none",
    },
  },
  defaultVariants: {
    variant: "primary",
    size: "md",
    shape: "minimal",
  },
});

export interface TooltipProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof tooltipVariants> {}

// Context type remains unchanged
interface TooltipContextType {
  isOpen: boolean;
  setIsOpen: React.Dispatch<React.SetStateAction<boolean>>;
  getReferenceProps: (
    userProps?: React.HTMLProps<HTMLElement> | undefined
  ) => Record<string, unknown>;
  getFloatingProps: (
    userProps?: React.HTMLProps<HTMLElement> | undefined
  ) => Record<string, unknown>;
  floatingStyles: React.CSSProperties;
  refs: {
    setReference: (node: HTMLElement | null) => void;
    setFloating: (node: HTMLElement | null) => void;
  };
  middlewareData: ReturnType<typeof useFloating>["middlewareData"];
  placement: ReturnType<typeof useFloating>["placement"];
  arrowRef: React.RefObject<HTMLDivElement>;
}

const TooltipContext = createContext<TooltipContextType | null>(null);

export const useTooltip = (): TooltipContextType => {
  const context = useContext(TooltipContext);
  if (context == null) {
    throw new Error(
      "Tooltip components must be wrapped in <TooltipProvider />"
    );
  }
  return context;
};

// ==================== TooltipProvider (Refactored) ====================

export const TooltipProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const arrowRef = useRef<HTMLDivElement>(null);

  // 3. Use useMediaQuery to detect touch devices reliably
  const isTouchDevice = useMediaQuery("(pointer: coarse)");

  const data = useFloating({
    open: isOpen,
    onOpenChange: setIsOpen,
    middleware: [
      offset(10),
      flip(),
      shift({ padding: 8 }),
      arrow({ element: arrowRef }),
    ],
    whileElementsMounted: autoUpdate,
    strategy: "fixed",
    placement: "top",
  });

  const context = data.context;

  // Interactions from @floating-ui/react
  const hover = useHover(context, { enabled: !isTouchDevice, move: false });
  const focus = useFocus(context, { enabled: !isTouchDevice });
  const dismiss = useDismiss(context, { referencePress: !isTouchDevice });
  const role = useRole(context, { role: "tooltip" });

  // 4. Use useLongPress from the library
  // The callback is only passed if it's a touch device, otherwise it's null.
  const longPressEvents = useLongPress(
    isTouchDevice ? () => setIsOpen(true) : null,
    { threshold: 500 } // Long press duration
  );

  // useInteractions only manages the Floating UI native hooks
  const interactions = useInteractions([hover, focus, dismiss, role]);

  const value = useMemo(
    () => ({
      isOpen,
      setIsOpen,
      // 5. Manually merge the props from useInteractions and useLongPress
      getReferenceProps: (userProps) => ({
        ...interactions.getReferenceProps(userProps),
        ...(isTouchDevice ? longPressEvents : {}),
      }),
      getFloatingProps: interactions.getFloatingProps,
      floatingStyles: data.floatingStyles,
      refs: data.refs,
      middlewareData: data.middlewareData,
      placement: data.placement,
      arrowRef,
    }),
    [
      isOpen,
      interactions,
      isTouchDevice,
      longPressEvents,
      data.floatingStyles,
      data.refs,
      data.middlewareData,
      data.placement,
    ]
  );

  return (
    <TooltipContext.Provider value={value}>{children}</TooltipContext.Provider>
  );
};

// =====================================================================

// TooltipTrigger and mergeRefs remain unchanged
function mergeRefs<T>(
  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T> | null | undefined>
): React.RefCallback<T> {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        (ref as React.MutableRefObject<T | null>).current = value;
      }
    });
  };
}
export const TooltipTrigger = React.forwardRef<
  HTMLElement,
  React.HTMLProps<HTMLElement> & { asChild?: boolean }
>(function TooltipTrigger({ children, asChild = true, ...props }, propRef) {
  const context = useTooltip();
  const childrenRef = (children as any)?.ref;
  const ref = useMemo(
    () => mergeRefs([propRef, childrenRef, context.refs.setReference]),
    [propRef, childrenRef, context.refs.setReference]
  );
  if (!isValidElement(children)) {
    console.warn("TooltipTrigger expects a single React element as a child");
    return (
      <span
        ref={ref as any}
        {...context.getReferenceProps(props)}
        data-state={context.isOpen ? "open" : "closed"}
      >
        {children}
      </span>
    );
  }
  const childProps = children.props as Record<string, any>;
  return cloneElement(
    children,
    context.getReferenceProps({
      ref,
      ...props,
      ...childProps,
    })
  );
});

// Tooltip component remains unchanged
export const Tooltip = React.forwardRef<HTMLDivElement, TooltipProps>(
  ({ className, variant, size, shape, style, children, ...props }, ref) => {
    const context = useTooltip();
    const [isMounted, setIsMounted] = useState(false);
    const mergedRef = useMemo(
      () => mergeRefs([ref, context.refs.setFloating]),
      [ref, context.refs.setFloating]
    );
    useEffect(() => {
      if (context.isOpen) {
        const timer = setTimeout(() => setIsMounted(true), 10);
        return () => clearTimeout(timer);
      } else {
        setIsMounted(false);
      }
    }, [context.isOpen]);
    if (!context.isOpen) return null;

    const staticSide = {
      top: "bottom",
      right: "left",
      bottom: "top",
      left: "right",
    }[context.placement.split("-")[0]] as string;
    const arrowColorClass = {
      primary: "bg-graphite-primary",
      secondary: "bg-graphite-secondary",
    }[variant || "primary"];

    return (
      <FloatingPortal>
        <div
          ref={mergedRef}
          className={tooltipVariants({ variant, size, shape, className })}
          style={{
            ...context.floatingStyles,
            ...style,
            visibility: context.floatingStyles.transform ? "visible" : "hidden",
            opacity: isMounted ? 1 : 0,
            transition: "opacity 200ms ease-in-out",
          }}
          {...context.getFloatingProps(props)}
        >
          {children}
          <div
            ref={context.arrowRef}
            className={clsx("absolute h-2 w-2 rotate-45", arrowColorClass)}
            style={{
              left: context.middlewareData.arrow?.x ?? "",
              top: context.middlewareData.arrow?.y ?? "",
              [staticSide]: "-4px",
            }}
          />
        </div>
      </FloatingPortal>
    );
  }
);
Tooltip.displayName = "Tooltip";
```

**Storybook Stories (`Tooltip.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Bold, HelpCircle, Italic } from "lucide-react";
import { Button } from "../button";
import { IconButton } from "../icon-button";
import { Tooltip, TooltipProvider, TooltipTrigger } from "./index";

const meta: Meta<typeof Tooltip> = {
  title: "Components/Tooltip",
  // We point to the Tooltip content component as the primary component for controls
  component: Tooltip,
  // Subcomponents tell Storybook how the parts are related
  subcomponents: { TooltipProvider, TooltipTrigger },
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: ["primary", "secondary"],
    },
    size: {
      control: "select",
      options: ["sm", "md", "lg"],
    },
    shape: {
      control: "select",
      options: ["full", "minimal", "sharp"],
    },
  },
  parameters: {
    docs: {
      description: {
        component:
          "A powerful, accessible tooltip built with Floating UI. It must be wrapped in a `TooltipProvider`.",
      },
    },
  },
  // The `render` function is used for all stories to provide the necessary context
  render: (args) => (
    <div className="flex justify-center items-center h-48">
      <TooltipProvider>
        <TooltipTrigger>
          <Button variant="secondary">Hover or Focus Me</Button>
        </TooltipTrigger>
        {/* Pass the story's args to the Tooltip content */}
        <Tooltip {...args}>This is a tooltip</Tooltip>
      </TooltipProvider>
    </div>
  ),
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    // You can control the tooltip's appearance here
    variant: "primary",
    size: "md",
    shape: "minimal",
  },
};

export const AllVariants: Story = {
  name: "All Variants",
  render: () => (
    <div className="flex items-center gap-6 pt-8">
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton aria-label="Primary Tooltip">
            <Bold />
          </IconButton>
        </TooltipTrigger>
        <Tooltip variant="primary">Primary Tooltip</Tooltip>
      </TooltipProvider>
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton aria-label="Secondary Tooltip">
            <Italic />
          </IconButton>
        </TooltipTrigger>
        <Tooltip variant="secondary">Secondary Tooltip</Tooltip>
      </TooltipProvider>
    </div>
  ),
};

export const AllSizesAndShapes: Story = {
  name: "All Sizes & Shapes",
  render: () => (
    <div className="flex items-center gap-6 pt-8">
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton size="sm" aria-label="Small Minimal">
            <HelpCircle className="h-4 w-4" />
          </IconButton>
        </TooltipTrigger>
        <Tooltip size="sm" shape="minimal">
          Small Minimal
        </Tooltip>
      </TooltipProvider>
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton size="md" aria-label="Medium Full">
            <HelpCircle className="h-5 w-5" />
          </IconButton>
        </TooltipTrigger>
        <Tooltip size="md" shape="full">
          Medium Full
        </Tooltip>
      </TooltipProvider>
      <TooltipProvider>
        <TooltipTrigger>
          <IconButton size="lg" aria-label="Large Sharp">
            <HelpCircle className="h-6 w-6" />
          </IconButton>
        </TooltipTrigger>
        <Tooltip size="lg" shape="sharp">
          Large Sharp
        </Tooltip>
      </TooltipProvider>
    </div>
  ),
};

export const DynamicPositioning: Story = {
  name: "Dynamic Positioning",
  parameters: {
    docs: {
      description: {
        story:
          "Place tooltips near the edge of the canvas to see them flip automatically.",
      },
    },
  },
  render: () => (
    <div className="w-full h-96 relative border border-dashed flex items-center justify-center">
      <div className="absolute top-2 left-2">
        <TooltipProvider>
          <TooltipTrigger>
            <IconButton aria-label="Top-left corner">
              <Bold />
            </IconButton>
          </TooltipTrigger>
          <Tooltip>Flipped to the bottom!</Tooltip>
        </TooltipProvider>
      </div>
      <div className="absolute bottom-2 right-2">
        <TooltipProvider>
          <TooltipTrigger>
            <IconButton aria-label="Bottom-right corner">
              <Italic />
            </IconButton>
          </TooltipTrigger>
          <Tooltip>This should stay on top.</Tooltip>
        </TooltipProvider>
      </div>
    </div>
  ),
};
```


### Component: `typography`

This section contains the source code for the `typography` component and its corresponding Storybook stories.

**Component Source (`src\lib\components\typography\index.tsx`)**
```tsx
import React from "react";

const variants = {
  h1: "scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl",
  h2: "scroll-m-20  text-3xl font-semibold tracking-tight first:mt-0",
  h3: "scroll-m-20 text-2xl font-semibold tracking-tight",
  h4: "scroll-m-20 text-xl font-semibold tracking-tight",
  p: "leading-7 [&:not(:first-child)]:mt-6",
  blockquote:
    "mt-6 border-l-2 border-graphite-primary pl-6 italic text-gray-600",
  highlight:
    "relative rounded bg-graphite-secondary px-[0.3rem] py-[0.2rem] text-sm font-semibold text-graphite-secondaryForeground",
  lead: "text-xl text-gray-500",
  large: "text-lg font-semibold",
  small: "text-sm font-medium leading-none",
  muted: "text-sm text-gray-500",
};

const variantToTagMap: Record<keyof typeof variants, React.ElementType> = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  p: "p",
  blockquote: "blockquote",
  highlight: "span",
  lead: "p",
  large: "div",
  small: "small",
  muted: "p",
};

// 1. Define the component's specific props
type TypographyOwnProps = {
  variant?: keyof typeof variants;
  className?: string;
};

// 2. Create a refined generic props type for the polymorphic component
// This type merges the component's own props (P) with the native props
// of the element (C), while ensuring no keys are accidentally omitted.
type PolymorphicComponentProps<
  C extends React.ElementType,
  P extends object
> = P & Omit<React.ComponentPropsWithoutRef<C>, keyof P>;

// 3. Create the final props type for our Typography component
// We add 'as' to the TypographyOwnProps to make it an explicit part of our own props.
type TypographyProps<C extends React.ElementType> = PolymorphicComponentProps<
  C,
  TypographyOwnProps & { as?: C }
>;

// 4. Create a generic Ref type
type PolymorphicRef<C extends React.ElementType> =
  React.ComponentPropsWithRef<C>["ref"];

// 5. Define the component's function signature with the correct types and a displayName property
type TypographyComponent = (<C extends React.ElementType = "p">(
  props: TypographyProps<C> & { ref?: PolymorphicRef<C> }
) => React.ReactElement | null) & {
  displayName?: string;
};

// 6. Implement the component using forwardRef and the correct types.
// We cast the result to TypographyComponent to ensure all type declarations are met.
export const Typography = React.forwardRef(
  <C extends React.HTMLElementType = "p">(
    { as, variant, className, children, ...restProps }: TypographyProps<C>,
    ref?: PolymorphicRef<C>
  ) => {
    const Component = as || variantToTagMap[variant] || "p";
    const combinedClassName = `${variants[variant]} ${className || ""}`.trim();

    return (
      <Component ref={ref} className={combinedClassName} {...restProps}>
        {children}
      </Component>
    );
  }
) as TypographyComponent;

Typography.displayName = "Typography";
```

**Storybook Stories (`Typography.stories.tsx`)**
```tsx
import type { Meta, StoryObj } from "@storybook/react";
import { Typography } from "./index";

const meta: Meta<typeof Typography> = {
  title: "Components/Typography",
  component: Typography,
  tags: ["autodocs"],
  argTypes: {
    variant: {
      control: "select",
      options: [
        "h1",
        "h2",
        "h3",
        "h4",
        "p",
        "blockquote",
        "code",
        "lead",
        "large",
        "small",
        "muted",
      ],
    },
    as: {
      control: "text",
      description:
        'Render the component as a different HTML tag (e.g., "span").',
    },
    children: {
      control: "text",
    },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    variant: "p",
    children:
      "This is a default paragraph. The quick brown fox jumps over the lazy dog.",
  },
};

export const Heading1: Story = {
  args: {
    variant: "h1",
    children: "This is an H1 Heading",
  },
};

export const AllVariants: Story = {
  render: () => (
    <div className="space-y-4">
      <Typography variant="h1">H1: The quick brown fox</Typography>
      <Typography variant="h2">H2: The quick brown fox</Typography>
      <Typography variant="h3">H3: The quick brown fox</Typography>
      <Typography variant="h4">H4: The quick brown fox</Typography>
      <Typography variant="p">
        p: The quick brown fox jumps over the lazy dog. This is a standard
        paragraph used for long-form content.
      </Typography>
      <Typography variant="lead">
        lead: The quick brown fox jumps over the lazy dog. This is a leading
        paragraph that stands out.
      </Typography>
      <Typography variant="large">
        large: The quick brown fox jumps over the lazy dog. For slightly larger,
        emphasized text.
      </Typography>
      <Typography variant="small">
        small: The quick brown fox jumps over the lazy dog. For fine print or
        less important details.
      </Typography>
      <Typography variant="muted">
        muted: The quick brown fox jumps over the lazy dog. For subtle, muted
        text.
      </Typography>
      <Typography variant="blockquote">
        blockquote: "The quick brown fox jumps over the lazy dog."
      </Typography>
      <Typography variant="p">
        Use <code>code</code> variant for inline code like{" "}
        <Typography variant="highlight">npm install your-library</Typography>
      </Typography>
    </div>
  ),
};

export const Polymorphic: Story = {
  args: {
    variant: "h1",
    as: "div", // Render an H1 style but with a <div> tag
    children: "This looks like an H1, but it is a div tag.",
  },
};
```


---

## React Context


### Source: `src\lib\context\List.context.ts`

```ts
import { createContext } from 'react'

export interface ListContextProps {
  isSelectionMode: boolean
  setIsSelectionMode: (value: boolean) => void
  selectedItems: Set<string | number>
  toggleSelection: (id: string | number) => void
  isReorderable: boolean
  startReorder: (id: string | number) => void
}

export const ListContext = createContext<ListContextProps | null>(null)
```


---

## Custom Hooks


### Source: `src\lib\hooks\use-calender.ts`

```ts
import {
  add,
  eachDayOfInterval,
  endOfMonth,
  endOfWeek,
  format,
  isAfter, // FIX: Import isAfter
  isBefore, // FIX: Import isBefore
  isSameDay,
  isSameMonth,
  isToday,
  startOfMonth,
  startOfWeek,
} from 'date-fns'
import { useMemo } from 'react'
// FIX: Use 'import type' for type-only imports
import type { DateRange } from 'react-day-picker'

export const useCalendar = (cursorDate: Date, value?: Date | DateRange, mode: 'single' | 'range' = 'single') => {
  const firstDayOfMonth = startOfMonth(cursorDate)
  const lastDayOfMonth = endOfMonth(cursorDate)
  const firstDayOfFirstWeek = startOfWeek(firstDayOfMonth)
  const lastDayOfLastWeek = endOfWeek(lastDayOfMonth)

  const daysInMonth = useMemo(
    () =>
      eachDayOfInterval({
        start: firstDayOfFirstWeek,
        end: lastDayOfLastWeek,
      }),
    [firstDayOfFirstWeek, lastDayOfLastWeek],
  )

  const getDayProps = (day: Date) => {
    // FIX: Use type guards to safely check for properties on 'value'
    const isValueDateRange = mode === 'range' && value && 'from' in value

    const isSelected =
      (mode === 'single' && value instanceof Date && isSameDay(day, value)) ||
      (isValueDateRange && ((value.from && isSameDay(day, value.from)) || (value.to && isSameDay(day, value.to))))

    const isRangeStart = isValueDateRange && value.from && isSameDay(day, value.from)

    const isRangeEnd = isValueDateRange && value.to && isSameDay(day, value.to)

    const isInRange = isValueDateRange && value.from && value.to && isAfter(day, value.from) && isBefore(day, value.to)

    return {
      isCurrentMonth: isSameMonth(day, cursorDate),
      isToday: isToday(day),
      isSelected,
      isRangeStart,
      isRangeEnd,
      isInRange,
    }
  }

  return {
    daysInMonth,
    weekdays: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    getDayProps,
  }
}
```


### Source: `src\lib\hooks\useShallowRouter.tsx`

```tsx
import { useCallback, useEffect, useMemo, useState } from "react";

// --- TYPE DEFINITIONS (Fix for TypeScript errors) ---
type HistoryMode = "search" | "pathname";

interface UseHistoryOptions {
  mode?: HistoryMode;
  paramName?: string;
  basePath?: string;
}

type Params = Record<string, string | number | boolean | null | undefined>;

// --- HOOK IMPLEMENTATION ---

// Custom useHistory Hook with configurable routing modes
const useShallowRouter = (options: UseHistoryOptions = {}) => {
  const { mode = "search", paramName = "path", basePath = "/" } = options;

  const [searchParams, setSearchParams] = useState(
    () => new URLSearchParams(window.location.search)
  );
  const [pathname, setPathname] = useState(() => window.location.pathname);

  // Get current path based on mode
  const currentPath = useMemo(() => {
    if (mode === "pathname") {
      // Extract path relative to basePath
      // FIX: Used template literal instead of concatenation
      if (pathname === basePath || pathname === `${basePath}/`) {
        return "/";
      }
      if (pathname.startsWith(basePath)) {
        return pathname.slice(basePath.length) || "/";
      }
      return "/";
    }
    // Search param mode
    return searchParams.get(paramName) || "/";
  }, [mode, pathname, searchParams, paramName, basePath]);

  // Get all other params except the routing param
  const otherParams = useMemo(() => {
    const params = new URLSearchParams(searchParams);
    params.delete(paramName);
    return params;
  }, [searchParams, paramName]);

  // Update state when browser navigation occurs (e.g., back/forward buttons)
  useEffect(() => {
    const handlePopState = () => {
      setSearchParams(new URLSearchParams(window.location.search));
      setPathname(window.location.pathname);
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  // Push new path to history
  const push = useCallback(
    (path: string, additionalParams: Params = {}, state: any = null) => {
      if (mode === "pathname") {
        // --- FEATURE: Handle pathname mode navigation ---
        const newPathname =
          path === "/" || !path ? basePath : `${basePath}${path}`;
        const newParams = new URLSearchParams();
        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string
            newParams.set(key, String(value));
          }
        });
        const newSearch = newParams.toString();
        const newUrl = `${newPathname}${newSearch ? `?${newSearch}` : ""}`;

        window.history.pushState(state, "", newUrl);
        setPathname(newPathname);
        setSearchParams(newParams);
      } else {
        // --- Original search mode logic ---
        const newParams = new URLSearchParams(window.location.search);
        if (path) {
          newParams.set(paramName, path);
        } else {
          newParams.delete(paramName);
        }

        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string to prevent ts(2345)
            newParams.set(key, String(value));
          } else {
            newParams.delete(key);
          }
        });

        const newUrl = `${window.location.pathname}?${newParams.toString()}`;
        window.history.pushState(state, "", newUrl);
        setSearchParams(newParams);
      }
    },
    [mode, basePath, paramName] // Updated dependencies
  );

  // Replace current path in history
  const replace = useCallback(
    (path: string, additionalParams: Params = {}, state: any = null) => {
      if (mode === "pathname") {
        // --- FEATURE: Handle pathname mode navigation ---
        const newPathname =
          path === "/" || !path ? basePath : `${basePath}${path}`;
        const newParams = new URLSearchParams();
        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            newParams.set(key, String(value));
          }
        });
        const newSearch = newParams.toString();
        const newUrl = `${newPathname}${newSearch ? `?${newSearch}` : ""}`;

        window.history.replaceState(state, "", newUrl);
        setPathname(newPathname);
        setSearchParams(newParams);
      } else {
        // --- Original search mode logic ---
        const newParams = new URLSearchParams(window.location.search);
        if (path) {
          newParams.set(paramName, path);
        } else {
          newParams.delete(paramName);
        }

        Object.entries(additionalParams).forEach(([key, value]) => {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string to prevent ts(2345)
            newParams.set(key, String(value));
          } else {
            newParams.delete(key);
          }
        });

        const newUrl = `${window.location.pathname}?${newParams.toString()}`;
        window.history.replaceState(state, "", newUrl);
        setSearchParams(newParams);
      }
    },
    [mode, basePath, paramName] // Updated dependencies
  );

  // Update only specific params without changing the path
  const updateParams = useCallback(
    (params: Params, replaceHistory = false) => {
      const newParams = new URLSearchParams(window.location.search);

      Object.entries(params).forEach(([key, value]) => {
        if (key !== paramName) {
          if (value !== null && value !== undefined) {
            // FIX: Ensure value is a string to prevent ts(2345)
            newParams.set(key, String(value));
          } else {
            newParams.delete(key);
          }
        }
      });

      const newUrl = `${window.location.pathname}?${newParams.toString()}`;

      if (replaceHistory) {
        window.history.replaceState(null, "", newUrl);
      } else {
        window.history.pushState(null, "", newUrl);
      }
      setSearchParams(newParams);
    },
    [paramName]
  );

  // Clear all params except the path
  const clearParams = useCallback(
    (keepPath = true) => {
      const newParams = new URLSearchParams();
      let newUrl = window.location.pathname;

      if (mode === "search" && keepPath && currentPath && currentPath !== "/") {
        newParams.set(paramName, currentPath);
      }

      const newSearchString = newParams.toString();
      if (newSearchString) {
        newUrl = `${newUrl}?${newSearchString}`;
      }

      window.history.pushState(null, "", newUrl);
      setSearchParams(newParams);
    },
    [currentPath, paramName, mode] // Updated dependencies
  );

  // Get a specific param value
  const getParam = useCallback(
    (key: string) => searchParams.get(key),
    [searchParams]
  );

  // Check if a param exists
  const hasParam = useCallback(
    (key: string) => searchParams.has(key),
    [searchParams]
  );

  // Navigation helpers
  const goBack = useCallback(() => window.history.back(), []);
  const goForward = useCallback(() => window.history.forward(), []);
  const go = useCallback((n: number) => window.history.go(n), []);

  return {
    path: currentPath,
    searchParams,
    otherParams,
    push,
    replace,
    goBack,
    goForward,
    go,
    updateParams,
    clearParams,
    getParam,
    hasParam,
    // Note: These values are snapshots and won't update on their own.
    // They are provided for convenience but could become stale.
    length: window.history.length,
    href: window.location.href,
    basename: window.location.pathname,
  };
};

export default useShallowRouter;
```


---

## Tailwind & Styling


### Source: `src\lib\tailwind\theme.css`

```css
/* src\lib\tailwind\theme.css */

@import url("https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap");
@import "tailwindcss";

@theme {
  /*
  |--------------------------------------------------------------------------
  | Project-Specific Theme Values
  |--------------------------------------------------------------------------
  */

  --font-manrope: manrope, sans-serif;

  /* Graphite Color Theme Definitions */
  --color-graphite-primary: hsl(0 0% 9%);            /* #171717 */
  --color-graphite-primaryForeground: hsl(0 0% 98%);  /* #FAFAFA */
  --color-graphite-secondary: hsl(0 0% 96.1%);       /* #F5F5F5 */
  --color-graphite-secondaryForeground: hsl(0 0% 9%); /* #171717 */
  --color-graphite-background: hsl(33 33% 98%);      /* #FDFBFA */
  --color-graphite-foreground: hsl(0 0% 9%);         /* #171717 */
  --color-graphite-card: hsl(0 0% 100%);             /* #FFFFFF */
  --color-graphite-cardForeground: hsl(0 0% 9%);
  --color-graphite-border: hsl(0 0% 93%);            /* #EDEDED */
  --color-graphite-ring: hsl(0 0% 9%);

  /*
  |--------------------------------------------------------------------------
  | Animations
  |--------------------------------------------------------------------------
  */

  /* 1. Define the animation keyframes */
  @keyframes menu-enter {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(-0.5rem);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  @keyframes menu-exit {
    from {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
    to {
      opacity: 0;
      transform: scale(0.9) translateY(-0.5rem);
    }
  }

  /* --- SELECT ANIMATIONS (Center-Out Clip-Path) --- */
  @keyframes select-enter-clip {
    from {
      opacity: 0;
      clip-path: inset(50% 0 50% 0);
    }
    to {
      opacity: 1;
      clip-path: inset(0 0 0 0);
    }
  }

  @keyframes select-exit-clip {
    from {
      opacity: 1;
      clip-path: inset(0 0 0 0);
    }
    to {
      opacity: 0;
      clip-path: inset(50% 0 50% 0);
    }
  }
  /* --- END SELECT ANIMATIONS --- */

  @keyframes submenu-enter-right {
    from { opacity: 0; transform: scale(0.95) translateX(-0.5rem); }
    to { opacity: 1; transform: scale(1) translateX(0); }
  }

  @keyframes submenu-enter-left {
    from { opacity: 0; transform: scale(0.95) translateX(0.5rem); }
    to { opacity: 1; transform: scale(1) translateX(0); }
  }

  @keyframes submenu-exit-right {
    from { opacity: 1; transform: scale(1) translateX(0); }
    to { opacity: 0; transform: scale(0.95) translateX(-0.5rem); }
  }

  @keyframes submenu-exit-left {
    from { opacity: 1; transform: scale(1) translateX(0); }
    to { opacity: 0; transform: scale(0.95) translateX(0.5rem); }
  }

  @keyframes check-in {
    from {
      opacity: 0;
      transform: scale(0.5) rotate(-90deg);
    }
    to {
      opacity: 1;
      transform: scale(1) rotate(0deg);
    }
  }


  /* 2. Create the `animate-*` utility classes from the keyframes */
  --animate-menu-enter: menu-enter 300ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-menu-exit: menu-exit 150ms cubic-bezier(0.4, 0, 1, 1) forwards;
  
  /* --- SELECT UTILITIES --- */
  --animate-select-enter: select-enter-clip 200ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-select-exit: select-exit-clip 1500ms cubic-bezier(0.4, 0, 1, 1) forwards;
  /* --- END SELECT UTILITIES --- */

  --animate-submenu-enter-right: submenu-enter-right 250ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-submenu-enter-left: submenu-enter-left 250ms cubic-bezier(0.2, 0, 0, 1) forwards;
  --animate-submenu-exit-right: submenu-exit-right 150ms cubic-bezier(0.4, 0, 1, 1) forwards;
  --animate-submenu-exit-left: submenu-exit-left 150ms cubic-bezier(0.4, 0, 1, 1) forwards;
  
  --animate-check-in: check-in 200ms cubic-bezier(0.2, 0, 0, 1) forwards;
}

@layer base {
  body {
    @apply font-manrope  text-gray-900;
  }
}


input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
input[type="number"] {
  -moz-appearance: none;
}
@media only screen and (hover: none) and (pointer: coarse) {
  * {
    cursor: default !important;
    user-select: none;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
  }
  ::-webkit-scrollbar {
  display: none; /* Hides the scrollbar visually */
  width: 0; /* Removes any allocated space for the scrollbar */
  background: transparent; /* Makes the scrollbar track transparent */
}

}
  [data-vaul-drawer][data-vaul-drawer-direction="bottom"]::after {
    opacity: var(--vaul-after-display, block);
  }

    [data-vaul-drawer][data-vaul-drawer-direction="left"]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction="right"]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction="top"]::after {
    opacity: var(--vaul-after-display, block);
  }

  
/*  */
  [data-vaul-drawer][data-vaul-drawer-direction=bottom]::after {
    opacity: var(--vaul-after-display, block);
  }

    [data-vaul-drawer][data-vaul-drawer-direction=left]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction=right]::after {
    opacity: var(--vaul-after-display, block);
  }

      [data-vaul-drawer][data-vaul-drawer-direction=top]::after {
    opacity: var(--vaul-after-display, block);
  }

  textarea {
  resize: none;
}
```
